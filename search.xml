<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/Python%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<ul>
<li>[[概述]]<ul>
<li>[[概述#可用性注释|可用性注释]]</li>
</ul>
</li>
<li>[[内置函数]]</li>
<li>[[内置常量]]<ul>
<li>[[内置常量#由site模块添加的常量|由site模块添加的常量]]</li>
</ul>
</li>
<li>[[内置类型]]<ul>
<li>[[内置类型#逻辑值检测|逻辑值检测]]</li>
<li>[[内置类型#布尔运算 — <code>and</code>, <code>or</code>, <code>not</code>|布尔运算 — <code>and</code>, <code>or</code>, <code>not</code>]]</li>
<li>[[内置类型#比较运算|比较运算]]</li>
<li>[[内置类型#数字类型 —<code>int</code>,<code>float</code>,<code>complex</code>|数字类型 —<code>int</code>,<code>float</code>,<code>complex</code>]]</li>
<li>[[内置类型#迭代器类型|迭代器类型]]</li>
<li>[[内置类型#序列类型 — <code>list``tuple``range</code>|序列类型 — <code>list``tuple``range</code>]]</li>
<li>[[内置类型#文本序列类型 —<code>str</code>|文本序列类型 —<code>str</code>]]</li>
<li>[[内置类型#二进制序列类型 —<code>bytes``bytearray``memoryview</code>|二进制序列类型 —<code>bytes``bytearray``memoryview</code>]]</li>
<li>[[内置类型#集合类型 — <code>set``frozenset</code>|集合类型 — <code>set``frozenset</code>]]</li>
<li>[[内置类型#映射类型 —<code>dict</code>|映射类型 —<code>dict</code>]]</li>
<li>[[内置类型#上下文管理器类型|上下文管理器类型]]</li>
<li>[[内置类型#类型注解的类型 —Generic Alias|类型注解的类型 —Generic Alias]]</li>
<li>[[内置类型#其他内置类型|其他内置类型]]</li>
<li>[[内置类型#特殊属性|特殊属性]]</li>
<li>[[内置类型#整数字符串转换长度限制|整数字符串转换长度限制]]</li>
</ul>
</li>
<li>[[内置异常]]<ul>
<li>[[内置异常#异常上下文|异常上下文]]</li>
<li>[[内置异常#从内置异常继承|从内置异常继承]]</li>
<li>[[内置异常#基类|基类]]</li>
<li>[[内置异常#具体异常|具体异常]]</li>
<li>[[内置异常#警告|警告]]</li>
<li>[[内置异常#异常层次结构|异常层次结构]]</li>
</ul>
</li>
<li>[[文本处理服务]]<ul>
<li>[[文本处理服务#string — 常见的字符串操作|string — 常见的字符串操作]]</li>
<li>[[文本处理服务#re — 正则表达式操作|re — 正则表达式操作]]</li>
<li>[[文本处理服务#difflib — 计算差异的辅助工具|difflib — 计算差异的辅助工具]]</li>
<li>[[文本处理服务#textwrap — 文本自动换行与填充|textwrap — 文本自动换行与填充]]</li>
<li>[[文本处理服务#unicodedata — Unicode 数据库|unicodedata — Unicode 数据库]]</li>
<li>[[文本处理服务#stringprep — 因特网字符串预备|stringprep — 因特网字符串预备]]</li>
<li>[[文本处理服务#readline — GNU readline 接口|readline — GNU readline 接口]]</li>
<li>[[文本处理服务#rlcompleter — GNU readline 的补全函数|rlcompleter — GNU readline 的补全函数]]</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python 标准库</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/Python%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="Python学习规划"><a href="#Python学习规划" class="headerlink" title="Python学习规划"></a>Python学习规划</h3><h4 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h4><ol>
<li>Python基础：掌握Python的基本语法，学习Python的数据类型、控制流、函数等基础知识。</li>
<li>Numpy：Python的数值计算库，包括pandas之类的很多分析库都建立在numpy基础上。</li>
<li>Pandas：一款不断进步的Python数据科学库，它的数据结构十分适合做数据处理，并且pandas纳入了大量分析函数方法，以及常用统计学模型、可视化处理。</li>
<li>Matplotlib：Python的2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。</li>
<li>数据基础：理解数据分析的定义，了解数据分析的意义和需求类型。</li>
<li>机器学习：面对海量数据需求，越来越多的数据分析岗位需要有大数据处理能力和机器学习技巧，这些技能才是你的核心竞争力。</li>
</ol>
<hr>
<h4 id="自动化办公"><a href="#自动化办公" class="headerlink" title="自动化办公"></a>自动化办公</h4><ol>
<li>Python基础：掌握Python的基本语法，学习Python的数据类型、控制流、函数等基础知识。</li>
<li>Excel自动化：使用xlwings和pandas这两个库，基本能解决Excel自动化的所有问题。</li>
<li>PPT自动化：Python操作PPT的库有pywin32com、pptx，可以创建、修改PPT文件。</li>
<li>Word自动化：Python操作Word的库有python-docx、import docx、pypiwin32、import win32com等，可以实现对Word文件的增删改查。</li>
<li>邮件处理：Python处理邮件也是极其便利的，smtplib、imaplib、email三个库配合使用，实现邮件编写、发送、接收、读取等一系列自动化操作。</li>
<li>文件批量处理：Python在处理批量操作有得天独厚的优势，成千上万的文件修改可能只需几秒的时间。</li>
</ol>
<hr>
<h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><ol>
<li>Python基础：掌握Python的基本语法，学习Python的数据类型、控制流、函数等基础知识。</li>
<li>HTTP协议：爬虫必须掌握HTTP协议，并了解HTTP协议的请求与响应过程。</li>
<li>正则表达式：在爬虫过程中，需要从文本中提取出目标信息，因此需要学习正则表达式。</li>
<li>Python爬虫库：学习使用Python爬虫库。</li>
</ol>
<p><br><br><br><br></p>
<hr>
<p>![[Pasted image 20231227092621.png]]</p>
]]></content>
      <tags>
        <tag>Python 学习规划</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/Python%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h3 id="什么是Python"><a href="#什么是Python" class="headerlink" title="什么是Python"></a>什么是Python</h3><h4 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h4><p><strong>Python</strong>由<strong>荷兰</strong>国家数学与计算机科学研究中心的<strong>吉多·范罗苏姆</strong>于<strong>1990</strong>年代初设计，作为一门叫做ABC语言的替代品。 Python提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言，随着版本的不断更新和语言新功能的添加，逐渐被用于独立的、大型项目的开发。 Python在各个编程语言中比较适合新手学习，Python解释器易于扩展，可以使用C、C++或其他可以通过C调用的语言扩展新的功能和数据类型。Python也可用于可定制化软件中的扩展程序语言。Python丰富的标准库，提供了适用于各个主要系统平台的源码或机器码。</p>
<h4 id="面向领域"><a href="#面向领域" class="headerlink" title="面向领域"></a>面向领域</h4><ol>
<li><strong>Web开发</strong>：Python有许多Web开发框架和库，如Django、Flask等，这些框架和库使得Python成为了Web开发的首选语言。</li>
<li><strong>数据分析和人工智能</strong>：Python有许多用于数据分析和人工智能的库，如NumPy、Pandas、SciPy等，这些库可以帮助科学家、工程师和数据分析师处理和分析数据。</li>
<li><strong>机器学习</strong>：Python有许多用于机器学习的库，如Scikit-learn、TensorFlow、PyTorch等，这些库可以帮助程序员训练和部署机器学习模型。</li>
<li><strong>自动化</strong>：Python有许多用于自动化的库和工具，如Selenium、Puppet、Ansible等，这些工具可以帮助程序员自动执行重复性任务。</li>
<li><strong>网络编程</strong>：Python有许多用于网络编程的库和框架，如SocketIO、Pyro等，这些库和框架可以帮助开发人员快速构建网络应用程序。</li>
<li><strong>其他领域</strong>：Python还有许多其他领域的应用，如GUI开发、多媒体处理、桌面应用程序开发等。</li>
</ol>
<h4 id="语言优点"><a href="#语言优点" class="headerlink" title="语言优点"></a>语言优点</h4><p><strong>1. 语法简单</strong></p>
<ul>
<li>和传统的 C&#x2F;C++、Java、C# 等语言相比，Python对代码格式的要求没有那么严格，这种宽松使得用户在编写代码时比较舒服，不用在细枝末节上花费太多精力。 我来举两个典型的例子：<br>  -Python 不要求在每个语句的最后写分号，当然写上也没错；<br>  -定义变量时不需要指明类型，甚至可以给同一个变量赋值不同类型的数据。</li>
</ul>
<blockquote>
<p>这两点也是 <a href="http://c.biancheng.net/php/">PHP</a>、<a href="http://c.biancheng.net/js/">JavaScript</a>、<a href="http://c.biancheng.net/matlab/">MATLAB</a> 等常见脚本语言都具备的特性。</p>
</blockquote>
<ul>
<li>Python 是一种代表极简主义的编程语言，阅读一段排版优美的 Python 代码，就像在阅读一个英文段落，非常贴近人类语言，所以人们常说，Python 是一种具有伪代码特质的编程语言。</li>
<li>伪代码（Pseudo Code）是一种算法描述语言，它介于自然语言和编程语言之间，使用伪代码的目的是为了使被描述的算法可以容易地以任何一种编程语言（Pascal，C，Java，etc）实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。</li>
</ul>
<blockquote>
<p>如果你学过<a href="http://c.biancheng.net/data_structure/">数据结构</a>，阅读过严蔚敏的书籍，那你一定知道什么是伪代码。</p>
</blockquote>
<ul>
<li>为什么说简单就是杀手锏？一旦简单了，一件事情就会变得很纯粹；我们在开发 Python 程序时，可以专注于解决问题本身，而不用顾虑语法的细枝末节。在简单的环境中做一件纯粹的事情，那简直是一种享受。</li>
</ul>
<p><strong>2. Python 是开源的</strong></p>
<ul>
<li><p>开源，也即开放源代码，意思是所有用户都可以看到源代码。</p>
</li>
<li><p>Python 的开源体现在两方面：</p>
<blockquote>
<p><strong>① 程序员使用 Python 编写的代码是开源的。</strong><br>比如我们开发了一个 BBS 系统，放在互联网上让用户下载，那么用户下载到的就是该系统的所有源代码，并且可以随意修改。这也是解释型语言本身的特性，想要运行程序就必须有源代码。<br><strong>② Python 解释器和模块是开源的。</strong><br>官方将 Python 解释器和模块的代码开源，是希望所有 Python 用户都参与进来，一起改进 Python 的性能，弥补 Python 的漏洞，代码被研究的越多就越健壮。</p>
</blockquote>
</li>
<li><p>这个世界上总有那么一小撮人，他们或者不慕名利，或者为了达到某种目的，会不断地加强和改善 Python。千万不要认为所有人都是只图眼前利益的，总有一些精英会放长线钓大鱼，总有一些极客会做一些炫酷的事情。</p>
</li>
</ul>
<p><strong>3. Python 是免费的</strong></p>
<ul>
<li>开源并不等于免费，开源软件和免费软件是两个概念，只不过大多数的开源软件也是免费软件；Python 就是这样一种语言，它既开源又免费。</li>
<li>用户使用 Python 进行开发或者发布自己的程序，不需要支付任何费用，也不用担心版权问题，即使作为商业用途，Python 也是免费的。</li>
</ul>
<p><strong>4. Python 是高级语言</strong></p>
<ul>
<li>这里所说的高级，是指 Python 封装较深，屏蔽了很多底层细节，比如 Python 会自动管理内存（需要时自动分配，不需要时自动释放）。</li>
<li>高级语言的优点是使用方便，不用顾虑细枝末节；缺点是容易让人浅尝辄止，知其然不知其所以然。</li>
</ul>
<p><strong>5. Python 是解释型语言，能跨平台</strong></p>
<ul>
<li>解释型语言一般都是跨平台的（可移植性好），Python 也不例外，我们已经在<a href="https://blog.csdn.net/yelitoudu/article/details/117379736">《编译型语言和解释型语言的区别》</a>中进行了讲解，这里不再赘述。<br>  <strong>Python 是面向对象的编程语言</strong></li>
<li>面向对象是现代编程语言一般都具备的特性，否则在开发中大型程序时会捉襟见肘。</li>
<li>Python 支持面向对象，但它不强制使用面向对象。Java 是典型的面向对象的编程语言，但是它强制必须以类和对象的形式来组织代码。</li>
</ul>
<p><strong>6. Python 功能强大（模块众多）</strong></p>
<ul>
<li>Python 的模块众多，基本实现了所有的常见的功能，从简单的字符串处理，到复杂的 3D 图形绘制，借助 Python 模块都可以轻松完成。</li>
<li>Python 社区发展良好，除了 Python 官方提供的核心模块，很多第三方机构也会参与进来开发模块，这其中就有 Google、Facebook、Microsoft 等软件巨头。即使是一些小众的功能，Python 往往也有对应的开源模块，甚至有可能不止一个模块。</li>
</ul>
<p><strong>7. Python 可扩展性强</strong></p>
<ul>
<li>Python 的可扩展性体现在它的模块，Python 具有脚本语言中最丰富和强大的类库，这些类库覆盖了文件 I&#x2F;O、GUI、网络编程、数据库访问、文本操作等绝大部分应用场景。</li>
<li>这些类库的底层代码不一定都是 Python，还有很多 C&#x2F;C++ 的身影。当需要一段关键代码运行速度更快时，就可以使用 C&#x2F;C++ 语言实现，然后在 Python 中调用它们。Python 能把其它语言“粘”在一起，<strong>所以被称为“胶水语言”</strong>。</li>
<li><strong>Python 依靠其良好的扩展性，在一定程度上弥补了运行效率慢的缺点。</strong></li>
</ul>
<h4 id="语言缺点"><a href="#语言缺点" class="headerlink" title="语言缺点"></a>语言缺点</h4><p><strong>1. 运行速度慢</strong></p>
<ul>
<li>运行速度慢是解释型语言的通病，Python 也不例外。</li>
<li>Python 速度慢不仅仅是因为一边运行一边“翻译”源代码，还因为 Python<br>  是高级语言，屏蔽了很多底层细节。这个代价也是很大的，Python 要多做很多工作，有些工作是很消耗资源的，比如管理内存。</li>
<li>Python 的运行速度几乎是最慢的，不但远远慢于 C&#x2F;C++，还慢于 Java。</li>
<li>但是速度慢的缺点往往也不会带来什么大问题。首先是计算机的硬件速度运来越快，多花钱就可以堆出高性能的硬件，硬件性能的提升可以弥补软件性能的不足。</li>
<li>其次是有些应用场景可以容忍速度慢，比如网站，用户打开一个网页的大部分时间是在等待网络请求，而不是等待服务器执行网页程序。服务器花 1ms 执行程序，和花 20ms 执行程序，对用户来说是毫无感觉的，因为网络连接时间往往需要 500ms 甚至 2000ms。</li>
</ul>
<p><strong>2. 代码加密困难</strong></p>
<ul>
<li>不像编译型语言的源代码会被编译成可执行程序，Python 是直接运行源代码，因此对源代码加密比较困难。</li>
<li>开源是软件产业的大趋势，传统程序员需要转变观念。</li>
</ul>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python Python介绍</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/Python%E4%B8%BB%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="认知与规划"><a href="#认知与规划" class="headerlink" title="认知与规划"></a>认知与规划</h2><ul>
<li>[[Python学习路线]]<ul>
<li>[[Python学习路线#数据分析|数据分析]]</li>
<li>[[Python学习路线#自动化办公|自动化办公]]</li>
<li>[[Python学习路线#爬虫|网络爬虫]]</li>
</ul>
</li>
<li>[[Python是什么]]<ul>
<li>[[Python是什么#诞生|Python诞生]]</li>
<li>[[Python是什么#面向领域|面向领域]]</li>
<li>[[Python是什么#语言优点|语言优点]]</li>
<li>[[Python是什么#语言缺点|语言缺点]]</li>
</ul>
</li>
</ul>
<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li>[[Python教程]]</li>
<li>[[Python标准库]]</li>
<li>[[术语对照表]]</li>
</ul>
<h2 id="Python基础知识"><a href="#Python基础知识" class="headerlink" title="Python基础知识"></a>Python基础知识</h2><h3 id="基础认知"><a href="#基础认知" class="headerlink" title="基础认知"></a>基础认知</h3><ul>
<li>[[编辑器PyCharm快捷键]]</li>
<li>[[字面量]]</li>
<li>[[注释]]</li>
<li>[[变量]]<ul>
<li>[[变量#什么是变量|什么是变量]]</li>
<li>[[变量#变量的定义格式|变量的定义格式]]</li>
</ul>
</li>
<li>[[数据类型]]<ul>
<li>[[数据类型#主要三类数据类型|常用3类]]</li>
<li>[[数据类型#验证数据类型|type函数]]</li>
</ul>
</li>
<li>[[标识符]]<ul>
<li>[[标识符#什么是标识符|标识符定义]]</li>
<li>[[标识符#标识符命名规则|命名规则]]</li>
</ul>
</li>
<li>[[运算符]]<ul>
<li>[[运算符#算术运算符|算术运算符]]</li>
<li>[[运算符#赋值运算符|赋值运算符]]</li>
<li>[[运算符#复合赋值运算符|复合赋值运算符]]</li>
</ul>
</li>
<li>[[数据类型转换]]<ul>
<li>[[数据类型转换#常用转换语句|常用转换语句]]</li>
</ul>
</li>
<li>[[字符串]]<ul>
<li>[[字符串#字符串3种定义方式|定义语法]]</li>
<li>[[字符串#字符串的拼接|字符串拼接]]</li>
<li>[[字符串#字符串的格式化|字符串格式化]]</li>
<li>[[字符串#格式化的精度控制|精度控制]]</li>
<li>[[字符串#快捷格式化|快捷格式化]]</li>
<li>[[字符串#表达式格式化|表达式格式化]]</li>
</ul>
</li>
<li>[[获取键盘输入]]</li>
<li>[[布尔类型]]</li>
</ul>
<h3 id="异常与模块"><a href="#异常与模块" class="headerlink" title="异常与模块"></a>异常与模块</h3><ul>
<li>[[异常]]<ul>
<li>[[异常#异常的捕获|异常的捕获]]</li>
<li>[[异常#异常传递性|异常的传递性]]</li>
</ul>
</li>
<li>[[模块]]<ul>
<li>[[模块#什么是模块|模块定义]]</li>
<li>[[模块#模块导入方式|模块的导入方式]]</li>
<li>[[模块#自定义模块|自定义模块]]</li>
<li>[[模块#模块测试|模块测试]]</li>
<li>[[模块#自定义包|自定义包]]</li>
<li>[[模块#第三方包|第三方包]]</li>
</ul>
</li>
</ul>
<h3 id="Python语句"><a href="#Python语句" class="headerlink" title="Python语句"></a>Python语句</h3><ul>
<li>[[判断if语句]]</li>
<li>[[循环语句while]]</li>
<li>[[循环for]]<ul>
<li>[[循环for#语法|基本语法]]</li>
<li>[[循环for#语句range|range]]</li>
<li>[[循环for#临时变量作用域|临时变量作用域]]</li>
<li>[[循环for#乘法表|乘法表]]</li>
</ul>
</li>
<li>[[语句continue和break]]</li>
<li>[[函数]]<ul>
<li>[[函数#函数定义|函数定义]]</li>
<li>[[函数#函数返回值|返回值]]</li>
<li>[[函数#函数说明文档|函数说明文档]]</li>
<li>[[函数#变量作用域|函数变量作用域]]</li>
<li>[[函数#关键词global|global]]</li>
</ul>
</li>
<li>[[函数进阶]]<ul>
<li>[[函数进阶#多返回值|多返回值]]</li>
<li>[[函数进阶#函数参数|函数参数]]</li>
<li>[[函数进阶#函数作为参数传递|函数作为参数传递]]</li>
<li>[[函数进阶#匿名函数lambda|匿名函数lambda]]</li>
</ul>
</li>
</ul>
<h3 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h3><ul>
<li>[[数据容器对比]]<ul>
<li>[[数据容器对比#分类|分类]]</li>
<li>[[数据容器对比#特点对比|特点对比]]</li>
<li>[[数据容器对比#应用场景|应用场景]]</li>
<li>[[数据容器对比#通用操作-遍历|通用操作-遍历]]</li>
<li>[[数据容器对比#通用统计|通用统计方法]]</li>
<li>[[数据容器对比#通用功能|通用功能]]<ul>
<li>[[数据容器对比#容器转列表|转列表]]</li>
<li>[[数据容器对比#容器转元组|转元组]]</li>
<li>[[数据容器对比#容器转字符串|转字符串]]</li>
<li>[[数据容器对比#容器转集合|转集合]]</li>
<li>[[数据容器对比#通用排序(sorted方法)|通用排序(sorted方法)]]</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><ul>
<li>[[序列]]</li>
<li>[[列表]]<ul>
<li>[[列表#定义语法|定义语法]]</li>
<li>[[列表#下标索引|下标索引]]</li>
<li>[[列表#列表方法|列表方法]]<ul>
<li>[[列表#index|index]]</li>
<li>[[列表#赋值|赋值覆盖]]</li>
<li>[[列表#insert|insert]]</li>
<li>[[列表#append|append]]</li>
<li>[[列表#extend|extend]]</li>
<li>[[列表#del和pop|del和pop]]</li>
<li>[[列表#remove|remove]]</li>
<li>[[列表#clear|clear]]</li>
<li>[[列表#count|count]]</li>
<li>[[列表#len|len]]</li>
</ul>
</li>
</ul>
</li>
<li>[[元组]]<ul>
<li>[[元组#定义语法|定义语法]]</li>
<li>[[元组#查找方法index|方法index]]</li>
<li>[[元组#统计方法count|方法count]]</li>
<li>[[元组#元组长度len|方法len]]</li>
</ul>
</li>
<li>[[字符容器]]<ul>
<li>[[字符容器#操作汇总|操作汇总]]</li>
<li>[[字符容器#方法index|方法index]]</li>
<li>[[字符容器#方法replace|方法replace]]</li>
<li>[[字符容器#方法split|方法split]]</li>
<li>[[字符容器#方法strip|方法strip]]</li>
<li>[[字符容器#方法count|方法count]]</li>
<li>[[字符容器#方法len|方法len]]</li>
<li>[[字符容器#字符串大小比较|字符串大小比较]]</li>
</ul>
</li>
</ul>
<h4 id="非序列"><a href="#非序列" class="headerlink" title="非序列"></a>非序列</h4><ul>
<li>[[集合]]<ul>
<li>[[集合#操作总结|操作总结]]</li>
<li>[[集合#集合的定义|集合定义]]</li>
<li>[[集合#方法add|方法add]]</li>
<li>[[集合#方法remove|方法remove]]</li>
<li>[[集合#方法pop|方法pop]]</li>
<li>[[集合#方法clear|方法clear]]</li>
<li>[[集合#方法difference|方法difference]]</li>
<li>[[集合#方法difference_update|方法difference_update]]</li>
<li>[[集合#方法union|方法union]]</li>
</ul>
</li>
<li>[[字典]]<ul>
<li>[[字典#操作总结|操作总结]]</li>
<li>[[字典#字典定义|字典定义]]</li>
<li>[[字典#增加与更新|元素增加与更新]]</li>
<li>[[字典#方法pop|方法pop]]</li>
<li>[[字典#方法clear|方法clear]]</li>
<li>[[字典#方法keys|方法keys]]</li>
<li>[[字典#方法len|方法len]]</li>
<li>[[字典#字典遍历|字典遍历]]</li>
<li>[[字典#案例|案例]]</li>
</ul>
</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>[[文件操作]]<ul>
<li>[[文件操作#文件编码概念|编码概念]]</li>
<li>[[文件操作#文件读取open|方法open]]</li>
<li>[[文件操作#方法read-readlines-readline|方法read]]</li>
<li>[[文件操作#文件遍历|文件遍历]]</li>
<li>[[文件操作#语句with-open-as|with语句]]</li>
<li>[[文件操作#写入操作|w模式]]</li>
<li>[[文件操作#追加写入|a模式]]</li>
</ul>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>[[对象]]</li>
</ul>
<h2 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h2><p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python主页</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><p>定义元组使用小括号, 且使用逗号隔开各个数据, 数据可以使不同的数据类型</p>
<div style = "color: red"><b>元组是一个无法修改内容的序列</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义元组字面量</span></span><br><span class="line">(元素, 元素, 元素, 元素)</span><br><span class="line"><span class="comment"># 定义元组变量</span></span><br><span class="line">变量名称 = (元素, 元素, 元素, 元素)</span><br><span class="line"><span class="comment"># 定义空元组</span></span><br><span class="line">变量名称 = ()</span><br><span class="line">变量名称 = <span class="built_in">tuple</span>()</span><br><span class="line"><span class="comment"># 定义单个元素的元组, 必须加个逗号</span></span><br><span class="line">t4 = <span class="built_in">tuple</span>(<span class="string">&quot;hello&quot;</span>, )</span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="查找方法index"><a href="#查找方法index" class="headerlink" title="查找方法index"></a>查找方法index</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;happy&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;在元组中查找world的下标是: <span class="subst">&#123;t1.index(<span class="string">&quot;world&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是: 1</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="统计方法count"><a href="#统计方法count" class="headerlink" title="统计方法count"></a>统计方法count</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;happy&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;在元组中查找hello的个数是: <span class="subst">&#123;t1.count(<span class="string">&quot;hello&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是: 2</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="元组长度len"><a href="#元组长度len" class="headerlink" title="元组长度len"></a>元组长度len</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;happy&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;在元组中查找元组的长度是: <span class="subst">&#123;<span class="built_in">len</span>(t1)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是: 3</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python 元组 index count len</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/string%20---%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>此模块中定义的常量为：</p>
<p><code>string.``ascii_letters</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.ascii_letters" title="永久链接至目标"></a></p>
<p>下文所述 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.ascii_lowercase" title="string.ascii_lowercase"><code>ascii_lowercase</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.ascii_uppercase" title="string.ascii_uppercase"><code>ascii_uppercase</code></a> 常量的拼连。 该值不依赖于语言区域。</p>
<p><code>string.``ascii_lowercase</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.ascii_lowercase" title="永久链接至目标"></a></p>
<p>小写字母 <code>&#39;abcdefghijklmnopqrstuvwxyz&#39;</code>。 该值不依赖于语言区域，不会发生改变。</p>
<p><code>string.``ascii_uppercase</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.ascii_uppercase" title="永久链接至目标"></a></p>
<p>大写字母 <code>&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code>。 该值不依赖于语言区域，不会发生改变。</p>
<p><code>string.``digits</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.digits" title="永久链接至目标"></a></p>
<p>字符串 <code>&#39;0123456789&#39;</code>。</p>
<p><code>string.``hexdigits</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.hexdigits" title="永久链接至目标"></a></p>
<p>字符串 <code>&#39;0123456789abcdefABCDEF&#39;</code>。</p>
<p><code>string.``octdigits</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.octdigits" title="永久链接至目标"></a></p>
<p>字符串 <code>&#39;01234567&#39;</code>。</p>
<p><code>string.``punctuation</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.punctuation" title="永久链接至目标"></a></p>
<p>由在 <code>C</code> 区域设置中被视为标点符号的 ASCII 字符所组成的字符串: <code>!&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~</code>.</p>
<p><code>string.``printable</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.printable" title="永久链接至目标"></a></p>
<p>由被视为可打印符号的 ASCII 字符组成的字符串。 这是 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.digits" title="string.digits"><code>digits</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.ascii_letters" title="string.ascii_letters"><code>ascii_letters</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.punctuation" title="string.punctuation"><code>punctuation</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.whitespace" title="string.whitespace"><code>whitespace</code></a> 的总和。</p>
<p><code>string.``whitespace</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.whitespace" title="永久链接至目标"></a></p>
<p>由被视为空白符号的 ASCII 字符组成的字符串。 其中包括空格、制表、换行、回车、进纸和纵向制表符。</p>
<h2 id="自定义字符串格式化"><a href="#自定义字符串格式化" class="headerlink" title="自定义字符串格式化"></a>自定义字符串格式化</h2><p>内置的字符串类提供了通过使用 <a href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a> 所描述的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>format()</code></a> 方法进行复杂变量替换和值格式化的能力。 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#module-string" title="string: Common string operations."><code>string</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="string.Formatter"><code>Formatter</code></a> 类允许你使用与内置 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>format()</code></a> 方法相同的实现来创建并定制你自己的字符串格式化行为。</p>
<p><em>class</em> <code>string.``Formatter</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="string.Formatter"><code>Formatter</code></a> 类包含下列公有方法：</p>
<p><code>format</code>(<em>format_string</em>, <em>&#x2F;</em>, <em>*args</em>, <em>**kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.format" title="永久链接至目标"></a></p>
<p>首要的 API 方法。 它接受一个格式字符串和任意一组位置和关键字参数。 它只是一个调用 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.vformat" title="string.Formatter.vformat"><code>vformat()</code></a> 的包装器。</p>
<p>在 3.7 版更改: 格式字符串参数现在是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#positional-only-parameter">仅限位置参数</a>。</p>
<p><code>vformat</code>(<em>format_string</em>, <em>args</em>, <em>kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.vformat" title="永久链接至目标"></a></p>
<p>此函数执行实际的格式化操作。 它被公开为一个单独的函数，用于需要传入一个预定义字母作为参数，而不是使用 <code>*args</code> 和 <code>**kwargs</code> 语法将字典解包为多个单独参数并重打包的情况。 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.vformat" title="string.Formatter.vformat"><code>vformat()</code></a> 完成将格式字符串分解为字符数据和替换字段的工作。 它会调用下文所述的几种不同方法。</p>
<p>此外，<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="string.Formatter"><code>Formatter</code></a> 还定义了一些旨在被子类替换的方法：</p>
<p><code>parse</code>(<em>format_string</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.parse" title="永久链接至目标"></a></p>
<p>循环遍历 format_string 并返回一个由可迭代对象组成的元组 (<em>literal_text</em>, <em>field_name</em>, <em>format_spec</em>, <em>conversion</em>)。 它会被 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.vformat" title="string.Formatter.vformat"><code>vformat()</code></a> 用来将字符串分解为文本字面值或替换字段。</p>
<p>元组中的值在概念上表示一段字面文本加上一个替换字段。 如果没有字面文本（如果连续出现两个替换字段就会发生这种情况），则 <em>literal_text</em> 将是一个长度为零的字符串。 如果没有替换字段，则 <em>field_name</em>, <em>format_spec</em> 和 <em>conversion</em> 的值将为 <code>None</code>。</p>
<p><code>get_field</code>(<em>field_name</em>, <em>args</em>, <em>kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.get_field" title="永久链接至目标"></a></p>
<p>给定 <em>field_name</em> 作为 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.parse" title="string.Formatter.parse"><code>parse()</code></a> (见上文) 的返回值，将其转换为要格式化的对象。 返回一个元组 (obj, used_key)。 默认版本接受在 <a href="https://www.python.org/dev/peps/pep-3101"><strong>PEP 3101</strong></a> 所定义形式的字符串，例如 “0[name]” 或 “label.title”。 <em>args</em> 和 <em>kwargs</em> 与传给 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.vformat" title="string.Formatter.vformat"><code>vformat()</code></a> 的一样。 返回值 <em>used_key</em> 与 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.get_value" title="string.Formatter.get_value"><code>get_value()</code></a> 的 <em>key</em> 形参具有相同的含义。</p>
<p><code>get_value</code>(<em>key</em>, <em>args</em>, <em>kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.get_value" title="永久链接至目标"></a></p>
<p>提取给定的字段值。 <em>key</em> 参数将为整数或字符串。 如果是整数，它表示 <em>args</em> 中位置参数的索引；如果是字符串，它表示 <em>kwargs</em> 中的关键字参数名。</p>
<p><em>args</em> 形参会被设为 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.vformat" title="string.Formatter.vformat"><code>vformat()</code></a> 的位置参数列表，而 <em>kwargs</em> 形参会被设为由关键字参数组成的字典。</p>
<p>对于复合字段名称，仅会为字段名称的第一个组件调用这些函数；后续组件会通过普通属性和索引操作来进行处理。</p>
<p>因此举例来说，字段表达式 ‘0.name’ 将导致调用 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.get_value" title="string.Formatter.get_value"><code>get_value()</code></a> 时附带 <em>key</em> 参数值 0。 在 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.get_value" title="string.Formatter.get_value"><code>get_value()</code></a> 通过调用内置的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 函数返回后将会查找 <code>name</code> 属性。</p>
<p>如果索引或关键字引用了一个不存在的项，则将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p><code>check_unused_args</code>(<em>used_args</em>, <em>args</em>, <em>kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.check_unused_args" title="永久链接至目标"></a></p>
<p>在必要时实现对未使用参数进行检测。 此函数的参数是是格式字符串中实际引用的所有参数键的集合（整数表示位置参数，字符串表示名称参数），以及被传给 vformat 的 <em>args</em> 和 <em>kwargs</em> 的引用。 未使用参数的集合可以根据这些形参计算出来。 如果检测失败则 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.check_unused_args" title="string.Formatter.check_unused_args"><code>check_unused_args()</code></a> 应会引发一个异常。</p>
<p><code>format_field</code>(<em>value</em>, <em>format_spec</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.format_field" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.format_field" title="string.Formatter.format_field"><code>format_field()</code></a> 会简单地调用内置全局函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a>。 提供该方法是为了让子类能够重载它。</p>
<p><code>convert_field</code>(<em>value</em>, <em>conversion</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.convert_field" title="永久链接至目标"></a></p>
<p>使用给定的转换类型（来自 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.parse" title="string.Formatter.parse"><code>parse()</code></a> 方法所返回的元组）来转换（由 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter.get_field" title="string.Formatter.get_field"><code>get_field()</code></a> 所返回的）值。 默认版本支持 ‘s’ (str), ‘r’ (repr) 和 ‘a’ (ascii) 等转换类型。</p>
<h2 id="格式字符串语法"><a href="#格式字符串语法" class="headerlink" title="格式字符串语法"></a>格式字符串语法</h2><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> 方法和 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="string.Formatter"><code>Formatter</code></a> 类共享相同的格式字符串语法（虽然对于 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="string.Formatter"><code>Formatter</code></a> 来说，其子类可以定义它们自己的格式字符串语法）。 具体语法与 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#f-strings">格式化字符串字面值</a> 相似，但较为简单一些，并且关键的一点是不支持任意表达式。</p>
<p>格式字符串包含有以花括号 <code>&#123;&#125;</code> 括起来的“替换字段”。 不在花括号之内的内容被视为字面文本，会不加修改地复制到输出中。 如果你需要在字面文本中包含花括号字符，可以通过重复来转义: <code>&#123;&#123;` and `&#125;&#125;</code>。</p>
<p>替换字段的语法如下：</p>
<blockquote>
<p><strong>replacement_field</strong> ::&#x3D;  “{“ [<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-string-field_name"><code>field_name</code></a>] [“!” <a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-string-conversion"><code>conversion</code></a>] [“:” <a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-string-format_spec"><code>format_spec</code></a>] “}”<br>*<em>field_name       ** ::&#x3D;  arg_name (“.” <a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-string-attribute_name"><code>attribute_name</code></a> | “[“ <a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-string-element_index"><code>element_index</code></a> “]”)</em><br>**arg_name         ** ::&#x3D;  [<code>identifier</code> | <code>digit</code>+]<br>**attribute_name   ** ::&#x3D;  <code>identifier</code><br>**element_index    ** ::&#x3D;  <code>digit</code>+ | <a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-string-index_string"><code>index_string</code></a><br>**index_string     ** ::&#x3D;  &lt;any source character except “]”&gt; +<br>**conversion       ** ::&#x3D;  “r” | “s” | “a”<br>**format_spec      ** ::&#x3D;  <described in the next section></p>
</blockquote>
<p>用不太正式的术语来描述，替换字段开头可以用一个 <em>field_name</em> 指定要对值进行格式化并取代替换字符被插入到输出结果的对象。 <em>field_name</em> 之后有可选的 <em>conversion</em> 字段，它是一个感叹号 <code>&#39;!&#39;</code> 加一个 _format_spec_，并以一个冒号 <code>&#39;:&#39;</code> 打头。 这些指明了替换值的非默认格式。</p>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatspec">格式规格迷你语言</a> 一节。</p>
<p><em>field_name</em> 本身以一个数字或关键字 <em>arg_name</em> 打头。 如果为数字，则它指向一个位置参数，而如果为关键字，则它指向一个命名关键字参数。 如果格式字符串中的数字 arg_names 为 0, 1, 2, … 的序列，它们可以全部省略（而非部分省略），数字 0, 1, 2, … 将会按顺序自动插入。 由于 <em>arg_name</em> 不使用引号分隔，因此无法在格式字符串中指定任意的字典键 (例如字符串 <code>&#39;10&#39;</code> 或 <code>&#39;:-]&#39;</code>)。 <em>arg_name</em> 之后可以带上任意数量的索引或属性表达式。 <code>&#39;.name&#39;</code> 形式的表达式会使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 选择命名属性，而 <code>&#39;[index]&#39;</code> 形式的表达式会使用 <code>__getitem__()</code> 执行索引查找。</p>
<p>在 3.1 版更改: 位置参数说明符对于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> 可以省略，因此 <code>&#39;&#123;&#125; &#123;&#125;&#39;.format(a, b)</code> 等价于 <code>&#39;&#123;0&#125; &#123;1&#125;&#39;.format(a, b)</code>。</p>
<p>在 3.4 版更改: 位置参数说明符对于 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Formatter" title="string.Formatter"><code>Formatter</code></a> 可以省略。</p>
<p>一些简单的格式字符串示例</p>
<p>“First, thou shalt count to {0}”  # References first positional argument<br>“Bring me a {}”                   # Implicitly references the first positional argument<br>“From {} to {}”                   # Same as “From {0} to {1}”<br>“My quest is {name}”              # References keyword argument ‘name’<br>“Weight in tons {0.weight}”       # ‘weight’ attribute of first positional arg<br>“Units destroyed: {players[0]}”   # First element of keyword argument ‘players’.</p>
<p>使用 <em>conversion</em> 字段在格式化之前进行类型强制转换。 通常，格式化值的工作由值本身的 <code>__format__()</code> 方法来完成。 但是，在某些情况下最好强制将类型格式化为一个字符串，覆盖其本身的格式化定义。 通过在调用 <code>__format__()</code> 之前将值转换为字符串，可以绕过正常的格式化逻辑。</p>
<p>目前支持的转换旗标有三种: <code>&#39;!s&#39;</code> 会对值调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a>，<code>&#39;!r&#39;</code> 调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 而 <code>&#39;!a&#39;</code> 则调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ascii" title="ascii"><code>ascii()</code></a>。</p>
<p>示例如下：</p>
<p>“Harold’s a clever {0!s}”        # Calls str() on the argument first<br>“Bring out the holy {name!r}”    # Calls repr() on the argument first<br>“More {!a}”                      # Calls ascii() on the argument first</p>
<p><em>format_spec</em> 字段包含值应如何呈现的规格描述，例如字段宽度、对齐、填充、小数精度等细节信息。 每种值类型可以定义自己的“格式化迷你语言”或对 <em>format_spec</em> 的解读方式。</p>
<p>大多数内置类型都支持同样的格式化迷你语言，具体描述见下一节。</p>
<p><em>format_spec</em> 字段还可以在其内部包含嵌套的替换字段。 这些嵌套的替换字段可能包括字段名称、转换旗标和格式规格描述，但是不再允许更深层的嵌套。 format_spec 内部的替换字段会在解读 <em>format_spec</em> 字符串之前先被解读。 这将允许动态地指定特定值的格式。</p>
<p>请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatexamples">格式示例</a> 一节查看相关示例。</p>
<h3 id="格式规格迷你语言"><a href="#格式规格迷你语言" class="headerlink" title="格式规格迷你语言"></a>格式规格迷你语言</h3><p>“格式规格”在格式字符串所包含的替换字段内部使用，用于定义单个值应如何呈现 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatstrings">格式字符串语法</a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#f-strings">格式字符串字面值</a>)。 它们也可以被直接传给内置的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a> 函数。 每种可格式化的类型都可以自行定义如何对格式规格进行解读。</p>
<p>大多数内置类型都为格式规格实现了下列选项，不过某些格式化选项只被数值类型所支持。</p>
<p>一般约定空的格式描述将产生与在值上调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 相同的结果。 非空格式描述通常会修改此结果。</p>
<p><em>标准格式说明符</em> 的一般形式如下：</p>
<p>**format_spec    ** ::&#x3D;  [[<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-fill"><code>fill</code></a>]<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-align"><code>align</code></a>][<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-sign"><code>sign</code></a>][#][0][<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-width"><code>width</code></a>][<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-grouping_option"><code>grouping_option</code></a>][.<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-precision"><code>precision</code></a>][<a href="https://docs.python.org/zh-cn/3.10/library/string.html#grammar-token-format-spec-type"><code>type</code></a>]<br>**fill           ** ::&#x3D;  <any character><br>**align          ** ::&#x3D;  “&lt;” | “&gt;” | “&#x3D;” | “^”<br>**sign           ** ::&#x3D;  “+” | “-“ | “ “<br>**width          ** ::&#x3D;  <code>digit</code>+<br><strong>grouping_option</strong> ::&#x3D;  “_” | “,”<br>**precision      ** ::&#x3D;  <code>digit</code>+<br>**type           ** ::&#x3D;  “b” | “c” | “d” | “e” | “E” | “f” | “F” | “g” | “G” | “n” | “o” | “s” | “x” | “X” | “%”</p>
<p>如果指定了一个有效的 <em>align</em> 值，则可以在该值前面加一个 <em>fill</em> 字符，它可以为任意字符，如果省略则默认为空格符。 在 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#f-strings">格式化字符串字面值</a> 或在使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> 方法时是无法使用花括号字面值 (“<code>&#123;</code>“ or “<code>&#125;</code>“) 作为 <em>fill</em> 字符的。 但是，通过嵌套替换字段插入花括号则是可以的。 这个限制不会影响 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a> 函数。</p>
<p>各种对齐选项的含义如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;&lt;&#39;</code></td>
<td>强制字段在可用空间内左对齐（这是大多数对象的默认值）。</td>
</tr>
<tr>
<td><code>&#39;&gt;&#39;</code></td>
<td>强制字段在可用空间内右对齐（这是数字的默认值）。</td>
</tr>
<tr>
<td><code>&#39;=&#39;</code></td>
<td>强制在符号（如果有）之后数码之前放置填充。 这被用于以 ‘+000000120’ 形式打印字段。 这个对齐选项仅对数字类型有效。 这是当 ‘0’ 紧接在字段宽度之前时的默认选项。</td>
</tr>
<tr>
<td><code>&#39;^&#39;</code></td>
<td>强制字段在可用空间内居中。</td>
</tr>
</tbody></table>
</blockquote>
<p>请注意，除非定义了最小字段宽度，否则字段宽度将始终与填充它的数据大小相同，因此在这种情况下，对齐选项没有意义。</p>
<p><em>sign</em> 选项仅对数字类型有效，可以是以下之一：</p>
<blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;+&#39;</code></td>
<td>表示标志应该用于正数和负数。</td>
</tr>
<tr>
<td><code>&#39;-&#39;</code></td>
<td>表示标志应仅用于负数（这是默认行为）。</td>
</tr>
<tr>
<td>space</td>
<td>表示应在正数上使用前导空格，在负数上使用减号。</td>
</tr>
</tbody></table>
</blockquote>
<p><code>&#39;#&#39;</code> 选项可让“替代形式”被用于执行转换。 替代形式会针对不同的类型分别定义。 此选项仅适用于整数、浮点数和复数类型。 对于整数类型，当使用二进制、八进制或十六进制输出时，此选项会为输出值分别添加相应的 <code>&#39;0b&#39;</code>, <code>&#39;0o&#39;</code>, <code>&#39;0x&#39;</code> 或 <code>&#39;0X&#39;</code> 前缀。 对于浮点数和复数类型，替代形式会使得转换结果总是包含小数点符号，即使其不带小数部分。 通常只有在带有小数部分的情况下，此类转换的结果中才会出现小数点符号。 此外，对于 <code>&#39;g&#39;</code> 和 <code>&#39;G&#39;</code> 转换，末尾的零不会从结果中被移除。</p>
<p><code>&#39;,&#39;</code> 选项表示使用逗号作为千位分隔符。 对于感应区域设置的分隔符，请改用 <code>&#39;n&#39;</code> 整数表示类型。</p>
<p>在 3.1 版更改: 添加了 <code>&#39;,&#39;</code> 选项 (另请参阅 <a href="https://www.python.org/dev/peps/pep-0378"><strong>PEP 378</strong></a>)。</p>
<p><code>&#39;_&#39;</code> 选项表示对浮点表示类型和整数表示类型 <code>&#39;d&#39;</code> 使用下划线作为千位分隔符。 对于整数表示类型 <code>&#39;b&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;x&#39;</code> 和 <code>&#39;X&#39;</code>，将为每 4 个数位插入一个下划线。 对于其他表示类型指定此选项则将导致错误。</p>
<p>在 3.6 版更改: 添加了 <code>&#39;_&#39;</code> 选项 (另请参阅 <a href="https://www.python.org/dev/peps/pep-0515"><strong>PEP 515</strong></a>)。</p>
<p><em>width</em> 是一个定义最小总字段宽度的十进制整数，包括任何前缀、分隔符和其他格式化字符。 如果未指定，则字段宽度将由内容确定。</p>
<p>当未显式给出对齐方式时，在 <em>width</em> 字段前加一个零 (<code>&#39;0&#39;</code>) 字段将为数字类型启用感知正负号的零填充。 这相当于设置 <em>fill</em> 字符为 <code>&#39;0&#39;</code> 且 <em>alignment</em> 类型为 <code>&#39;=&#39;</code>。</p>
<p>在 3.10 版更改: 在 <em>width</em> 字段之前添加 <code>&#39;0&#39;</code> 不会再影响字符串的默认对齐。</p>
<p><em>precision</em> 是一个十进制整数，它表示对于以表示类型 <code>&#39;f&#39;</code> 和 <code>&#39;F&#39;</code> 格式化的数值应当在小数点后显示多少个数位，或者对于以表示类型 <code>&#39;g&#39;</code> 或 <code>&#39;G&#39;</code> 格式化的数值应当在小数点前后显示多少个数位。 对于字符串表示类型，该字段表示最大的字段大小 ——换句话说，就是要使用多少个来自字段内容的字符。不允许对整数表示类型指定 <em>precision</em> 字段。</p>
<p>最后，<em>type</em> 确定了数据应如何呈现。</p>
<p>可用的字符串表示类型是：</p>
<blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;s&#39;</code></td>
<td>字符串格式。这是字符串的默认类型，可以省略。</td>
</tr>
<tr>
<td>None</td>
<td>和 <code>&#39;s&#39;</code> 一样。</td>
</tr>
</tbody></table>
</blockquote>
<p>可用的整数表示类型是：</p>
<blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;b&#39;</code></td>
<td>二进制格式。 输出以 2 为基数的数字。</td>
</tr>
<tr>
<td><code>&#39;c&#39;</code></td>
<td>字符。在打印之前将整数转换为相应的unicode字符。</td>
</tr>
<tr>
<td><code>&#39;d&#39;</code></td>
<td>十进制整数。 输出以 10 为基数的数字。</td>
</tr>
<tr>
<td><code>&#39;o&#39;</code></td>
<td>八进制格式。 输出以 8 为基数的数字。</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>十六进制格式。 输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。</td>
</tr>
<tr>
<td><code>&#39;X&#39;</code></td>
<td>十六进制格式。 输出以 16 为基数的数字，使用大写字母表示 9 以上的数码。 在指定 <code>&#39;#&#39;</code> 的情况下，前缀 <code>&#39;0x&#39;</code> 也将被转为大写形式 <code>&#39;0X&#39;</code>。</td>
</tr>
<tr>
<td><code>&#39;n&#39;</code></td>
<td>数字。 这与 <code>&#39;d&#39;</code> 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。</td>
</tr>
<tr>
<td>None</td>
<td>和 <code>&#39;d&#39;</code> 相同。</td>
</tr>
</tbody></table>
</blockquote>
<p>在上述的表示类型之外，整数还可以通过下列的浮点表示类型来格式化 (除了 <code>&#39;n&#39;</code> 和 <code>None</code>)。 当这样做时，会在格式化之前使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float()</code></a> 将整数转换为浮点数。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>Decimal</code></a> 值的可用表示类型有:</p>
<blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;e&#39;</code></td>
<td>科学计数法。 对于一个给定的精度 <code>p</code>，将数字格式化为以字母 ‘e’ 分隔系数和指数的科学计数法形式。 系数在小数点之前有一位，之后有 <code>p</code> 位，总计 <code>p + 1</code> 个有效数位。 如未指定精度，则会对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 采用小数点之后 <code>6</code> 位精度，而对 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>Decimal</code></a> 则显示所有系数位。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 <code>#</code> 选项。</td>
</tr>
<tr>
<td><code>&#39;E&#39;</code></td>
<td>科学计数法。 与 <code>&#39;e&#39;</code> 相似，不同之处在于它使用大写字母 ‘E’ 作为分隔字符。</td>
</tr>
<tr>
<td><code>&#39;f&#39;</code></td>
<td>定点表示法。 对于一个给定的精度 <code>p</code>，将数字格式化为在小数点之后恰好有 <code>p</code> 位的小数形式。 如未指定精度，则会对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 采用小数点之后 <code>6</code> 位精度，而对 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>Decimal</code></a> 则使用大到足够显示所有系数位的精度。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 <code>#</code> 选项。</td>
</tr>
<tr>
<td><code>&#39;F&#39;</code></td>
<td>定点表示。 与 <code>&#39;f&#39;</code> 相似，但会将 <code>nan</code> 转为 <code>NAN</code> 并将 <code>inf</code> 转为 <code>INF</code>。</td>
</tr>
<tr>
<td><code>&#39;g&#39;</code></td>
<td>常规格式。 对于给定精度 <code>p &gt;= 1</code>，这会将数值舍入到 <code>p</code> 个有效数位，再将结果以定点表示法或科学计数法进行格式化，具体取决于其值的大小。 精度 <code>0</code> 会被视为等价于精度 <code>1</code>。<br><br>准确的规则如下：假设使用表示类型 <code>&#39;e&#39;</code> 和精度 <code>p-1</code> 进行格式化的结果具有指数值 <code>exp</code>。 那么如果 <code>m &lt;= exp &lt; p</code>，其中 <code>m</code> 以 -4 表示浮点值而以 -6 表示 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>Decimal</code></a> 值，该数字将使用类型 <code>&#39;f&#39;</code> 和精度 <code>p-1-exp</code> 进行格式化。 否则的话，该数字将使用表示类型 <code>&#39;e&#39;</code> 和精度 <code>p-1</code> 进行格式化。 在两种情况下，都会从有效数字中移除无意义的末尾零，如果小数点之后没有余下数字则小数点也会被移除，除非使用了 <code>&#39;#&#39;</code> 选项。<br><br>如未指定精度，会对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 采用 <code>6</code> 个有效数位的精度。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>Decimal</code></a>，结果的系数会沿用原值的系数数位；对于绝对值小于 <code>1e-6</code> 的值以及最小有效数位的位值大于 1 的数值将会使用科学计数法，在其他情况下则会使用定点表示法。<br><br>正负无穷，正负零和 nan 会分别被格式化为 <code>inf</code>, <code>-inf</code>, <code>0</code>, <code>-0</code> 和 <code>nan</code>，无论精度如何设定。</td>
</tr>
<tr>
<td><code>&#39;G&#39;</code></td>
<td>常规格式。 类似于 <code>&#39;g&#39;</code>，不同之处在于当数值非常大时会切换为 <code>&#39;E&#39;</code>。 无穷与 NaN 也会表示为大写形式。</td>
</tr>
<tr>
<td><code>&#39;n&#39;</code></td>
<td>数字。 这与 <code>&#39;g&#39;</code> 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。</td>
</tr>
<tr>
<td><code>&#39;%&#39;</code></td>
<td>百分比。 将数字乘以 100 并显示为定点 (<code>&#39;f&#39;</code>) 格式，后面带一个百分号。</td>
</tr>
<tr>
<td>None</td>
<td>对于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 来说这类似于 <code>&#39;g&#39;</code>，不同之处在于当使用定点表示法时，小数点之后将至少显示一位。 所用的精度会大到足以精确表示给定的值。<br><br>对于 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>Decimal</code></a> 来说这相当于 <code>&#39;g&#39;</code> 或 <code>&#39;G&#39;</code>，具体取决于当前 decimal 上下文的 <code>context.capitals</code> 值。<br><br>总体效果是将 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 的输出匹配为其他格式化因子所调整出的样子。</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="格式示例"><a href="#格式示例" class="headerlink" title="格式示例"></a>格式示例</h3><p>本节包含 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> 语法的示例以及与旧式 <code>%</code> 格式化的比较。</p>
<p>该语法在大多数情况下与旧式的 <code>%</code> 格式化类似，只是增加了 <code>&#123;&#125;</code> 和 <code>:</code> 来取代 <code>%</code>。 例如，，<code>&#39;%03.2f&#39;</code> 可以被改写为 <code>&#39;&#123;:03.2f&#125;&#39;</code>。</p>
<p>新的格式语法还支持新增的不同选项，将在以下示例中说明。</p>
<p>按位置访问参数:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘{0}, {1}, {2}’.format(‘a’, ‘b’, ‘c’)<br>‘a, b, c’<br>‘{}, {}, {}’.format(‘a’, ‘b’, ‘c’)  # 3.1+ only<br>‘a, b, c’<br>‘{2}, {1}, {0}’.format(‘a’, ‘b’, ‘c’)<br>‘c, b, a’<br>‘{2}, {1}, {0}’.format(*’abc’)      # unpacking argument sequence<br>‘c, b, a’<br>‘{0}{1}{0}’.format(‘abra’, ‘cad’)   # arguments’ indices can be repeated<br>‘abracadabra’</p>
</blockquote>
</blockquote>
</blockquote>
<p>按名称访问参数:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘Coordinates: {latitude}, {longitude}’.format(latitude&#x3D;’37.24N’, longitude&#x3D;’-115.81W’)<br>‘Coordinates: 37.24N, -115.81W’<br>coord &#x3D; {‘latitude’: ‘37.24N’, ‘longitude’: ‘-115.81W’}<br>‘Coordinates: {latitude}, {longitude}’.format(**coord)<br>‘Coordinates: 37.24N, -115.81W’</p>
</blockquote>
</blockquote>
</blockquote>
<p>访问参数的属性:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>c &#x3D; 3-5j<br>(‘The complex number {0} is formed from the real part {0.real} ‘<br>…  ‘and the imaginary part {0.imag}.’).format(c)<br>‘The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.’<br>class Point:<br>…     def <strong>init</strong>(self, x, y):<br>…         self.x, self.y &#x3D; x, y<br>…     def <strong>str</strong>(self):<br>…         return ‘Point({self.x}, {self.y})’.format(self&#x3D;self)<br>…<br>str(Point(4, 2))<br>‘Point(4, 2)’</p>
</blockquote>
</blockquote>
</blockquote>
<p>访问参数的项:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>coord &#x3D; (3, 5)<br>‘X: {0[0]};  Y: {0[1]}’.format(coord)<br>‘X: 3;  Y: 5’</p>
</blockquote>
</blockquote>
</blockquote>
<p>替代 <code>%s</code> 和 <code>%r</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“repr() shows quotes: {!r}; str() doesn’t: {!s}”.format(‘test1’, ‘test2’)<br>“repr() shows quotes: ‘test1’; str() doesn’t: test2”</p>
</blockquote>
</blockquote>
</blockquote>
<p>对齐文本以及指定宽度:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘{:&lt;30}’.format(‘left aligned’)<br>‘left aligned                  ‘<br>‘{:&gt;30}’.format(‘right aligned’)<br>‘                 right aligned’<br>‘{:^30}’.format(‘centered’)<br>‘           centered           ‘<br>‘{:<em>^30}’.format(‘centered’)  # use ‘</em>‘ as a fill char<br>‘<em><strong><strong><strong><strong><strong>centered</strong></strong></strong></strong></strong></em>‘</p>
</blockquote>
</blockquote>
</blockquote>
<p>替代 <code>%+f</code>, <code>%-f</code> 和 <code>% f</code> 以及指定正负号:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘{:+f}; {:+f}’.format(3.14, -3.14)  # show it always<br>‘+3.140000; -3.140000’<br>‘{: f}; {: f}’.format(3.14, -3.14)  # show a space for positive numbers<br>‘ 3.140000; -3.140000’<br>‘{:-f}; {:-f}’.format(3.14, -3.14)  # show only the minus – same as ‘{:f}; {:f}’<br>‘3.140000; -3.140000’</p>
</blockquote>
</blockquote>
</blockquote>
<p>替代 <code>%x</code> 和 <code>%o</code> 以及转换基于不同进位制的值:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="format-also-supports-binary-numbers"><a href="#format-also-supports-binary-numbers" class="headerlink" title="format also supports binary numbers"></a>format also supports binary numbers</h1><p>“int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}”.format(42)<br>‘int: 42;  hex: 2a;  oct: 52;  bin: 101010’</p>
<h1 id="with-0x-0o-or-0b-as-prefix"><a href="#with-0x-0o-or-0b-as-prefix" class="headerlink" title="with 0x, 0o, or 0b as prefix:"></a>with 0x, 0o, or 0b as prefix:</h1><p>“int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}”.format(42)<br>‘int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010’</p>
</blockquote>
</blockquote>
</blockquote>
<p>使用逗号作为千位分隔符:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘{:,}’.format(1234567890)<br>‘1,234,567,890’</p>
</blockquote>
</blockquote>
</blockquote>
<p>表示为百分数:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>points &#x3D; 19<br>total &#x3D; 22<br>‘Correct answers: {:.2%}’.format(points&#x2F;total)<br>‘Correct answers: 86.36%’</p>
</blockquote>
</blockquote>
</blockquote>
<p>使用特定类型的专属格式化:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import datetime<br>d &#x3D; datetime.datetime(2010, 7, 4, 12, 15, 58)<br>‘{:%Y-%m-%d %H:%M:%S}’.format(d)<br>‘2010-07-04 12:15:58’</p>
</blockquote>
</blockquote>
</blockquote>
<p>嵌套参数以及更复杂的示例:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>for align, text in zip(‘&lt;^&gt;’, [‘left’, ‘center’, ‘right’]):<br>…     ‘{0:{fill}{align}16}’.format(text, fill&#x3D;align, align&#x3D;align)<br>…<br>‘left&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;’<br>‘^^^^^center^^^^^’<br>‘&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;right’</p>
<p>octets &#x3D; [192, 168, 0, 1]<br>‘{:02X}{:02X}{:02X}{:02X}’.format(*octets)<br>‘C0A80001’<br>int(_, 16)<br>3232235521</p>
<p>width &#x3D; 5<br>for num in range(5,12):<br>…     for base in ‘dXob’:<br>…         print(‘{0:{width}{base}}’.format(num, base&#x3D;base, width&#x3D;width), end&#x3D;’ ‘)<br>…     print()<br>…<br>    5     5     5   101<br>    6     6     6   110<br>    7     7     7   111<br>    8     8    10  1000<br>    9     9    11  1001<br>   10     A    12  1010<br>   11     B    13  1011</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串提供了由 <a href="https://www.python.org/dev/peps/pep-0292"><strong>PEP 292</strong></a> 所描述的更简便的字符串替换方式。 模板字符串的一个主要用例是文本国际化 (i18n)，因为在此情境下，更简单的语法和功能使得文本翻译过程比使用 Python 的其他内置字符串格式化工具更方便。 作为基于模板字符串构建以实现 i18n 的库的一个例子，请参看 <a href="https://flufli18n.readthedocs.io/en/latest/">flufl.i18n</a> 包。</p>
<p>模板字符串支持基于 <code>$</code> 的替换，使用以下规则：</p>
<ul>
<li><p><code>$$</code> 为转义符号；它会被替换为单个的 <code>$</code>。</p>
</li>
<li><p><code>$identifier</code> 为替换占位符，它会匹配一个名为 <code>&quot;identifier&quot;</code> 的映射键。 在默认情况下，<code>&quot;identifier&quot;</code> 限制为任意 ASCII 字母数字（包括下划线）组成的字符串，不区分大小写，以下划线或 ASCII 字母开头。 在 <code>$</code> 字符之后的第一个非标识符字符将表明占位符的终结。</p>
</li>
<li><p><code>$&#123;identifier&#125;</code> 等价于 <code>$identifier</code>。 当占位符之后紧跟着有效的但又不是占位符一部分的标识符字符时需要使用，例如 <code>&quot;$&#123;noun&#125;ification&quot;</code>。</p>
</li>
</ul>
<p>在字符串的其他位置出现 <code>$</code> 将导致引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/string.html#module-string" title="string: Common string operations."><code>string</code></a> 模块提供了实现这些规则的 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template" title="string.Template"><code>Template</code></a> 类。 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template" title="string.Template"><code>Template</code></a> 有下列方法：</p>
<p><em>class</em> <code>string.``Template</code>(<em>template</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template" title="永久链接至目标"></a></p>
<p>该构造器接受一个参数作为模板字符串。</p>
<p><code>substitute</code>(<em>mapping&#x3D;{}</em>, <em>&#x2F;</em>, <em>**kwds</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template.substitute" title="永久链接至目标"></a></p>
<p>执行模板替换，返回一个新字符串。 <em>mapping</em> 为任意字典类对象，其中的键将匹配模板中的占位符。 或者你也可以提供一组关键字参数，其中的关键字即对应占位符。 当同时给出 <em>mapping</em> 和 <em>kwds</em> 并且存在重复时，则以 <em>kwds</em> 中的占位符为优先。</p>
<p><code>safe_substitute</code>(<em>mapping&#x3D;{}</em>, <em>&#x2F;</em>, <em>**kwds</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template.safe_substitute" title="永久链接至目标"></a></p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template.substitute" title="string.Template.substitute"><code>substitute()</code></a>，不同之处是如果有占位符未在 <em>mapping</em> 和 <em>kwds</em> 中找到，不是引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> 异常，而是将原始占位符不加修改地显示在结果字符串中。 另一个与 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template.substitute" title="string.Template.substitute"><code>substitute()</code></a> 的差异是任何在其他情况下出现的 <code>$</code> 将简单地返回 <code>$</code> 而不是引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p>此方法被认为“安全”，因为虽然仍有可能发生其他异常，但它总是尝试返回可用的字符串而不是引发一个异常。 从另一方面来说，<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template.safe_substitute" title="string.Template.safe_substitute"><code>safe_substitute()</code></a> 也可能根本算不上安全，因为它将静默地忽略错误格式的模板，例如包含多余的分隔符、不成对的花括号或不是合法 Python 标识符的占位符等等。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template" title="string.Template"><code>Template</code></a> 的实例还提供一个公有数据属性：</p>
<p><code>template</code><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template.template" title="永久链接至目标"></a></p>
<p>这是作为构造器的 <em>template</em> 参数被传入的对象。 一般来说，你不应该修改它，但并不强制要求只读访问。</p>
<p>以下是一个如何使用模版的示例：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from string import Template<br>s &#x3D; Template(‘$who likes $what’)<br>s.substitute(who&#x3D;’tim’, what&#x3D;’kung pao’)<br>‘tim likes kung pao’<br>d &#x3D; dict(who&#x3D;’tim’)<br>Template(‘Give $who $100’).substitute(d)<br>Traceback (most recent call last):<br>…<br>ValueError: Invalid placeholder in string: line 1, col 11<br>Template(‘$who likes $what’).substitute(d)<br>Traceback (most recent call last):<br>…<br>KeyError: ‘what’<br>Template(‘$who likes $what’).safe_substitute(d)<br>‘tim likes $what’</p>
</blockquote>
</blockquote>
</blockquote>
<p>进阶用法：你可以派生 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.Template" title="string.Template"><code>Template</code></a> 的子类来自定义占位符语法、分隔符，或用于解析模板字符串的整个正则表达式。 为此目的，你可以重载这些类属性：</p>
<ul>
<li><p><em>delimiter</em> – 这是用来表示占位符的起始的分隔符的字符串字面值。 默认值为 <code>$</code>。 请注意此参数 <em>不能</em> 为正则表达式，因为其实现将在必要时对此字符串调用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.escape" title="re.escape"><code>re.escape()</code></a>。 还要注意你不能在创建类之后改变此分隔符（例如在子类的类命名空间中必须设置不同的分隔符）。</p>
</li>
<li><p><em>idpattern</em> – 这是用来描述不带花括号的占位符的模式的正则表达式。 默认值为正则表达式 <code>(?a:[_a-z][_a-z0-9]*)</code>。 如果给出了此属性并且 <em>braceidpattern</em> 为 <code>None</code> 则此模式也将作用于带花括号的占位符。</p>
<p>  注解</p>
<p>   </p>
<p>  由于默认的 <em>flags</em> 为 <code>re.IGNORECASE</code>，模式 <code>[a-z]</code> 可以匹配某些非 ASCII 字符。 因此我们在这里使用了局部旗标 <code>a</code>。</p>
<p>  在 3.7 版更改: <em>braceidpattern</em> 可被用来定义对花括号内部和外部进行区分的模式。</p>
</li>
<li><p><em>braceidpattern</em> – 此属性类似于 <em>idpattern</em> 但是用来描述带花括号的占位符的模式。 默认值 <code>None</code> 意味着回退到 <em>idpattern</em> (即在花括号内部和外部使用相同的模式)。 如果给出此属性，这将允许你为带花括号和不带花括号的占位符定义不同的模式。</p>
<p>  3.7 新版功能.</p>
</li>
<li><p><em>flags</em> – 将在编译用于识别替换内容的正则表达式被应用的正则表达式旗标。 默认值为 <code>re.IGNORECASE</code>。 请注意 <code>re.VERBOSE</code> 总是会被加为旗标，因此自定义的 <em>idpattern</em> 必须遵循详细正则表达式的约定。</p>
<p>  3.2 新版功能.</p>
</li>
</ul>
<p>作为另一种选项，你可以通过重载类属性 <em>pattern</em> 来提供整个正则表达式模式。 如果你这样做，该值必须为一个具有四个命名捕获组的正则表达式对象。 这些捕获组对应于上面已经给出的规则，以及无效占位符的规则：</p>
<ul>
<li><p><em>escaped</em> – 这个组匹配转义序列，在默认模式中即 <code>$$</code>。</p>
</li>
<li><p><em>named</em> – 这个组匹配不带花括号的占位符名称；它不应当包含捕获组中的分隔符。</p>
</li>
<li><p><em>braced</em> – 这个组匹配带有花括号的占位符名称；它不应当包含捕获组中的分隔符或者花括号。</p>
</li>
<li><p><em>invalid</em> – 这个组匹配任何其他分隔符模式（通常为单个分隔符），并且它应当出现在正则表达式的末尾。</p>
</li>
</ul>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p><code>string.``capwords</code>(<em>s</em>, <em>sep&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.capwords" title="永久链接至目标"></a></p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.split" title="str.split"><code>str.split()</code></a> 将参数拆分为单词，使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.capitalize" title="str.capitalize"><code>str.capitalize()</code></a> 将单词转为大写形式，使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.join" title="str.join"><code>str.join()</code></a> 将大写的单词进行拼接。 如果可选的第二个参数 <em>sep</em> 被省略或为 <code>None</code>，则连续的空白字符会被替换为单个空格符并且开头和末尾的空白字符会被移除，否则 <em>sep</em> 会被用来拆分和拼接单词。</p>
]]></content>
      <tags>
        <tag>Python Python标准库 字符串常量 自定义字符串格式化 格式字符串语法 模板字符串 辅助函数</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/re%20---%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本模块提供了与 Perl 语言类似的正则表达式匹配操作。</p>
<p>模式和被搜索的字符串既可以是 Unicode 字符串 (<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a>) ，也可以是8位字节串 (<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a>)。 但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能用字节串模式匹配 Unicode 字符串，反之亦然；同理，替换操作时，替换字符串的类型也必须与所用的模式和搜索字符串的类型一致。</p>
<p>正则表达式用反斜杠字符 (<code>&#39;\&#39;</code>) 表示特殊形式，或是允许在使用特殊字符时，不引发它们的特殊含义。 这与 Python 的字符串字面值中对相同字符出于相同目的的用法产生冲突；例如，要匹配一个反斜杠字面值，用户可能必须写成 <code>&#39;\&#39;</code> 来作为模式字符串，因为正则表达式必须为 <code>\</code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code>\</code>。 而且还要注意，在 Python 的字符串字面值中使用的反斜杠如果有任何无效的转义序列，现在会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a>，但以后会改为 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>。 此行为即使对于正则表达式来说有效的转义字符同样会发生。</p>
<p>解决办法是对于正则表达式模式（patterns）使用 Python 的原始字符串表示法；在带有 <code>&#39;r&#39;</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code>r&quot;\n&quot;</code> 表示包含 <code>&#39;\&#39;</code> 和 <code>&#39;n&#39;</code> 两个字符的字符串，而 <code>&quot;\n&quot;</code> 则表示只包含一个换行符的字符串。 模式在 Python 代码中通常都使用原始字符串表示法。</p>
<p>绝大多数正则表达式操作都提供为模块函数和方法，在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">编译正则表达式</a>. 这些函数是一个捷径，不需要先编译正则对象，但是损失了一些优化参数。</p>
<p>参见</p>
<p> </p>
<p>第三方模块 <a href="https://pypi.org/project/regex/">regex</a> , 提供了与标准库 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> 模块兼容的 API 接口，同时，还提供了更多功能和更全面的 Unicode 支持。</p>
<h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。</p>
<p>正则表达式可以拼接；如果 <em>A</em> 和 <em>B</em> 都是正则表达式，则 <em>AB</em> 也是正则表达式。通常，如果字符串 <em>p</em> 匹配 _A_，并且另一个字符串 <em>q</em> 匹配 <em>B_，那么 <em>pq</em> 可以匹配 AB。除非 <em>A</em> 或者 <em>B</em> 包含低优先级操作，_A</em> 和 <em>B</em> 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。更多正则表达式理论和实现，详见 the Friedl book <a href="https://docs.python.org/zh-cn/3.10/library/re.html#frie09">[Frie09]</a> ，或者其他构建编译器的书籍。</p>
<p>以下是正则表达式格式的简要说明。更详细的信息和演示，参考 <a href="https://docs.python.org/zh-cn/3.10/howto/regex.html#regex-howto">正则表达式指南</a>。</p>
<p>正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 <code>&#39;A&#39;</code>, <code>&#39;a&#39;</code>, 或者 <code>&#39;0&#39;</code>，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 <code>last</code> 匹配字符串 <code>&#39;last&#39;</code>. （在这一节的其他部分，我们将用 <code>this special style</code> 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 <code>&#39;in single quotes&#39;</code> ，单引号形式。）</p>
<p>有些字符，比如 <code>&#39;|&#39;</code> 或者 <code>&#39;(&#39;</code>，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p>
<p>重复修饰符 (<code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;m,n&#125;</code>, 等) 不能直接嵌套。这样避免了非贪婪后缀 <code>?</code> 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 <code>(?:a&#123;6&#125;)*</code> 匹配6个 <code>&#39;a&#39;</code> 字符重复任意次数。</p>
<p>特殊字符有：</p>
<p><code>.</code></p>
<p>(点号) 在默认模式下，匹配除换行符以外的任意字符。 如果指定了旗标 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.DOTALL" title="re.DOTALL"><code>DOTALL</code></a> ，它将匹配包括换行符在内的任意字符。</p>
<p><code>^</code></p>
<p>(插入符) 匹配字符串的开头， 并且在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> 模式下也匹配换行后的首个符号。</p>
<p><code>$</code></p>
<p>匹配字符串尾或者在字符串尾的换行符的前一个字符，在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> 模式下也会匹配换行符之前的文本。 <code>foo</code> 匹配 ‘foo’ 和 ‘foobar’，但正则表达式 <code>foo$</code> 只匹配 ‘foo’。 更有趣的是，在 <code>&#39;foo1\nfoo2\n&#39;</code> 中搜索 <code>foo.$</code>，通常匹配 ‘foo2’，但在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> 模式下可以匹配到 ‘foo1’；在 <code>&#39;foo\n&#39;</code> 中搜索 <code>$</code> 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。</p>
<p><code>*</code></p>
<p>对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 <code>ab*</code> 会匹配 <code>&#39;a&#39;</code>，<code>&#39;ab&#39;</code>，或者 <code>&#39;a&#39;</code> 后面跟随任意个 <code>&#39;b&#39;</code>。</p>
<p><code>+</code></p>
<p>对它前面的正则式匹配1到任意次重复。 <code>ab+</code> 会匹配 <code>&#39;a&#39;</code> 后面跟随1个以上到任意个 <code>&#39;b&#39;</code>，它不会匹配 <code>&#39;a&#39;</code>。</p>
<p><code>?</code></p>
<p>对它前面的正则式匹配0到1次重复。 <code>ab?</code> 会匹配 <code>&#39;a&#39;</code> 或者 <code>&#39;ab&#39;</code>。</p>
<p><code>*?</code>, <code>+?</code>, <code>??</code></p>
<p><code>&#39;*&#39;</code>, <code>&#39;+&#39;</code>，和 <code>&#39;?&#39;</code> 修饰符都是 _贪婪的_；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 <code>&lt;.*&gt;</code> 希望找到 <code>&#39;&lt;a&gt; b &lt;c&gt;&#39;</code>，它将会匹配整个字符串，而不仅是 <code>&#39;&lt;a&gt;&#39;</code>。在修饰符之后添加 <code>?</code> 将使样式以 <em>非贪婪<code>方式或者 :dfn:</code>最小</em> 方式进行匹配； 尽量 <em>少</em> 的字符将会被匹配。 使用正则式 <code>&lt;.*?&gt;</code> 将会仅仅匹配 <code>&#39;&lt;a&gt;&#39;</code>。</p>
<p><code>&#123;m&#125;</code></p>
<p>对其之前的正则式指定匹配 <em>m</em> 个重复；少于 <em>m</em> 的话就会导致匹配失败。比如， <code>a&#123;6&#125;</code> 将匹配6个 <code>&#39;a&#39;</code> , 但是不能是5个。</p>
<p><code>&#123;m,n&#125;</code></p>
<p>对正则式进行 <em>m</em> 到 <em>n</em> 次匹配，在 <em>m</em> 和 <em>n</em> 之间取尽量多。 比如，<code>a&#123;3,5&#125;</code> 将匹配 3 到 5个 <code>&#39;a&#39;</code>。忽略 <em>m</em> 意为指定下界为0，忽略 <em>n</em> 指定上界为无限次。 比如 <code>a&#123;4,&#125;b</code> 将匹配 <code>&#39;aaaab&#39;</code> 或者1000个 <code>&#39;a&#39;</code> 尾随一个 <code>&#39;b&#39;</code>，但不能匹配 <code>&#39;aaab&#39;</code>。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。</p>
<p><code>&#123;m,n&#125;?</code></p>
<p>前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 <code>&#39;aaaaaa&#39;</code>， <code>a&#123;3,5&#125;</code> 匹配 5个 <code>&#39;a&#39;</code> ，而 <code>a&#123;3,5&#125;?</code> 只匹配3个 <code>&#39;a&#39;</code>。</p>
<p><code>\</code></p>
<p>转义特殊字符（允许你匹配 <code>&#39;*&#39;</code>, <code>&#39;?&#39;</code>, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。</p>
<p>如果你没有使用原始字符串（ <code>r&#39;raw&#39;</code> ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p>
<p><code>[]</code></p>
<p>用于表示一个字符集合。在一个集合中：</p>
<ul>
<li><p>字符可以单独列出，比如 <code>[amk]</code> 匹配 <code>&#39;a&#39;</code>， <code>&#39;m&#39;</code>， 或者 <code>&#39;k&#39;</code>。</p>
</li>
<li><p>可以表示字符范围，通过用 <code>&#39;-&#39;</code> 将两个字符连起来。比如 <code>[a-z]</code> 将匹配任何小写ASCII字符， <code>[0-5][0-9]</code> 将匹配从 <code>00</code> 到 <code>59</code> 的两位数字， <code>[0-9A-Fa-f]</code> 将匹配任何十六进制数位。 如果 <code>-</code> 进行了转义 （比如 <code>[a\-z]</code>）或者它的位置在首位或者末尾（如 <code>[-a]</code> 或 <code>[a-]</code>），它就只表示普通字符 <code>&#39;-&#39;</code>。</p>
</li>
<li><p>特殊字符在集合中会失去其特殊意义。比如 <code>[(+*)]</code> 只会匹配这几个字面字符之一 <code>&#39;(&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;*&#39;</code>, or <code>&#39;)&#39;</code>。</p>
</li>
<li><p>字符类如 <code>\w</code> 或者 <code>\S</code> (如下定义) 在集合内可以接受，它们可以匹配的字符由 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> 模式决定。</p>
</li>
<li><p>不在集合范围内的字符可以通过 <em>取反</em> 来进行匹配。如果集合首字符是 <code>&#39;^&#39;</code> ，所有 <em>不</em> 在集合内的字符将会被匹配，比如 <code>[^5]</code> 将匹配所有字符，除了 <code>&#39;5&#39;</code>， <code>[^^]</code> 将匹配所有字符，除了 <code>&#39;^&#39;</code>. <code>^</code> 如果不在集合首位，就没有特殊含义。</p>
</li>
<li><p>要在集合内匹配一个 <code>&#39;]&#39;</code> 字面值，可以在它前面加上反斜杠，或是将它放到集合的开头。 例如，<code>[()[\]&#123;&#125;]</code> 和 <code>[]()[&#123;&#125;]</code> 都可以匹配右方括号，以及左方括号，花括号和圆括号。</p>
</li>
<li><p><a href="https://unicode.org/reports/tr18/">Unicode Technical Standard #18</a> 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FutureWarning" title="FutureWarning"><code>FutureWarning</code></a> 将会在有多义的情况里被 <code>raise</code>，包含以下几种情况，集合由 <code>&#39;[&#39;</code> 开始，或者包含下列字符序列 <code>&#39;--&#39;</code>, <code>&#39;&amp;&amp;&#39;</code>, <code>&#39;~~&#39;</code>, 和 <code>&#39;||&#39;</code>。为了避免警告，需要将它们用反斜杠转义。</p>
</li>
</ul>
<p>在 3.7 版更改: 如果一个字符串构建的语义在未来会改变的话，一个 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FutureWarning" title="FutureWarning"><code>FutureWarning</code></a> 会 <code>raise</code> 。</p>
<p><code>|</code></p>
<p><code>A|B</code>， <em>A</em> 和 <em>B</em> 可以是任意正则表达式，创建一个正则表达式，匹配 <em>A</em> 或者 <em>B</em>. 任意个正则表达式可以用 <code>&#39;|&#39;</code> 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， <code>&#39;|&#39;</code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 <em>A</em> 匹配成功， <em>B</em> 就不再进行匹配，即便它能产生一个更好的匹配。或者说，<code>&#39;|&#39;</code> 操作符绝不贪婪。 如果要匹配 <code>&#39;|&#39;</code> 字符，使用 <code>\|</code>， 或者把它包含在字符集里，比如 <code>[|]</code>.</p>
<p><code>(...)</code></p>
<p>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 <code>\number</code> 转义序列进行再次匹配，之后进行详细说明。要匹配字符 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code>, 用 <code>\(</code> 或 <code>\)</code>, 或者把它们包含在字符集合里: <code>[(]</code>, <code>[)]</code>.</p>
<p><code>(?…)</code></p>
<p>这是个扩展标记法 （一个 <code>&#39;?&#39;</code> 跟随 <code>&#39;(&#39;</code> 并无含义）。 <code>&#39;?&#39;</code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code>(?P&lt;name&gt;...)</code> 是唯一的例外。 以下是目前支持的扩展。</p>
<p><code>(?aiLmsux)</code></p>
<p>( <code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.A" title="re.A"><code>re.A</code></a> (只匹配ASCII字符), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.I" title="re.I"><code>re.I</code></a> (忽略大小写), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.L" title="re.L"><code>re.L</code></a> (语言依赖), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.M" title="re.M"><code>re.M</code></a> (多行模式), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.S" title="re.S"><code>re.S</code></a> (点dot匹配全部字符), <code>re.U</code> (Unicode匹配), and <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.X" title="re.X"><code>re.X</code></a> (冗长模式)。 (这些标记在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#contents-of-module-re">模块内容</a> 中描述) 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a> 中传递 <em>flag</em> 参数。标记应该在表达式字符串首位表示。</p>
<p><code>(?:…)</code></p>
<p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</p>
<p><code>(?aiLmsux-imsx:…)</code></p>
<p>(<code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的0或者多个， 之后可选跟随 <code>&#39;-&#39;</code> 在后面跟随 <code>&#39;i&#39;</code> , <code>&#39;m&#39;</code> , <code>&#39;s&#39;</code> , <code>&#39;x&#39;</code> 中的一到多个 .) 这些字符为表达式的其中一部分 <em>设置</em> 或者 <em>去除</em> 相应标记 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.A" title="re.A"><code>re.A</code></a> (只匹配ASCII), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.I" title="re.I"><code>re.I</code></a> (忽略大小写), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.L" title="re.L"><code>re.L</code></a> (语言依赖), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.M" title="re.M"><code>re.M</code></a> (多行), <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.S" title="re.S"><code>re.S</code></a> (点匹配所有字符), <code>re.U</code> (Unicode匹配), and <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.X" title="re.X"><code>re.X</code></a> (冗长模式)。(标记描述在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#contents-of-module-re">模块内容</a> .)</p>
<p><code>&#39;a&#39;</code>, <code>&#39;L&#39;</code> and <code>&#39;u&#39;</code> 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 <code>&#39;-&#39;</code> 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。在Unicode样式中， <code>(?a:...)</code> 切换为 只匹配ASCII， <code>(?u:...)</code> 切换为Unicode匹配 (默认). 在byte样式中 <code>(?L:...)</code> 切换为语言依赖模式， <code>(?a:...)</code> 切换为 只匹配ASCII (默认)。这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。</p>
<p>3.6 新版功能.</p>
<p>在 3.7 版更改: 符号 <code>&#39;a&#39;</code>, <code>&#39;L&#39;</code> 和 <code>&#39;u&#39;</code> 同样可以用在一个组合内。</p>
<p><code>(?P&lt;name&gt;…)</code></p>
<p>（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 <em>name</em> 来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。</p>
<p>命名组合可以在三种上下文中引用。如果样式是 <code>(?P&lt;quote&gt;[&#39;&quot;]).*?(?P=quote)</code> （也就是说，匹配单引号或者双引号括起来的字符串)：</p>
<table>
<thead>
<tr>
<th>引用组合 “quote” 的上下文</th>
<th>引用方法</th>
</tr>
</thead>
<tbody><tr>
<td>在正则式自身内</td>
<td>- <code>(?P=quote)</code> (如示)<br>    <br>- <code>\1</code></td>
</tr>
<tr>
<td>处理匹配对象 <em>m</em></td>
<td>- <code>m.group(&#39;quote&#39;)</code><br>    <br>- <code>m.end(&#39;quote&#39;)</code> (等)</td>
</tr>
<tr>
<td>传递到 <code>re.sub()</code> 里的 <em>repl</em> 参数中</td>
<td>- <code>\g&lt;quote&gt;</code><br>    <br>- <code>\g&lt;1&gt;</code><br>    <br>- <code>\1</code></td>
</tr>
</tbody></table>
<p><code>(?P=name)</code></p>
<p>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串。</p>
<p><code>(?#…)</code></p>
<p>注释；里面的内容会被忽略。</p>
<p><code>(?=…)</code></p>
<p>当 <code>…</code> 匹配时，匹配成功，但不消耗字符串中的任何字符。这个叫做 <em>前视断言</em> （lookahead assertion）。比如， <code>Isaac (?=Asimov)</code> 将会匹配 <code>&#39;Isaac &#39;</code> ，仅当其后紧跟 <code>&#39;Asimov&#39;</code> 。</p>
<p><code>(?!…)</code></p>
<p>当 <code>…</code> 不匹配时，匹配成功。这个叫 <em>否定型前视断言</em> （negative lookahead assertion）。例如， <code>Isaac (?!Asimov)</code> 将会匹配 <code>&#39;Isaac &#39;</code> ，仅当它后面 <em>不是</em> <code>&#39;Asimov&#39;</code> 。</p>
<p><code>(?&lt;=…)</code></p>
<p>如果 <code>...</code> 的匹配内容出现在当前位置的左侧，则匹配。这叫做 <em>肯定型后视断言</em> （positive lookbehind assertion）。 <code>(?&lt;=abc)def</code> 将会在 <code>&#39;abcdef&#39;</code> 中找到一个匹配，因为后视会回退3个字符并检查内部表达式是否匹配。内部表达式（匹配的内容）必须是固定长度的，意思就是 <code>abc</code> 或 <code>a|b</code> 是允许的，但是 <code>a*</code> 和 <code>a&#123;3,4&#125;</code> 不可以。注意，以肯定型后视断言开头的正则表达式，匹配项一般不会位于搜索字符串的开头。很可能你应该使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a> 函数，而不是 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.match" title="re.match"><code>match()</code></a> 函数：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>m &#x3D; re.search(‘(?&lt;&#x3D;abc)def’, ‘abcdef’)<br>m.group(0)<br>‘def’</p>
</blockquote>
</blockquote>
</blockquote>
<p>这个例子搜索一个跟随在连字符后的单词：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.search(r’(?&lt;&#x3D;-)\w+’, ‘spam-egg’)<br>m.group(0)<br>‘egg’</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.5 版更改: 添加定长组合引用的支持。</p>
<p><code>(?&lt;!…)</code></p>
<p>如果 <code>...</code> 的匹配内容没有出现在当前位置的左侧，则匹配。这个叫做 <em>否定型后视断言</em> （negative lookbehind assertion）。类似于肯定型后视断言，内部表达式（匹配的内容）必须是固定长度的。以否定型后视断言开头的正则表达式，匹配项可能位于搜索字符串的开头。</p>
<p><code>(?(id/name)yes-pattern|no-pattern)</code></p>
<p>如果给定的 <em>id</em> 或 <em>name</em> 存在，将会尝试匹配 <code>yes-pattern</code> ，否则就尝试匹配 <code>no-pattern</code>，<code>no-pattern</code> 可选，也可以被忽略。比如， <code>(&lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&gt;|$)</code> 是一个email样式匹配，将匹配 <code>&#39;&lt;user@host.com&gt;&#39;</code> 或 <code>&#39;user@host.com&#39;</code> ，但不会匹配 <code>&#39;&lt;user@host.com&#39;</code> ，也不会匹配 <code>&#39;user@host.com&gt;&#39;</code>。</p>
<p>由 <code>&#39;\&#39;</code> 和一个字符组成的特殊序列在以下列出。 如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，<code>\$</code> 匹配字符 <code>&#39;$&#39;</code>.</p>
<p><code>\number</code></p>
<p>匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 <code>(.+) \1</code> 匹配 <code>&#39;the the&#39;</code> 或者 <code>&#39;55 55&#39;</code>, 但不会匹配 <code>&#39;thethe&#39;</code> (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 <em>number</em> 的第一个数位是0， 或者 <em>number</em> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 <code>&#39;[&#39;</code> 和 <code>&#39;]&#39;</code> 字符集合内，任何数字转义都被看作是字符。</p>
<p><code>\A</code></p>
<p>只匹配字符串开始。</p>
<p><code>\b</code></p>
<p>匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始&#x2F;结尾的边界， 意思就是 <code>r&#39;\bfoo\b&#39;</code> 匹配 <code>&#39;foo&#39;</code>, <code>&#39;foo.&#39;</code>, <code>&#39;(foo)&#39;</code>, <code>&#39;bar foo baz&#39;</code> 但不匹配 <code>&#39;foobar&#39;</code> 或者 <code>&#39;foo3&#39;</code>。</p>
<p>默认情况下，Unicode字母和数字是在Unicode样式中使用的，但是可以用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 标记来更改。如果 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> 标记被设置的话，词的边界是由当前语言区域设置决定的，<code>\b</code> 表示退格字符，以便与Python字符串文本兼容。</p>
<p><code>\B</code></p>
<p>匹配空字符串，但 <em>不</em> 能在词的开头或者结尾。意思就是 <code>r&#39;py\B&#39;</code> 匹配 <code>&#39;python&#39;</code>, <code>&#39;py3&#39;</code>, <code>&#39;py2&#39;</code>, 但不匹配 <code>&#39;py&#39;</code>, <code>&#39;py.&#39;</code>, 或者 <code>&#39;py!&#39;</code>. <code>\B</code> 是 <code>\b</code> 的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 标志来改变。如果使用了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> 标志，则词的边界由当前语言区域设置。</p>
<p><code>\d</code></p>
<p>对于 Unicode (str) 样式：</p>
<p>匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了 <code>[0-9]</code> ，和很多其他的数字字符。如果设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 标志，就只匹配 <code>[0-9]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配任何十进制数，就是 <code>[0-9]</code>。</p>
<p><code>\D</code></p>
<p>匹配任何非十进制数字的字符。就是 <code>\d</code> 取非。 如果设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 标志，就相当于 <code>[^0-9]</code> 。</p>
<p><code>\s</code></p>
<p>对于 Unicode (str) 样式：</p>
<p>匹配任何Unicode空白字符（包括 <code>[ \t\n\r\f\v]</code> ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 被设置，就只匹配 <code>[ \t\n\r\f\v]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配ASCII中的空白字符，就是 <code>[ \t\n\r\f\v]</code> 。</p>
<p><code>\S</code></p>
<p>匹配任何非空白字符。就是 <code>\s</code> 取非。如果设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 标志，就相当于 <code>[^ \t\n\r\f\v]</code> 。</p>
<p><code>\w</code></p>
<p>对于 Unicode (str) 样式：</p>
<p>匹配 Unicode 单词类字符；这包括字母数字字符 (如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isalnum" title="str.isalnum"><code>str.isalnum()</code></a> 所定义的) 以及下划线 (<code>_</code>)。 如果使用了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 旗标，则将只匹配 <code>[a-zA-Z0-9_]</code>。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配ASCII字符中的数字和字母和下划线，就是 <code>[a-zA-Z0-9_]</code> 。如果设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> 标记，就匹配当前语言区域的数字和字母和下划线。</p>
<p><code>\W</code></p>
<p>匹配非单词字符的字符。这与 <code>\w</code> 正相反。如果使用了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 旗标，这就等价于 <code>[^a-zA-Z0-9_]</code>。如果使用了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>LOCALE</code></a> 旗标，则会匹配当前区域中既非字母数字也非下划线的字符。</p>
<p><code>\Z</code></p>
<p>只匹配字符串尾。</p>
<p>绝大部分Python的标准转义字符也被正则表达式分析器支持。:</p>
<p>\a      \b      \f      \n<br>\N      \r      \t      \u<br>\U      \v      \x      \</p>
<p>（注意 <code>\b</code> 被用于表示词语的边界，它只在字符集合内表示退格，比如 <code>[\b]</code> 。）</p>
<p><code>&#39;\u&#39;</code>, <code>&#39;\U&#39;</code> 和 <code>&#39;\N&#39;</code> 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。</p>
<p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p>
<p>在 3.3 版更改: 增加了 <code>&#39;\u&#39;</code> 和 <code>&#39;\U&#39;</code> 转义序列。</p>
<p>在 3.6 版更改: 由 <code>&#39;\&#39;</code> 和一个ASCII字符组成的未知转义会被看成错误。</p>
<p>在 3.8 版更改: 添加了 <code>&#39;\N&#123;name&#125;&#39;</code> 转义序列。 与在字符串字面值中一样，它扩展了命名 Unicode 字符 (例如 <code>&#39;\N&#123;EM DASH&#125;&#39;</code>)。</p>
<h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>模块定义了几个函数、常量，和一个异常。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。重要的应用程序大多会在使用前先编译正则表达式。</p>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>在 3.6 版更改: 标志常量现在是 <code>RegexFlag</code> 类的实例，这个类是 <a href="https://docs.python.org/zh-cn/3.10/library/enum.html#enum.IntFlag" title="enum.IntFlag"><code>enum.IntFlag</code></a> 的子类。</p>
<p><code>re.``A</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.A" title="永久链接至目标"></a></p>
<p><code>re.``ASCII</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="永久链接至目标"></a></p>
<p>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 <code>(?a)</code> 。</p>
<p>注意，为了保持向后兼容， <code>re.U</code> 标记依然存在（还有他的同义 <code>re.UNICODE</code> 和嵌入形式 <code>(?u)</code> ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。</p>
<p><code>re.``DEBUG</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.DEBUG" title="永久链接至目标"></a></p>
<p>显示编译时的debug信息，没有内联标记。</p>
<p><code>re.``I</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.I" title="永久链接至目标"></a></p>
<p><code>re.``IGNORECASE</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.IGNORECASE" title="永久链接至目标"></a></p>
<p>进行忽略大小写匹配；表达式如 <code>[A-Z]</code> 也会匹配小写字符。Unicode匹配（比如 <code>Ü</code> 匹配 <code>ü</code>）同样有用，除非设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>re.ASCII</code></a> 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>re.LOCALE</code></a> 标记。这个相当于内联标记 <code>(?i)</code> 。</p>
<p>注意，当设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.IGNORECASE" title="re.IGNORECASE"><code>IGNORECASE</code></a> 标记，搜索Unicode样式 <code>[a-z]</code> 或 <code>[A-Z]</code> 的结合时，它将会匹配52个ASCII字符和4个额外的非ASCII字符： ‘İ’ (U+0130, 拉丁大写的 I 带个点在上面), ‘ı’ (U+0131, 拉丁小写没有点的 I ), ‘ſ’ (U+017F, 拉丁小写长 s) and ‘K’ (U+212A, 开尔文符号).如果使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>ASCII</code></a> 标记，就只匹配 ‘a’ 到 ‘z’ 和 ‘A’ 到 ‘Z’ 。</p>
<p><code>re.``L</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.L" title="永久链接至目标"></a></p>
<p><code>re.``LOCALE</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="永久链接至目标"></a></p>
<p>由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 <code>(?L)</code> 。</p>
<p>在 3.6 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>re.LOCALE</code></a> 只能用于byte样式，而且不能和 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.ASCII" title="re.ASCII"><code>re.ASCII</code></a> 一起用。</p>
<p>在 3.7 版更改: 设置了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.LOCALE" title="re.LOCALE"><code>re.LOCALE</code></a> 标记的编译正则对象不再在编译时依赖语言区域设置。语言区域设置只在匹配的时候影响其结果。</p>
<p><code>re.``M</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.M" title="永久链接至目标"></a></p>
<p><code>re.``MULTILINE</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.MULTILINE" title="永久链接至目标"></a></p>
<p>设置以后，样式字符 <code>&#39;^&#39;</code> 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 <code>&#39;$&#39;</code> 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，<code>’^’</code> 匹配字符串头，<code>&#39;$&#39;</code> 匹配字符串尾。对应内联标记 <code>(?m)</code> 。</p>
<p><code>re.``S</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.S" title="永久链接至目标"></a></p>
<p><code>re.``DOTALL</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.DOTALL" title="永久链接至目标"></a></p>
<p>让 <code>&#39;.&#39;</code> 特殊字符匹配任何字符，包括换行符；如果没有这个标记，<code>&#39;.&#39;</code> 就匹配 <em>除了</em> 换行符的其他任意字符。对应内联标记 <code>(?s)</code> 。</p>
<p><code>re.``X</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.X" title="永久链接至目标"></a></p>
<p><code>re.``VERBOSE</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.VERBOSE" title="永久链接至目标"></a></p>
<p>这个旗标允许你通过在视觉上分隔表达式的逻辑段落和添加注释来编写更为友好并更具可读性的正则表达式。 表达式中的空白符会被忽略，除非是在字符类中，或前面有一个未转义的反斜杠，或者是在 <code>*?</code>, <code>(?:</code> 或 <code>(?P&lt;...&gt;</code> 等形符之内。 例如，<code>(? :</code> 和 <code>* ?</code> 是不被允许的。 当一个行内包含不在字符类中并且前面没有未转义反斜杠的 <code>#</code> 时，则从最左边的此 <code>#</code> 直至行尾的所有字符都会被忽略。</p>
<p>意思就是下面两个正则表达式等价地匹配一个十进制数字：</p>
<p>a &#x3D; re.compile(r”””\d +  # the integral part<br>                   .    # the decimal point<br>                   \d *  # some fractional digits”””, re.X)<br>b &#x3D; re.compile(r”\d+.\d*”)</p>
<p>对应内联标记 <code>(?x)</code> 。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>re.``compile</code>(<em>pattern</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.compile" title="永久链接至目标"></a></p>
<p>将正则表达式的样式编译为一个 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">正则表达式对象</a> （正则对象），可以用于匹配，通过这个对象的方法 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 以及其他如下描述。</p>
<p>这个表达式的行为可以通过指定 <em>标记</em> 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ <code>|</code> 操作符）。</p>
<p>序列</p>
<p>prog &#x3D; re.compile(pattern)<br>result &#x3D; prog.match(string)</p>
<p>等价于</p>
<p>result &#x3D; re.match(pattern, string)</p>
<p>如果需要多次使用这个正则表达式的话，使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a> 和保存这个正则对象以便复用，可以让程序更加高效。</p>
<p>注解</p>
<p> </p>
<p>通过 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.compile" title="re.compile"><code>re.compile()</code></a> 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p>
<p><code>re.``search</code>(<em>pattern</em>, <em>string</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="永久链接至目标"></a></p>
<p>扫描整个 <em>字符串</em> 找到匹配样式的第一个位置，并返回一个相应的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a>。如果没有匹配，就返回一个 <code>None</code> ； 注意这和找到一个零长度匹配是不同的。</p>
<p><code>re.``match</code>(<em>pattern</em>, <em>string</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.match" title="永久链接至目标"></a></p>
<p>如果 <em>string</em> 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a> 。 如果没有匹配，就返回 <code>None</code> ；注意它跟零长度匹配是不同的。</p>
<p>注意即便是 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> 多行模式， <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.match" title="re.match"><code>re.match()</code></a> 也只匹配字符串的开始位置，而不匹配每行开始。</p>
<p>如果你想定位 <em>string</em> 的任何位置，使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a> 来替代（也可参考 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#search-vs-match">search() vs. match()</a> ）</p>
<p><code>re.``fullmatch</code>(<em>pattern</em>, <em>string</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.fullmatch" title="永久链接至目标"></a></p>
<p>如果整个 <em>string</em> 匹配到正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a> 。 否则就返回一个 <code>None</code> ；注意这跟零长度匹配是不同的。</p>
<p>3.4 新版功能.</p>
<p><code>re.``split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit&#x3D;0</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.split" title="永久链接至目标"></a></p>
<p>用 <em>pattern</em> 分开 <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.split(r’\W+’, ‘Words, words, words.’)<br>[‘Words’, ‘words’, ‘words’, ‘’]<br>re.split(r’(\W+)’, ‘Words, words, words.’)<br>[‘Words’, ‘, ‘, ‘words’, ‘, ‘, ‘words’, ‘.’, ‘’]<br>re.split(r’\W+’, ‘Words, words, words.’, 1)<br>[‘Words’, ‘words, words.’]<br>re.split(‘[a-f]+’, ‘0a3B9’, flags&#x3D;re.IGNORECASE)<br>[‘0’, ‘3’, ‘9’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.split(r’(\W+)’, ‘…words, words…’)<br>[‘’, ‘…’, ‘words’, ‘, ‘, ‘words’, ‘…’, ‘’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>这样的话，分隔组将会出现在结果列表中同样的位置。</p>
<p>样式的空匹配仅在与前一个空匹配不相邻时才会拆分字符串。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.split(r’\b’, ‘Words, words, words.’)<br>[‘’, ‘Words’, ‘, ‘, ‘words’, ‘, ‘, ‘words’, ‘.’]<br>re.split(r’\W*’, ‘…words…’)<br>[‘’, ‘’, ‘w’, ‘o’, ‘r’, ‘d’, ‘s’, ‘’, ‘’]<br>re.split(r’(\W*)’, ‘…words…’)<br>[‘’, ‘…’, ‘’, ‘’, ‘w’, ‘’, ‘o’, ‘’, ‘r’, ‘’, ‘d’, ‘’, ‘s’, ‘…’, ‘’, ‘’, ‘’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.7 版更改: 增加了空字符串的样式分隔。</p>
<p><code>re.``findall</code>(<em>pattern</em>, <em>string</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.findall" title="永久链接至目标"></a></p>
<p>返回 <em>pattern</em> 在 <em>string</em> 中的所有非重叠匹配，以字符串列表或字符串元组列表的形式。对 <em>string</em> 的扫描从左至右，匹配结果按照找到的顺序返回。 空匹配也包括在结果中。</p>
<p>返回结果取决于模式中捕获组的数量。如果没有组，返回与整个模式匹配的字符串列表。如果有且仅有一个组，返回与该组匹配的字符串列表。如果有多个组，返回与这些组匹配的字符串元组列表。非捕获组不影响结果。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.findall(r’\bf[a-z]*’, ‘which foot or hand fell fastest’)<br>[‘foot’, ‘fell’, ‘fastest’]<br>re.findall(r’(\w+)&#x3D;(\d+)’, ‘set width&#x3D;20 and height&#x3D;10’)<br>[(‘width’, ‘20’), (‘height’, ‘10’)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.7 版更改: 非空匹配现在可以在前一个空匹配之后出现了。</p>
<p><code>re.``finditer</code>(<em>pattern</em>, <em>string</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.finditer" title="永久链接至目标"></a></p>
<p><em>pattern</em> 在 <em>string</em> 里所有的非重复匹配，返回为一个迭代器 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 保存了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a> 。 <em>string</em> 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。</p>
<p>在 3.7 版更改: 非空匹配现在可以在前一个空匹配之后出现了。</p>
<p><code>re.``sub</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count&#x3D;0</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.sub" title="永久链接至目标"></a></p>
<p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 _string_。 <em>repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code>\n</code> 会被转换为一个换行符，<code>\r</code> 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code>\&amp;</code> 会保持原样。 向后引用像是 <code>\6</code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.sub(r’def\s+([a-zA-Z_][a-zA-Z_0-9]<em>)\s</em>(\s<em>):’,<br>…        r’static PyObject</em>\npy_\1(void)\n{‘,<br>…        ‘def myfunc():’)<br>‘static PyObject*\npy_myfunc(void)\n{‘</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果 <em>repl</em> 是一个函数，那它会对每个非重复的 <em>pattern</em> 的情况调用。这个函数只能有一个 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a> 参数，并返回一个替换后的字符串。比如</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>def dashrepl(matchobj):<br>…     if matchobj.group(0) &#x3D;&#x3D; ‘-‘: return ‘ ‘<br>…     else: return ‘-‘<br>re.sub(‘-{1,2}’, dashrepl, ‘pro—-gram-files’)<br>‘pro–gram files’<br>re.sub(r’\sAND\s’, ‘ &amp; ‘, ‘Baked Beans And Spam’, flags&#x3D;re.IGNORECASE)<br>‘Baked Beans &amp; Spam’</p>
</blockquote>
</blockquote>
</blockquote>
<p>样式可以是一个字符串或者一个 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">样式对象</a> 。</p>
<p>可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以 <code>sub(&#39;x*&#39;, &#39;-&#39;, &#39;abxd&#39;)</code> 返回 <code>&#39;-a-b--d-&#39;</code> 。</p>
<p>在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code>\g&lt;name&gt;</code> 会使用命名组合 <code>name</code>，（在 <code>(?P&lt;name&gt;…)</code> 语法中定义） <code>\g&lt;number&gt;</code> 会使用数字组；<code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了二义性，如 <code>\g&lt;2&gt;0</code>。 <code>\20</code> 就会被解释为组20，而不是组2后面跟随一个字符 <code>&#39;0&#39;</code>。向后引用 <code>\g&lt;0&gt;</code> 把 <em>pattern</em> 作为一整个组进行引用。</p>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p>在 3.6 版更改: <em>pattern</em> 中的未知转义（由 <code>&#39;\&#39;</code> 和一个 ASCII 字符组成）被视为错误。</p>
<p>在 3.7 版更改: <em>repl</em> 中的未知转义（由 <code>&#39;\&#39;</code> 和一个 ASCII 字符组成）被视为错误。</p>
<p>在 3.7 版更改: 样式中的空匹配相邻接时会被替换。</p>
<p><code>re.``subn</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count&#x3D;0</em>, <em>flags&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.subn" title="永久链接至目标"></a></p>
<p>行为与 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.sub" title="re.sub"><code>sub()</code></a> 相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.</p>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p><code>re.``escape</code>(<em>pattern</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.escape" title="永久链接至目标"></a></p>
<p>转义 <em>pattern</em> 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print(re.escape(‘<a href="https://www.python.org/">https://www.python.org</a>‘))<br><a href="https://www/.python/.org">https://www\.python\.org</a></p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>legal_chars &#x3D; string.ascii_lowercase + string.digits + “!#$%&amp;’*+-.^_<code>|~:&quot; print(&#39;[%s]+&#39; % re.escape(legal_chars)) [abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_</code>|~:]+</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>operators &#x3D; [‘+’, ‘-‘, ‘*’, ‘&#x2F;‘, ‘**’]<br>print(‘|’.join(map(re.escape, sorted(operators, reverse&#x3D;True))))<br>&#x2F;|-|+|**|*</p>
</blockquote>
</blockquote>
</blockquote>
<p>这个函数不能被用于 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.sub" title="re.sub"><code>sub()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.subn" title="re.subn"><code>subn()</code></a> 的替换字符串，只有反斜杠应该被转义。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>digits_re &#x3D; r’\d+’<br>sample &#x3D; ‘&#x2F;usr&#x2F;sbin&#x2F;sendmail - 0 errors, 12 warnings’<br>print(re.sub(digits_re, digits_re.replace(‘\‘, r’\‘), sample))<br>&#x2F;usr&#x2F;sbin&#x2F;sendmail - \d+ errors, \d+ warnings</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.3 版更改: <code>&#39;_&#39;</code> 不再被转义。</p>
<p>在 3.7 版更改: 只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code>&#39;!&#39;</code>, <code>&#39;&quot;&#39;</code>, <code>&#39;%&#39;</code>, <code>&quot;&#39;&quot;</code>, <code>&#39;,&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;:&#39;</code>, <code>&#39;;&#39;</code>, <code>&#39;&lt;&#39;</code>, <code>&#39;=&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;@&#39;</code> 和 <code>&quot;`&quot;</code> 将不再会被转义。</p>
<p><code>re.``purge</code>()<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.purge" title="永久链接至目标"></a></p>
<p>清除正则表达式的缓存。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>re.``error</code>(<em>msg</em>, <em>pattern&#x3D;None</em>, <em>pos&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.error" title="永久链接至目标"></a></p>
<p>当传递给函数的正则表达式不合法（比如括号不匹配），或者在编译或匹配过程中出现其他错误时，会引发异常。所给字符串不匹配所给模式不会引发异常。异常实例有以下附加属性：</p>
<p><code>msg</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.error.msg" title="永久链接至目标"></a></p>
<p>未格式化的错误消息。</p>
<p><code>pattern</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.error.pattern" title="永久链接至目标"></a></p>
<p>正则表达式的模式串。</p>
<p><code>pos</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.error.pos" title="永久链接至目标"></a></p>
<p>编译失败的 <em>pattern</em> 的位置索引（可以是 <code>None</code> ）。</p>
<p><code>lineno</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.error.lineno" title="永久链接至目标"></a></p>
<p>对应 <em>pos</em> (可以是 <code>None</code>) 的行号。</p>
<p><code>colno</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.error.colno" title="永久链接至目标"></a></p>
<p>对应 <em>pos</em> (可以是 <code>None</code>) 的列号。</p>
<p>在 3.5 版更改: 增加了额外的属性。</p>
<h2 id="正则表达式对象-（正则对象）"><a href="#正则表达式对象-（正则对象）" class="headerlink" title="正则表达式对象 （正则对象）"></a>正则表达式对象 （正则对象）</h2><p>编译后的正则表达式对象支持以下方法和属性：</p>
<p><code>Pattern.``search</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="永久链接至目标"></a></p>
<p>扫描整个 <em>string</em> 寻找第一个匹配的位置， 并返回一个相应的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a>。如果没有匹配，就返回 <code>None</code> ；注意它和零长度匹配是不同的。</p>
<p>可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code>0</code>，它不完全等价于字符串切片； <code>&#39;^&#39;</code> 样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。</p>
<p>可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code>pos</code> 到 <code>endpos - 1</code> 的字符会被匹配。如果 <em>endpos</em> 小于 _pos_，就不会有匹配产生；另外，如果 <em>rx</em> 是一个编译后的正则对象， <code>rx.search(string, 0, 50)</code> 等价于 <code>rx.search(string[:50], 0)</code>。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pattern &#x3D; re.compile(“d”)<br>pattern.search(“dog”)     # Match at index 0<br>&lt;re.Match object; span&#x3D;(0, 1), match&#x3D;’d’&gt;<br>pattern.search(“dog”, 1)  # No match; search doesn’t include the “d”</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>Pattern.``match</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="永久链接至目标"></a></p>
<p>如果 <em>string</em> 的 <em>开始位置</em> 能够找到这个正则样式的任意个匹配，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a>。如果不匹配，就返回 <code>None</code> ；注意它与零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 含义相同。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pattern &#x3D; re.compile(“o”)<br>pattern.match(“dog”)      # No match as “o” is not at the start of “dog”.<br>pattern.match(“dog”, 1)   # Match as “o” is the 2nd character of “dog”.<br>&lt;re.Match object; span&#x3D;(1, 2), match&#x3D;’o’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果你想定位匹配在 <em>string</em> 中的位置，使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 来替代（另参考 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#search-vs-match">search() vs. match()</a>）。</p>
<p><code>Pattern.``fullmatch</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.fullmatch" title="永久链接至目标"></a></p>
<p>如果整个 <em>string</em> 匹配这个正则表达式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a> 。 否则就返回 <code>None</code> ； 注意跟零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 含义相同。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pattern &#x3D; re.compile(“o[gh]”)<br>pattern.fullmatch(“dog”)      # No match as “o” is not at the start of “dog”.<br>pattern.fullmatch(“ogre”)     # No match as not the full string matches.<br>pattern.fullmatch(“doggie”, 1, 3)   # Matches within given limits.<br>&lt;re.Match object; span&#x3D;(1, 3), match&#x3D;’og’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.4 新版功能.</p>
<p><code>Pattern.``split</code>(<em>string</em>, <em>maxsplit&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.split" title="永久链接至目标"></a></p>
<p>等价于 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.split" title="re.split"><code>split()</code></a> 函数，使用了编译后的样式。</p>
<p><code>Pattern.``findall</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.findall" title="永久链接至目标"></a></p>
<p>类似函数 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.findall" title="re.findall"><code>findall()</code></a> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a>。</p>
<p><code>Pattern.``finditer</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.finditer" title="永久链接至目标"></a></p>
<p>类似函数 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.finditer" title="re.finditer"><code>finditer()</code></a> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a>。</p>
<p><code>Pattern.``sub</code>(<em>repl</em>, <em>string</em>, <em>count&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.sub" title="永久链接至目标"></a></p>
<p>等价于 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.sub" title="re.sub"><code>sub()</code></a> 函数，使用了编译后的样式。</p>
<p><code>Pattern.``subn</code>(<em>repl</em>, <em>string</em>, <em>count&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.subn" title="永久链接至目标"></a></p>
<p>等价于 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.subn" title="re.subn"><code>subn()</code></a> 函数，使用了编译后的样式。</p>
<p><code>Pattern.``flags</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.flags" title="永久链接至目标"></a></p>
<p>正则匹配标记。这是可以传递给 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.compile" title="re.compile"><code>compile()</code></a> 的参数，任何 <code>(?…)</code> 内联标记，隐性标记比如 <code>UNICODE</code> 的结合。</p>
<p><code>Pattern.``groups</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.groups" title="永久链接至目标"></a></p>
<p>捕获到的模式串中组的数量。</p>
<p><code>Pattern.``groupindex</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.groupindex" title="永久链接至目标"></a></p>
<p>映射由 <code>(?P&lt;id&gt;)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</p>
<p><code>Pattern.``pattern</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.pattern" title="永久链接至目标"></a></p>
<p>编译对象的原始样式字符串。</p>
<p>在 3.7 版更改: 添加 <a href="https://docs.python.org/zh-cn/3.10/library/copy.html#copy.copy" title="copy.copy"><code>copy.copy()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/copy.html#copy.deepcopy" title="copy.deepcopy"><code>copy.deepcopy()</code></a> 函数的支持。编译后的正则表达式对象被认为是原子性的。</p>
<h2 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h2><p>匹配对象总是有一个布尔值 <code>True</code>。如果没有匹配的话 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 返回 <code>None</code> 所以你可以简单的用 <code>if</code> 语句来判断是否匹配</p>
<p>match &#x3D; re.search(pattern, string)<br>if match:<br>    process(match)</p>
<p>匹配对象支持以下方法和属性：</p>
<p><code>Match.``expand</code>(<em>template</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.expand" title="永久链接至目标"></a></p>
<p>对 <em>template</em> 进行反斜杠转义替换并且返回，就像 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.sub" title="re.Pattern.sub"><code>sub()</code></a> 方法中一样。转义如同 <code>\n</code> 被转换成合适的字符，数字引用(<code>\1</code>, <code>\2</code>)和命名组合(<code>\g&lt;1&gt;</code>, <code>\g&lt;name&gt;</code>) 替换为相应组合的内容。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p><code>Match.``group</code>([<em>group1</em>, <em>…</em>])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.group" title="永久链接至目标"></a></p>
<p>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，就引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> 异常。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(\w+) (\w+)”, “Isaac Newton, physicist”)<br>m.group(0)       # The entire match<br>‘Isaac Newton’<br>m.group(1)       # The first parenthesized subgroup.<br>‘Isaac’<br>m.group(2)       # The second parenthesized subgroup.<br>‘Newton’<br>m.group(1, 2)    # Multiple arguments give us a tuple.<br>(‘Isaac’, ‘Newton’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果正则表达式使用了 <code>(?P&lt;name&gt;...)</code> 语法， <em>groupN</em> 参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，就引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> 异常。</p>
<p>一个相对复杂的例子</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(?P<first_name>\w+) (?P<last_name>\w+)”, “Malcolm Reynolds”)<br>m.group(‘first_name’)<br>‘Malcolm’<br>m.group(‘last_name’)<br>‘Reynolds’</p>
</blockquote>
</blockquote>
</blockquote>
<p>命名组合同样可以通过索引值引用</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m.group(1)<br>‘Malcolm’<br>m.group(2)<br>‘Reynolds’</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果一个组匹配成功多次，就只返回最后一个匹配</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(..)+”, “a1b2c3”)  # Matches 3 times.<br>m.group(1)                        # Returns only the last match.<br>‘c3’</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>Match.``__getitem__</code>(<em>g</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.__getitem__" title="永久链接至目标"></a></p>
<p>这个等价于 <code>m.group(g)</code>。这允许更方便的引用一个匹配</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(\w+) (\w+)”, “Isaac Newton, physicist”)<br>m[0]       # The entire match<br>‘Isaac Newton’<br>m[1]       # The first parenthesized subgroup.<br>‘Isaac’<br>m[2]       # The second parenthesized subgroup.<br>‘Newton’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.6 新版功能.</p>
<p><code>Match.``groups</code>(<em>default&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.groups" title="永久链接至目标"></a></p>
<p>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code>None</code>。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(\d+).(\d+)”, “24.1632”)<br>m.groups()<br>(‘24’, ‘1632’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code>None</code> ，除非指定了 <em>default</em> 参数。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(\d+).?(\d+)?”, “24”)<br>m.groups()      # Second group defaults to None.<br>(‘24’, None)<br>m.groups(‘0’)   # Now, the second group defaults to ‘0’.<br>(‘24’, ‘0’)</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>Match.``groupdict</code>(<em>default&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.groupdict" title="永久链接至目标"></a></p>
<p>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code>None</code>。 例如</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; re.match(r”(?P<first_name>\w+) (?P<last_name>\w+)”, “Malcolm Reynolds”)<br>m.groupdict()<br>{‘first_name’: ‘Malcolm’, ‘last_name’: ‘Reynolds’}</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>Match.``start</code>([<em>group</em>])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.start" title="永久链接至目标"></a></p>
<p><code>Match.``end</code>([<em>group</em>])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.end" title="永久链接至目标"></a></p>
<p>返回 <em>group</em> 匹配到的字串的开始和结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果 <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code> 。对于一个匹配对象 _m_， 和一个未参与匹配的组 <em>g</em> ，组 <em>g</em> (等价于 <code>m.group(g)</code>)产生的匹配是</p>
<p>m.string[m.start(g):m.end(g)]</p>
<p>注意 <code>m.start(group)</code> 将会等于 <code>m.end(group)</code> ，如果 <em>group</em> 匹配一个空字符串的话。比如，在 <code>m = re.search(&#39;b(c?)&#39;, &#39;cba&#39;)</code> 之后，<code>m.start(0)</code> 为 1, <code>m.end(0)</code> 为 2, <code>m.start(1)</code> 和 <code>m.end(1)</code> 都是 2, <code>m.start(2)</code> 引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> 异常。</p>
<p>这个例子会从email地址中移除掉 <em>remove_this</em></p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>email &#x3D; “<a href="mailto:&#x74;&#x6f;&#x6e;&#x79;&#x40;&#x74;&#105;&#x72;&#x65;&#x6d;&#111;&#x76;&#x65;&#95;&#116;&#104;&#x69;&#x73;&#103;&#101;&#x72;&#46;&#x6e;&#101;&#x74;">&#x74;&#x6f;&#x6e;&#x79;&#x40;&#x74;&#105;&#x72;&#x65;&#x6d;&#111;&#x76;&#x65;&#95;&#116;&#104;&#x69;&#x73;&#103;&#101;&#x72;&#46;&#x6e;&#101;&#x74;</a>“<br>m &#x3D; re.search(“remove_this”, email)<br>email[:m.start()] + email[m.end():]<br>‘<a href="mailto:&#116;&#x6f;&#110;&#121;&#64;&#116;&#105;&#103;&#101;&#114;&#46;&#110;&#x65;&#x74;">&#116;&#x6f;&#110;&#121;&#64;&#116;&#105;&#103;&#101;&#114;&#46;&#110;&#x65;&#x74;</a>‘</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>Match.``span</code>([<em>group</em>])<a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.span" title="永久链接至目标"></a></p>
<p>对于一个匹配 <em>m</em> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。<em>group</em> 默认为0，就是整个匹配。</p>
<p><code>Match.``pos</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.pos" title="永久链接至目标"></a></p>
<p><em>pos</em> 的值，会传递给 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> 的方法 a <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">正则对象</a> 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。</p>
<p><code>Match.``endpos</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.endpos" title="永久链接至目标"></a></p>
<p><em>endpos</em> 的值，会传递给 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> 的方法 a <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">正则对象</a> 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。</p>
<p><code>Match.``lastindex</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.lastindex" title="永久链接至目标"></a></p>
<p>捕获组的最后一个匹配的整数索引值，或者 <code>None</code> 如果没有匹配产生的话。比如，对于字符串 <code>&#39;ab&#39;</code>，表达式 <code>(a)b</code>, <code>((a)(b))</code>, 和 <code>((ab))</code> 将得到 <code>lastindex == 1</code> ， 而 <code>(a)(b)</code> 会得到 <code>lastindex == 2</code> 。</p>
<p><code>Match.``lastgroup</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.lastgroup" title="永久链接至目标"></a></p>
<p>最后一个匹配的命名组名字，或者 <code>None</code> 如果没有产生匹配的话。</p>
<p><code>Match.``re</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.re" title="永久链接至目标"></a></p>
<p>返回产生这个实例的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">正则对象</a> ， 这个实例是由 正则对象的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 方法产生的。</p>
<p><code>Match.``string</code><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.string" title="永久链接至目标"></a></p>
<p>传递到 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.match" title="re.Pattern.match"><code>match()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Pattern.search" title="re.Pattern.search"><code>search()</code></a> 的字符串。</p>
<p>在 3.7 版更改: 添加了对 <a href="https://docs.python.org/zh-cn/3.10/library/copy.html#copy.copy" title="copy.copy"><code>copy.copy()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/copy.html#copy.deepcopy" title="copy.deepcopy"><code>copy.deepcopy()</code></a> 的支持。匹配对象被看作是原子性的。</p>
<h2 id="正则表达式例子"><a href="#正则表达式例子" class="headerlink" title="正则表达式例子"></a>正则表达式例子</h2><h3 id="检查对子"><a href="#检查对子" class="headerlink" title="检查对子"></a>检查对子</h3><p>在这个例子里，我们使用以下辅助函数来更好地显示匹配对象:</p>
<p>def displaymatch(match):<br>    if match is None:<br>        return None<br>    return ‘&lt;Match: %r, groups&#x3D;%r&gt;’ % (match.group(), match.groups())</p>
<p>假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，”a” 就是 A, “k” K， “q” Q, “j” J, “t” 为 10, “2” 到 “9” 表示2 到 9。</p>
<p>要看给定的字符串是否有效，我们可以按照以下步骤</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>valid &#x3D; re.compile(r”^[a2-9tjqk]{5}$”)<br>displaymatch(valid.match(“akt5q”))  # Valid.<br>“&lt;Match: ‘akt5q’, groups&#x3D;()&gt;”<br>displaymatch(valid.match(“akt5e”))  # Invalid.<br>displaymatch(valid.match(“akt”))    # Invalid.<br>displaymatch(valid.match(“727ak”))  # Valid.<br>“&lt;Match: ‘727ak’, groups&#x3D;()&gt;”</p>
</blockquote>
</blockquote>
</blockquote>
<p>最后一手牌，<code>&quot;727ak&quot;</code> ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pair &#x3D; re.compile(r”.*(.).*\1”)<br>displaymatch(pair.match(“717ak”))     # Pair of 7s.<br>“&lt;Match: ‘717’, groups&#x3D;(‘7’,)&gt;”<br>displaymatch(pair.match(“718ak”))     # No pairs.<br>displaymatch(pair.match(“354aa”))     # Pair of aces.<br>“&lt;Match: ‘354aa’, groups&#x3D;(‘a’,)&gt;”</p>
</blockquote>
</blockquote>
</blockquote>
<p>要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.Match.group" title="re.Match.group"><code>group()</code></a> 方法:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pair &#x3D; re.compile(r”.*(.).*\1”)<br>pair.match(“717ak”).group(1)<br>‘7’</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Error-because-re-match-returns-None-which-doesn’t-have-a-group-method"><a href="#Error-because-re-match-returns-None-which-doesn’t-have-a-group-method" class="headerlink" title="Error because re.match() returns None, which doesn’t have a group() method"></a>Error because re.match() returns None, which doesn’t have a group() method</h1><blockquote>
<blockquote>
<blockquote>
<p>pair.match(“718ak”).group(1)<br>Traceback (most recent call last):<br>  File “&lt;pyshell#23&gt;”, line 1, in <module><br>    re.match(r”.*(.).*\1”, “718ak”).group(1)<br>AttributeError: ‘NoneType’ object has no attribute ‘group’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pair.match(“354aa”).group(1)<br>‘a’</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="模拟-scanf"><a href="#模拟-scanf" class="headerlink" title="模拟 scanf()"></a>模拟 scanf()</h3><p>Python 目前没有一个类似c函数 <code>scanf()</code> 的替代品。正则表达式通常比 <code>scanf()</code> 格式字符串要更强大一些，但也带来更多复杂性。下面的表格提供了 <code>scanf()</code> 格式符和正则表达式大致相同的映射。</p>
<table>
<thead>
<tr>
<th><code>scanf()</code> 格式符</th>
<th>正则表达式</th>
</tr>
</thead>
<tbody><tr>
<td><code>%c</code></td>
<td><code>.</code></td>
</tr>
<tr>
<td><code>%5c</code></td>
<td><code>.&#123;5&#125;</code></td>
</tr>
<tr>
<td><code>%d</code></td>
<td><code>[-+]?\d+</code></td>
</tr>
<tr>
<td><code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%g</code></td>
<td><code>[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</code></td>
</tr>
<tr>
<td><code>%i</code></td>
<td><code>[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</code></td>
</tr>
<tr>
<td><code>%o</code></td>
<td><code>[-+]?[0-7]+</code></td>
</tr>
<tr>
<td><code>%s</code></td>
<td><code>\S+</code></td>
</tr>
<tr>
<td><code>%u</code></td>
<td><code>\d+</code></td>
</tr>
<tr>
<td><code>%x</code>, <code>%X</code></td>
<td><code>[-+]?(0[xX])?[\dA-Fa-f]+</code></td>
</tr>
</tbody></table>
<p>从文件名和数字提取字符串</p>
<p>&#x2F;usr&#x2F;sbin&#x2F;sendmail - 0 errors, 4 warnings</p>
<p>你可以使用 <code>scanf()</code> 格式化</p>
<p>%s - %d errors, %d warnings</p>
<p>等价的正则表达式是：</p>
<p>(\S+) - (\d+) errors, (\d+) warnings</p>
<h3 id="search-vs-match"><a href="#search-vs-match" class="headerlink" title="search() vs. match()"></a>search() vs. match()</h3><p>Python 基于正则表达式提供了不同的原始操作:</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.match" title="re.match"><code>re.match()</code></a> 只在字符串的开头位置检测匹配。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>re.search()</code></a> 在字符串中的任何位置检测匹配（这也是 Perl 在默认情况下所做的）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.fullmatch" title="re.fullmatch"><code>re.fullmatch()</code></a> 检测整个字符串是否匹配</p>
</li>
</ul>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.match(“c”, “abcdef”)    # No match<br>re.search(“c”, “abcdef”)   # Match<br>&lt;re.Match object; span&#x3D;(2, 3), match&#x3D;’c’&gt;<br>re.fullmatch(“p.*n”, “python”) # Match<br>&lt;re.Match object; span&#x3D;(0, 6), match&#x3D;’python’&gt;<br>re.fullmatch(“r.*n”, “python”) # No match</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a> 中，可以用 <code>&#39;^&#39;</code> 作为开始来限制匹配到字符串的首位</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.match(“c”, “abcdef”)    # No match<br>re.search(“^c”, “abcdef”)  # No match<br>re.search(“^a”, “abcdef”)  # Match<br>&lt;re.Match object; span&#x3D;(0, 1), match&#x3D;’a’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>注意 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.MULTILINE" title="re.MULTILINE"><code>MULTILINE</code></a> 多行模式中函数 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.match" title="re.match"><code>match()</code></a> 只匹配字符串的开始，但使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a> 和以 <code>&#39;^&#39;</code> 开始的正则表达式会匹配每行的开始</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.match(“X”, “A\nB\nX”, re.MULTILINE)  # No match<br>re.search(“^X”, “A\nB\nX”, re.MULTILINE)  # Match<br>&lt;re.Match object; span&#x3D;(4, 5), match&#x3D;’X’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="制作一个电话本"><a href="#制作一个电话本" class="headerlink" title="制作一个电话本"></a>制作一个电话本</h3><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.split" title="re.split"><code>split()</code></a> 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。</p>
<p>首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>text &#x3D; “””Ross McFluff: 834.345.1254 155 Elm Street<br>…<br>… Ronald Heathmore: 892.345.3428 436 Finley Avenue<br>… Frank Burger: 925.541.7625 662 South Dogwood Way<br>…<br>…<br>… Heather Albrecht: 548.326.4584 919 Park Place”””</p>
</blockquote>
</blockquote>
</blockquote>
<p>条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>entries &#x3D; re.split(“\n+”, text)<br>entries<br>[‘Ross McFluff: 834.345.1254 155 Elm Street’,<br>‘Ronald Heathmore: 892.345.3428 436 Finley Avenue’,<br>‘Frank Burger: 925.541.7625 662 South Dogwood Way’,<br>‘Heather Albrecht: 548.326.4584 919 Park Place’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.split" title="re.split"><code>split()</code></a> 使用了 <code>maxsplit</code> 形参，因为地址中包含有被我们作为分割模式的空格符:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>[re.split(“:? “, entry, 3) for entry in entries]<br>[[‘Ross’, ‘McFluff’, ‘834.345.1254’, ‘155 Elm Street’],<br>[‘Ronald’, ‘Heathmore’, ‘892.345.3428’, ‘436 Finley Avenue’],<br>[‘Frank’, ‘Burger’, ‘925.541.7625’, ‘662 South Dogwood Way’],<br>[‘Heather’, ‘Albrecht’, ‘548.326.4584’, ‘919 Park Place’]]</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>:?</code> 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 <code>maxsplit</code> 设置为 <code>4</code> ，我们还可以从地址中获取到房间号:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>[re.split(“:? “, entry, 4) for entry in entries]<br>[[‘Ross’, ‘McFluff’, ‘834.345.1254’, ‘155’, ‘Elm Street’],<br>[‘Ronald’, ‘Heathmore’, ‘892.345.3428’, ‘436’, ‘Finley Avenue’],<br>[‘Frank’, ‘Burger’, ‘925.541.7625’, ‘662’, ‘South Dogwood Way’],<br>[‘Heather’, ‘Albrecht’, ‘548.326.4584’, ‘919’, ‘Park Place’]]</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="文字整理"><a href="#文字整理" class="headerlink" title="文字整理"></a>文字整理</h3><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.sub" title="re.sub"><code>sub()</code></a> 替换字符串中出现的样式的每一个实例。这个例子证明了使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.sub" title="re.sub"><code>sub()</code></a> 来整理文字，或者随机化每个字符的位置，除了首位和末尾字符</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>def repl(m):<br>…     inner_word &#x3D; list(m.group(2))<br>…     random.shuffle(inner_word)<br>…     return m.group(1) + “”.join(inner_word) + m.group(3)<br>text &#x3D; “Professor Abdolmalek, please report your absences promptly.”<br>re.sub(r”(\w)(\w+)(\w)”, repl, text)<br>‘Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.’<br>re.sub(r”(\w)(\w+)(\w)”, repl, text)<br>‘Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.’</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="查找所有副词"><a href="#查找所有副词" class="headerlink" title="查找所有副词"></a>查找所有副词</h3><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.findall" title="re.findall"><code>findall()</code></a> 匹配样式 <em>所有</em> 的出现，不仅是像 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.search" title="re.search"><code>search()</code></a> 中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.findall" title="re.findall"><code>findall()</code></a></p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>text &#x3D; “He was carefully disguised but captured quickly by police.”<br>re.findall(r”\w+ly\b”, text)<br>[‘carefully’, ‘quickly’]</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="查找所有的副词及其位置"><a href="#查找所有的副词及其位置" class="headerlink" title="查找所有的副词及其位置"></a>查找所有的副词及其位置</h3><p>如果需要匹配样式的更多信息， <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.finditer" title="re.finditer"><code>finditer()</code></a> 可以起到作用，它提供了 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">匹配对象</a> 作为返回值，而不是字符串。继续上面的例子，如果一个作者希望找到所有副词和它的位置，可以按照下面方法使用 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#re.finditer" title="re.finditer"><code>finditer()</code></a></p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>text &#x3D; “He was carefully disguised but captured quickly by police.”<br>for m in re.finditer(r”\w+ly\b”, text):<br>…     print(‘%02d-%02d: %s’ % (m.start(), m.end(), m.group(0)))<br>07-16: carefully<br>40-47: quickly</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="原始字符串标记"><a href="#原始字符串标记" class="headerlink" title="原始字符串标记"></a>原始字符串标记</h3><p>原始字符串记法 (<code>r&quot;text&quot;</code>) 保持正则表达式正常。否则，每个正则式里的反斜杠(<code>&#39;\&#39;</code>) 都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.match(r”\W(.)\1\W”, “ ff “)<br>&lt;re.Match object; span&#x3D;(0, 4), match&#x3D;’ ff ‘&gt;<br>re.match(“\W(.)\1\W”, “ ff “)<br>&lt;re.Match object; span&#x3D;(0, 4), match&#x3D;’ ff ‘&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 <code>r&quot;\\&quot;</code>。否则就必须用 <code>&quot;\\\\&quot;</code>，来表示同样的意思</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>re.match(r”\“, r”\“)<br>&lt;re.Match object; span&#x3D;(0, 1), match&#x3D;’\‘&gt;<br>re.match(“\\“, r”\“)<br>&lt;re.Match object; span&#x3D;(0, 1), match&#x3D;’\‘&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="写一个词法分析器"><a href="#写一个词法分析器" class="headerlink" title="写一个词法分析器"></a>写一个词法分析器</h3><p>一个 <a href="https://en.wikipedia.org/wiki/Lexical_analysis">词法器或词法分析器</a> 分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。</p>
<p>文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的</p>
<p>from typing import NamedTuple<br>import re</p>
<p>class Token(NamedTuple):<br>    type: str<br>    value: str<br>    line: int<br>    column: int</p>
<p>def tokenize(code):<br>    keywords &#x3D; {‘IF’, ‘THEN’, ‘ENDIF’, ‘FOR’, ‘NEXT’, ‘GOSUB’, ‘RETURN’}<br>    token_specification &#x3D; [<br>        (‘NUMBER’,   r’\d+(.\d*)?’),  # Integer or decimal number<br>        (‘ASSIGN’,   r’:&#x3D;’),           # Assignment operator<br>        (‘END’,      r’;’),            # Statement terminator<br>        (‘ID’,       r’[A-Za-z]+’),    # Identifiers<br>        (‘OP’,       r’[+-*&#x2F;]’),      # Arithmetic operators<br>        (‘NEWLINE’,  r’\n’),           # Line endings<br>        (‘SKIP’,     r’[ \t]+’),       # Skip over spaces and tabs<br>        (‘MISMATCH’, r’.’),            # Any other character<br>    ]<br>    tok_regex &#x3D; ‘|’.join(‘(?P&lt;%s&gt;%s)’ % pair for pair in token_specification)<br>    line_num &#x3D; 1<br>    line_start &#x3D; 0<br>    for mo in re.finditer(tok_regex, code):<br>        kind &#x3D; mo.lastgroup<br>        value &#x3D; mo.group()<br>        column &#x3D; mo.start() - line_start<br>        if kind &#x3D;&#x3D; ‘NUMBER’:<br>            value &#x3D; float(value) if ‘.’ in value else int(value)<br>        elif kind &#x3D;&#x3D; ‘ID’ and value in keywords:<br>            kind &#x3D; value<br>        elif kind &#x3D;&#x3D; ‘NEWLINE’:<br>            line_start &#x3D; mo.end()<br>            line_num +&#x3D; 1<br>            continue<br>        elif kind &#x3D;&#x3D; ‘SKIP’:<br>            continue<br>        elif kind &#x3D;&#x3D; ‘MISMATCH’:<br>            raise RuntimeError(f’{value!r} unexpected on line {line_num}’)<br>        yield Token(kind, value, line_num, column)</p>
<p>statements &#x3D; ‘’’<br>    IF quantity THEN<br>        total :&#x3D; total + price * quantity;<br>        tax :&#x3D; price * 0.05;<br>    ENDIF;<br>‘’’</p>
<p>for token in tokenize(statements):<br>    print(token)</p>
<p>该词法器产生以下的输出</p>
<p>Token(type&#x3D;’IF’, value&#x3D;’IF’, line&#x3D;2, column&#x3D;4)<br>Token(type&#x3D;’ID’, value&#x3D;’quantity’, line&#x3D;2, column&#x3D;7)<br>Token(type&#x3D;’THEN’, value&#x3D;’THEN’, line&#x3D;2, column&#x3D;16)<br>Token(type&#x3D;’ID’, value&#x3D;’total’, line&#x3D;3, column&#x3D;8)<br>Token(type&#x3D;’ASSIGN’, value&#x3D;’:&#x3D;’, line&#x3D;3, column&#x3D;14)<br>Token(type&#x3D;’ID’, value&#x3D;’total’, line&#x3D;3, column&#x3D;17)<br>Token(type&#x3D;’OP’, value&#x3D;’+’, line&#x3D;3, column&#x3D;23)<br>Token(type&#x3D;’ID’, value&#x3D;’price’, line&#x3D;3, column&#x3D;25)<br>Token(type&#x3D;’OP’, value&#x3D;’<em>‘, line&#x3D;3, column&#x3D;31)<br>Token(type&#x3D;’ID’, value&#x3D;’quantity’, line&#x3D;3, column&#x3D;33)<br>Token(type&#x3D;’END’, value&#x3D;’;’, line&#x3D;3, column&#x3D;41)<br>Token(type&#x3D;’ID’, value&#x3D;’tax’, line&#x3D;4, column&#x3D;8)<br>Token(type&#x3D;’ASSIGN’, value&#x3D;’:&#x3D;’, line&#x3D;4, column&#x3D;12)<br>Token(type&#x3D;’ID’, value&#x3D;’price’, line&#x3D;4, column&#x3D;15)<br>Token(type&#x3D;’OP’, value&#x3D;’</em>‘, line&#x3D;4, column&#x3D;21)<br>Token(type&#x3D;’NUMBER’, value&#x3D;0.05, line&#x3D;4, column&#x3D;23)<br>Token(type&#x3D;’END’, value&#x3D;’;’, line&#x3D;4, column&#x3D;27)<br>Token(type&#x3D;’ENDIF’, value&#x3D;’ENDIF’, line&#x3D;5, column&#x3D;4)<br>Token(type&#x3D;’END’, value&#x3D;’;’, line&#x3D;5, column&#x3D;9)</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#id1">Frie09</a></p>
<p>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. 该书的第三版不再包含 Python，但第一版极详细地覆盖了正则表达式模式串的编写。</p>
]]></content>
      <tags>
        <tag>Python Python标准库 re模块 正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%86%85%E7%BD%AE%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>有少数的常量存在于内置命名空间中。 它们是：</p>
<p><code>False</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#False" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bool" title="bool"><code>bool</code></a> 类型的假值。 给 <code>False</code> 赋值是非法的并会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>。</p>
<p><code>True</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#True" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bool" title="bool"><code>bool</code></a> 类型的真值。 给 <code>True</code> 赋值是非法的并会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>。</p>
<p><code>None</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#None" title="永久链接至目标"></a></p>
<p>通常被用来代表空值的对象，例如在未向某个函数传入默认参数时。 给 <code>None</code> 赋值是非法的并会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a>。 <code>None</code> 是 <code>NoneType</code> 类型的唯一实例。</p>
<p><code>NotImplemented</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#NotImplemented" title="永久链接至目标"></a></p>
<p>应当由双目运算特殊方法（如 <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code> 等）返回的特殊值，用于表明运算没有针对其他类型的实现；也可由原地双目运算特殊方法（如 <code>__imul__()</code>, <code>__iand__()</code> 等）出于同样的目的而返回。 它不应在布尔运算中被求值。 <code>NotImplemented</code> 是 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.NotImplementedType" title="types.NotImplementedType"><code>types.NotImplementedType</code></a> 类型的唯一实例。</p>
<p>注解</p>
<p> </p>
<p>当二进制（或就地）方法返回 <code>NotImplemented</code> 时，解释器将尝试对另一种类型（或其他一些回滚操作，取决于运算符）的反射操作。 如果所有尝试都返回 <code>NotImplemented</code> ，则解释器将引发适当的异常。 错误返回的 <code>NotImplemented</code> 将导致误导性错误消息或返回到Python代码中的 <code>NotImplemented</code> 值。</p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#implementing-the-arithmetic-operations">实现算术运算</a> 为例。</p>
<p>注解</p>
<p> </p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 有关何时使用它的详细信息，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a>。</p>
<p>在 3.9 版更改: 作为布尔值来解读 <code>NotImplemented</code> 已被弃用。 虽然它目前会被解读为真值，但将同时发出 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a>。 它将在未来的 Python 版本中引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。</p>
<p><code>Ellipsis</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#Ellipsis" title="永久链接至目标"></a></p>
<p>与省略号字面值 “<code>...</code>“ 相同。 该特殊值主要是与用户定义的容器数据类型的扩展切片语法结合使用。 <code>Ellipsis</code> 是 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.EllipsisType" title="types.EllipsisType"><code>types.EllipsisType</code></a> 类型的唯一实例。</p>
<p><code>__debug__</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#debug__" title="永久链接至目标"></a></p>
<p>如果 Python 没有以 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-O"><code>-O</code></a> 选项启动，则此常量为真值。 另请参见 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#assert"><code>assert</code></a> 语句。</p>
<p>注解</p>
<p> </p>
<p>变量名 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#None" title="None"><code>None</code></a>，<a href="https://docs.python.org/zh-cn/3.10/library/constants.html#False" title="False"><code>False</code></a>，<a href="https://docs.python.org/zh-cn/3.10/library/constants.html#True" title="True"><code>True</code></a> 和 <code>__ debug__</code> 无法重新赋值（赋值给它们，即使是属性名，将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> ），所以它们可以被认为是“真正的”常数。</p>
<h2 id="由site模块添加的常量"><a href="#由site模块添加的常量" class="headerlink" title="由site模块添加的常量"></a>由site模块添加的常量</h2><p><a href="https://docs.python.org/zh-cn/3.10/library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> 模块（在启动期间自动导入，除非给出 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-S"><code>-S</code></a> 命令行选项）将几个常量添加到内置命名空间。 它们对交互式解释器 shell 很有用，并且不应在程序中使用。</p>
<p><code>quit</code>(<em>code&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/constants.html#quit" title="永久链接至目标"></a></p>
<p><code>exit</code>(<em>code&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/constants.html#exit" title="永久链接至目标"></a></p>
<p>当打印此对象时，会打印出一条消息，例如“Use quit() or Ctrl-D (i.e. EOF) to exit”，当调用此对象时，将使用指定的退出代码来引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SystemExit" title="SystemExit"><code>SystemExit</code></a>。</p>
<p><code>copyright</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#copyright" title="永久链接至目标"></a></p>
<p><code>credits</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#credits" title="永久链接至目标"></a></p>
<p>打印或调用的对象分别打印版权或作者的文本。</p>
<p><code>license</code><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#license" title="永久链接至目标"></a></p>
<p>当打印此对象时，会打印出一条消息“Type license() to see the full license text”，当调用此对象时，将以分页形式显示完整的许可证文本（每次显示一屏）。</p>
]]></content>
      <tags>
        <tag>Python Python标准库 内置常量</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。</p>
<table>
<thead>
<tr>
<th>内置函数</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>A</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#abs" title="abs"><code>abs()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#aiter" title="aiter"><code>aiter()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#all" title="all"><code>all()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#any" title="any"><code>any()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#anext" title="anext"><code>anext()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ascii" title="ascii"><code>ascii()</code></a><br><br>  <br><br><strong>B</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bin" title="bin"><code>bin()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bool" title="bool"><code>bool()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#breakpoint" title="breakpoint"><code>breakpoint()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-bytearray"><code>bytearray()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-bytes"><code>bytes()</code></a><br><br>  <br><br><strong>C</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#callable" title="callable"><code>callable()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#chr" title="chr"><code>chr()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#classmethod" title="classmethod"><code>classmethod()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#compile" title="compile"><code>compile()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex()</code></a><br><br>  <br><br><strong>D</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#delattr" title="delattr"><code>delattr()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-dict"><code>dict()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#dir" title="dir"><code>dir()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#divmod" title="divmod"><code>divmod()</code></a></td>
<td><strong>E</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#enumerate" title="enumerate"><code>enumerate()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a><br><br>  <br><br><strong>F</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#filter" title="filter"><code>filter()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-frozenset"><code>frozenset()</code></a><br><br>  <br><br><strong>G</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#globals" title="globals"><code>globals()</code></a><br><br>  <br><br><strong>H</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hasattr" title="hasattr"><code>hasattr()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hash" title="hash"><code>hash()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#help" title="help"><code>help()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hex" title="hex"><code>hex()</code></a><br><br>  <br><br><strong>I</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#id" title="id"><code>id()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#input" title="input"><code>input()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="iter"><code>iter()</code></a></td>
<td><strong>L</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#len" title="len"><code>len()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-list"><code>list()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a><br><br>  <br><br><strong>M</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#map" title="map"><code>map()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#max" title="max"><code>max()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-memoryview"><code>memoryview()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#min" title="min"><code>min()</code></a><br><br>  <br><br><strong>N</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#next" title="next"><code>next()</code></a><br><br>  <br><br><strong>O</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#oct" title="oct"><code>oct()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ord" title="ord"><code>ord()</code></a><br><br>  <br><br><strong>P</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#pow" title="pow"><code>pow()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#print" title="print"><code>print()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#property" title="property"><code>property()</code></a></td>
<td><strong>R</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-range"><code>range()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#reversed" title="reversed"><code>reversed()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#round" title="round"><code>round()</code></a><br><br>  <br><br><strong>S</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-set"><code>set()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="setattr"><code>setattr()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#slice" title="slice"><code>slice()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted" title="sorted"><code>sorted()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#staticmethod" title="staticmethod"><code>staticmethod()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-str"><code>str()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sum" title="sum"><code>sum()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a><br><br>  <br><br><strong>T</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-tuple"><code>tuple()</code></a><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="type"><code>type()</code></a><br><br>  <br><br><strong>V</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#vars" title="vars"><code>vars()</code></a><br><br>  <br><br><strong>Z</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a><br><br>  <br><br><strong>_</strong><br><br><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#import__" title="__import__"><code>__import__()</code></a></td>
</tr>
</tbody></table>
<p><code>abs</code>(<em>x</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#abs" title="永久链接至目标"></a></p>
<p>返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 <code>__abs__()</code> 的对象。 如果参数是一个复数，则返回它的模。</p>
<p><code>aiter</code>(<em>async_iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#aiter" title="永久链接至目标"></a></p>
<p>返回 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-iterable">asynchronous iterable</a> 的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-iterator">asynchronous iterator</a> 。相当于调用 <code>x.__aiter__()</code>。</p>
<p>注意：与 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="iter"><code>iter()</code></a> 不同，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#aiter" title="aiter"><code>aiter()</code></a> 没有两个参数的版本。</p>
<p>3.10 新版功能.</p>
<p><code>all</code>(<em>iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#all" title="永久链接至目标"></a></p>
<p>如果 <em>iterable</em> 的所有元素均为真值（或可迭代对象为空）则返回 <code>True</code> 。 等价于：</p>
<p>def all(iterable):<br>    for element in iterable:<br>        if not element:<br>            return False<br>    return True</p>
<p><em>awaitable</em> <code>anext</code>(<em>async_iterator</em>[, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#anext" title="永久链接至目标"></a></p>
<p>当进入 await 状态时，从给定 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-iterator">asynchronous iterator</a> 返回下一数据项，迭代完毕则返回 _default_。</p>
<p>这是内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#next" title="next"><code>next()</code></a> 的异步版本，类似于：</p>
<p>调用 <em>async_iterator</em> 的 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__anext__" title="object.__anext__"><code>__anext__()</code></a> 方法，返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-awaitable">awaitable</a>。等待返回迭代器的下一个值。若有给出 _default_，则在迭代完毕后会返回给出的值，否则会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code>StopAsyncIteration</code></a>。</p>
<p>3.10 新版功能.</p>
<p><code>any</code>(<em>iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#any" title="永久链接至目标"></a></p>
<p>如果 <em>iterable</em> 的任一元素为真值则返回 <code>True</code>。 如果可迭代对象为空，返回 <code>False</code>。 等价于:</p>
<p>def any(iterable):<br>    for element in iterable:<br>        if element:<br>            return True<br>    return False</p>
<p><code>ascii</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ascii" title="永久链接至目标"></a></p>
<p>与 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 类似，返回一个包含对象的可打印表示形式的字符串，但是使用 <code>\x</code>、<code>\u</code> 和 <code>\U</code> 对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 返回的字符串中非 ASCII 编码的字符进行转义。生成的字符串和 Python 2 的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 返回的结果相似。</p>
<p><code>bin</code>(<em>x</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bin" title="永久链接至目标"></a></p>
<p>将整数转变为以“0b”前缀的二进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 对象，它必须定义 <code>__index__()</code> 方法，以便返回整数值。下面是一些例子：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bin(3)<br>‘0b11’<br>bin(-10)<br>‘-0b1010’</p>
</blockquote>
</blockquote>
</blockquote>
<p>若要控制是否显示前缀“0b”，可以采用以下两种方案：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>format(14, ‘#b’), format(14, ‘b’)<br>(‘0b1110’, ‘1110’)<br>f’{14:#b}’, f’{14:b}’<br>(‘0b1110’, ‘1110’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>另见 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a> 获取更多信息。</p>
<p><em>class</em> <code>bool</code>([<em>x</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bool" title="永久链接至目标"></a></p>
<p>返回布尔值，<code>True</code> 或 <code>False</code>。<em>x</em> 用标准的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#truth">真值测试过程</a> 进行转换。如果 <em>x</em> 为 False 或省略，则返回 <code>False</code>；否则返回 <code>True</code>。 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bool" title="bool"><code>bool</code></a> 类是 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 的子类（见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesnumeric">数字类型 — int, float, complex</a> ）。它不能再被继承。它唯一的实例就是 <code>False</code> 和 <code>True</code> （参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bltin-boolean-values">布尔值</a> ）。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p><code>breakpoint</code>(<em>*args</em>, <em>**kws</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#breakpoint" title="永久链接至目标"></a></p>
<p>此函数会在调用点进入调试器。具体来说，它调用 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.breakpointhook" title="sys.breakpointhook"><code>sys.breakpointhook()</code></a> ，直接传递 <code>args</code> 和 <code>kws</code> 。默认情况下， <code>sys.breakpointhook()</code> 调用 <a href="https://docs.python.org/zh-cn/3.10/library/pdb.html#pdb.set_trace" title="pdb.set_trace"><code>pdb.set_trace()</code></a> 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 <a href="https://docs.python.org/zh-cn/3.10/library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code>pdb</code></a> 且键入尽可能少的代码即可进入调试器。但是， <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.breakpointhook" title="sys.breakpointhook"><code>sys.breakpointhook()</code></a> 可以设置为其他一些函数并被 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#breakpoint" title="breakpoint"><code>breakpoint()</code></a> 自动调用，以允许进入你想用的调试器。如果 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.breakpointhook" title="sys.breakpointhook"><code>sys.breakpointhook()</code></a> 不可访问，这个函数将会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>builtins.breakpoint</code> 并附带参数 <code>breakpointhook</code>。</p>
<p>3.7 新版功能.</p>
<p><em>class</em> <code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</p>
<p>返回一个新的 bytes 数组。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 类是一个可变序列，包含范围为 0 &lt;&#x3D; x &lt; 256 的整数。它有可变序列大部分常见的方法，见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-mutable">可变序列类型</a> 的描述；同时有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类型的大部分方法，参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes-methods">bytes 和 bytearray 操作</a>。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul>
<li><p>如果是一个 <em>string_，您必须提供 <em>encoding</em> 参数（_errors</em> 参数仍是可选的）；<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray()</code></a> 会使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.encode" title="str.encode"><code>str.encode()</code></a> 方法来将 string 转变成 bytes。</p>
</li>
<li><p>如果是一个 _integer_，会初始化大小为该数字的数组，并使用 null 字节填充。</p>
</li>
<li><p>如果是一个遵循 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲区接口</a> 的对象，该对象的只读缓冲区将被用来初始化字节数组。</p>
</li>
<li><p>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code>0 &lt;= x &lt; 256</code> 的整数，它会被用作数组的初始内容。</p>
</li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<p>另见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#binaryseq">二进制序列类型 — bytes, bytearray, memoryview</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typebytearray">bytearray 对象</a>。</p>
<p><em>class</em> <code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</p>
<p>返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 <code>0 &lt;= x &lt; 256</code> 的整数。<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 是 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。</p>
<p>因此，构造函数的实参和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray()</code></a> 相同。</p>
<p>字节对象还可以用字面值创建，参见 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#strings">字符串与字节串字面值</a>。</p>
<p>另见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#binaryseq">二进制序列类型 — bytes, bytearray, memoryview</a>，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typebytes">bytes 对象</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes-methods">bytes 和 bytearray 操作</a>。</p>
<p><code>callable</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#callable" title="永久链接至目标"></a></p>
<p>如果参数 <em>object</em> 是可调用的就返回 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#True" title="True"><code>True</code></a>，否则返回 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#False" title="False"><code>False</code></a>。 如果返回 <code>True</code>，调用仍可能失败，但如果返回 <code>False</code>，则调用 <em>object</em> 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 <code>__call__()</code> 则它就是可调用的。</p>
<p>3.2 新版功能: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
<p><code>chr</code>(<em>i</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#chr" title="永久链接至目标"></a></p>
<p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code>chr(97)</code> 返回字符串 <code>&#39;a&#39;</code>，<code>chr(8364)</code> 返回字符串 <code>&#39;€&#39;</code>。这是 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ord" title="ord"><code>ord()</code></a> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> 异常。</p>
<p><code>@``classmethod</code><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#classmethod" title="永久链接至目标"></a></p>
<p>把一个方法封装成类方法。</p>
<p>类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：</p>
<p>class C:<br>    @classmethod<br>    def f(cls, arg1, arg2): …</p>
<p><code>@classmethod</code> 这样的形式称为函数的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-decorator">decorator</a> – 详情参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a>。</p>
<p>类方法的调用可以在类上进行 (例如 <code>C.f()</code>) 也可以在实例上进行 (例如 <code>C().f()</code>)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。</p>
<p>类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#staticmethod" title="staticmethod"><code>staticmethod()</code></a>。 有关类方法的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#types">标准类型层级结构</a>。</p>
<p>在 3.9 版更改: 类方法现在可以包装其他 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-descriptor">描述器</a> 例如 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#property" title="property"><code>property()</code></a>。</p>
<p>在 3.10 版更改: 类方法现在继承了方法的属性（ <code>__module__</code>、 <code>__name__</code>、 <code>__qualname__</code>、 <code>__doc__</code> 和 <code>__annotations__</code>），并拥有一个新的 <code>__wrapped__</code> 属性。</p>
<p><code>compile</code>(<em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags&#x3D;0</em>, <em>dont_inherit&#x3D;False</em>, <em>optimize&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#compile" title="永久链接至目标"></a></p>
<p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。参见 <a href="https://docs.python.org/zh-cn/3.10/library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code>ast</code></a> 模块的文档了解如何使用 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code>&#39;&lt;string&gt;&#39;</code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code>&#39;exec&#39;</code>；如果是单一表达式，可以是 <code>&#39;eval&#39;</code>；如果是单个交互式语句，可以是 <code>&#39;single&#39;</code>。（在最后一种情况下，如果表达式执行结果不是 <code>None</code> 将会被打印出来。）</p>
<p>可选参数 <em>flags</em> 和 <em>dont_inherit</em> 控制应当激活哪个 <a href="https://docs.python.org/zh-cn/3.10/library/ast.html#ast-compiler-flags">编译器选项</a> 以及应当允许哪个 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#future">future 特性</a>。 如果两者都未提供 (或都为零) 则代码会应用与调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#compile" title="compile"><code>compile()</code></a> 的代码相同的旗标来编译。 如果给出了 <em>flags</em> 参数而未给出 <em>dont_inherit</em> (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 <em>flags</em> 参数所指定的编译器选项和 future 语句。 如果 <em>dont_inherit</em> 为非零整数，则只使用 <em>flags</em> 参数 – 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。</p>
<p>编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 <a href="https://docs.python.org/zh-cn/3.10/library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code>__future__</code></a> 模块的 <code>_Feature</code> 实例的 <code>compiler_flag</code> 属性中找到。 <a href="https://docs.python.org/zh-cn/3.10/library/ast.html#ast-compiler-flags">编译器旗标</a> 可以在 <a href="https://docs.python.org/zh-cn/3.10/library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code>ast</code></a> 模块中查找带有 <code>PyCF_</code> 前缀的名称。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code>-1</code> 选择与解释器的 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-O"><code>-O</code></a> 选项相同的优化级别。显式级别为 <code>0</code> （没有优化；<code>__debug__</code> 为真）、<code>1</code> （断言被删除， <code>__debug__</code> 为假）或 <code>2</code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> 异常；如果源码包含 null 字节，则会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> 异常。</p>
<p>如果您想分析 Python 代码的 AST 表示，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/ast.html#ast.parse" title="ast.parse"><code>ast.parse()</code></a>。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>compile</code> 附带参数 <code>source</code>, <code>filename</code>。</p>
<p>注解</p>
<p> </p>
<p>在 <code>&#39;single&#39;</code> 或 <code>&#39;eval&#39;</code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <a href="https://docs.python.org/zh-cn/3.10/library/code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> 模块更容易检测语句的完整性。</p>
<p>警告</p>
<p> </p>
<p>在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。</p>
<p>在 3.2 版更改: Windows 和 Mac 的换行符均可使用。而且在 <code>&#39;exec&#39;</code> 模式下的输入不必再以换行符结尾了。另增加了 <em>optimize</em> 参数。</p>
<p>在 3.5 版更改: 之前 <em>source</em> 中包含 null 字节的话会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 异常。</p>
<p>3.8 新版功能: <code>ast.PyCF_ALLOW_TOP_LEVEL_AWAIT</code> 现在可在旗标中传入以启用对最高层级 <code>await</code>, <code>async for</code> 和 <code>async with</code> 的支持。</p>
<p><em>class</em> <code>complex</code>([<em>real</em>[, <em>imag</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="永久链接至目标"></a></p>
<p>返回值为 <em>real</em> + <em>imag</em>*1j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 _imag_，则默认值为零，构造函数会像 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 一样进行数值转换。如果两个实参都省略，则返回 <code>0j</code>。</p>
<p>对于一个普通 Python 对象 <code>x</code>，<code>complex(x)</code> 会委托给 <code>x.__complex__()</code>。 如果 <code>__complex__()</code> 未定义则将回退至 <code>__float__()</code>。 如果 <code>__float__()</code> 未定义则将回退至 <code>__index__()</code>。</p>
<p>注解</p>
<p> </p>
<p>当从字符串转换时，字符串在 <code>+</code> 或 <code>-</code> 的周围必须不能有空格。例如 <code>complex(&#39;1+2j&#39;)</code> 是合法的，但 <code>complex(&#39;1 + 2j&#39;)</code> 会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> 异常。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesnumeric">数字类型 — int, float, complex</a> 描述了复数类型。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.8 版更改: 如果 <code>__complex__()</code> 和 <code>__float__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<p><code>delattr</code>(<em>object</em>, <em>name</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#delattr" title="永久链接至目标"></a></p>
<p>这是 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="setattr"><code>setattr()</code></a> 的相关函数。 其参数是一个对象和一个字符串。 其中字符串必须是对象的某个属性的名称。 该函数会删除指定的属性，如果对象允许这样做的话。 例如，<code>delattr(x, &#39;foobar&#39;)</code> 等价于 <code>del x.foobar</code>。 <em>name</em> 不要求必须是 Python 标识符 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="setattr"><code>setattr()</code></a>)。</p>
<p><em>class</em> <code>dict</code>(<em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>mapping</em>, <em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>iterable</em>, <em>**kwarg</em>)</p>
<p>创建一个新的字典。<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 对象是一个字典类。参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesmapping">映射类型 — dict</a> 了解这个类。</p>
<p>其他容器类型，请参见内置的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 类，以及 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> 模块。</p>
<p><code>dir</code>([<em>object</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#dir" title="永久链接至目标"></a></p>
<p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <code>__dir__()</code> 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 <code>__getattr__()</code> 或 <code>__getattribute__()</code> 函数的对象能够自定义 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#dir" title="dir"><code>dir()</code></a> 来报告它们的属性。</p>
<p>如果对象未提供 <code>__dir__()</code> 方法，该函数会尽量从对象的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性和其类型对象中收集信息。得到的列表不一定是完整，如果对象带有自定义 <code>__getattr__()</code> 方法时，结果可能不准确。</p>
<p>默认的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#dir" title="dir"><code>dir()</code></a> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul>
<li><p>如果对象是模块对象，则列表包含模块的属性名称。</p>
</li>
<li><p>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</p>
</li>
<li><p>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</p>
</li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import struct<br>dir()   # show the names in the module namespace<br>[‘<strong>builtins</strong>‘, ‘<strong>name</strong>‘, ‘struct’]<br>dir(struct)   # show the names in the struct module<br>[‘Struct’, ‘<strong>all</strong>‘, ‘<strong>builtins</strong>‘, ‘<strong>cached</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>file</strong>‘,<br> ‘<strong>initializing</strong>‘, ‘<strong>loader</strong>‘, ‘<strong>name</strong>‘, ‘<strong>package</strong>‘,<br> ‘_clearcache’, ‘calcsize’, ‘error’, ‘pack’, ‘pack_into’,<br> ‘unpack’, ‘unpack_from’]<br>class Shape:<br>…     def <strong>dir</strong>(self):<br>…         return [‘area’, ‘perimeter’, ‘location’]<br>s &#x3D; Shape()<br>dir(s)<br>[‘area’, ‘location’, ‘perimeter’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>因为 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#dir" title="dir"><code>dir()</code></a> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
<p><code>divmod</code>(<em>a</em>, <em>b</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#divmod" title="永久链接至目标"></a></p>
<p>以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 <code>(a // b, a % b)</code> 相同。对于浮点数则结果为 <code>(q, a % b)</code>，其中 <em>q</em> 通常为 <code>math.floor(a / b)</code>，但可能比它小 1。在任何情况下， <code>q * b + a % b</code> 都非常接近 _a_，如果 <code>a % b</code> 非零，则结果符号与 <em>b</em> 相同，并且 <code>0 &lt;= abs(a % b) &lt; abs(b)</code>。</p>
<p><code>enumerate</code>(<em>iterable</em>, <em>start&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#enumerate" title="永久链接至目标"></a></p>
<p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a>，或其他支持迭代的对象。 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#enumerate" title="enumerate"><code>enumerate()</code></a> 返回的迭代器的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>seasons &#x3D; [‘Spring’, ‘Summer’, ‘Fall’, ‘Winter’]<br>list(enumerate(seasons))<br>[(0, ‘Spring’), (1, ‘Summer’), (2, ‘Fall’), (3, ‘Winter’)]<br>list(enumerate(seasons, start&#x3D;1))<br>[(1, ‘Spring’), (2, ‘Summer’), (3, ‘Fall’), (4, ‘Winter’)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>等价于:</p>
<p>def enumerate(sequence, start&#x3D;0):<br>    n &#x3D; start<br>    for elem in sequence:<br>        yield n, elem<br>        n +&#x3D; 1</p>
<p><code>eval</code>(<em>expression</em>[, <em>globals</em>[, <em>locals</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="永久链接至目标"></a></p>
<p>实参是一个字符串，以及可选的 globals 和 locals。<em>globals</em> 实参必须是一个字典。<em>locals</em> 可以是任何映射对象。</p>
<p>表达式解析参数 <em>expression</em> 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 <em>globals</em> 和 <em>locals</em> 字典作为全局和局部命名空间。 如果存在 <em>globals</em> 字典，并且不包含 <code>__builtins__</code> 键的值，则在解析 <em>expression</em> 之前会插入以该字符串为键以对内置模块 <a href="https://docs.python.org/zh-cn/3.10/library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code>builtins</code></a> 的字典的引用为值的项。 这样就可以在将 <em>globals</em> 传给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 之前通过向其传入你自己的 <code>__builtins__</code> 字典来控制可供被执行代码可以使用哪些内置模块。 如果 <em>locals</em> 字典被省略则它默认为 <em>globals</em> 字典。 如果两个字典都被省略，则将使用调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 的环境中的 <em>globals</em> 和 <em>locals</em> 来执行该表达式。 注意，<em>eval()</em> 无法访问闭包环境中的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-nested-scope">嵌套作用域</a> (非局部变量)。</p>
<p>返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>x &#x3D; 1<br>eval(‘x+1’)<br>2</p>
</blockquote>
</blockquote>
</blockquote>
<p>该函数还可用于执行任意代码对象（比如由 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#compile" title="compile"><code>compile()</code></a> 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为 <em>mode</em> 的 <code>&#39;exec&#39;</code> 进行了编译，那么 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 的返回值将为 <code>None</code>。</p>
<p>提示： <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 函数支持语句的动态执行。 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#globals" title="globals"><code>globals()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a> 函数分别返回当前的全局和本地字典，可供传给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 使用。</p>
<p>如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。</p>
<p>另外可以参阅 <a href="https://docs.python.org/zh-cn/3.10/library/ast.html#ast.literal_eval" title="ast.literal_eval"><code>ast.literal_eval()</code></a>，该函数可以安全执行仅包含文字的表达式字符串。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>exec</code> 附带参数 <code>code_object</code>。</p>
<p><code>exec</code>(<em>object</em>[, <em>globals</em>[, <em>locals</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="永久链接至目标"></a></p>
<p>这个函数支持动态执行 Python 代码。 <em>object</em> 必须是字符串或者代码对象。 如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#id2">1</a> 如果是代码对象，它将被直接执行。 在任何情况下，被执行的代码都应当是有效的文件输入（见参考手册中的 <a href="https://docs.python.org/zh-cn/3.10/reference/toplevel_components.html#file-input">文件输入</a> 一节）。 请注意即使在传递给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 函数的代码的上下文中，<a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a>, <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#yield"><code>yield</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#return"><code>return</code></a> 语句也不能在函数定义以外使用。 该函数的返回值是 <code>None</code>。</p>
<p>无论在什么情况下，如果省略了可选部分，代码将运行于当前作用域中。如果只提供了 _globals_，则必须为字典对象（而不能是字典的子类），同时用于存放全局变量和局部变量。如果提供了 <em>globals</em> 和 <em>locals_，则将分别用于全局变量和局部变量。_locals</em> 可以是任意字典映射对象。请记住，在模块级别，globals 和 locals 是同一个字典。如果 exec 获得两个独立的对象作为 <em>globals</em> 和 _locals_，代码执行起来就像嵌入到某个类定义中一样。</p>
<p>如果 <em>globals</em> 字典不包含 <code>__builtins__</code> 键值，则将为该键插入对内建 <a href="https://docs.python.org/zh-cn/3.10/library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code>builtins</code></a> 模块字典的引用。因此，在将执行的代码传递给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 之前，可以通过将自己的 <code>__builtins__</code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>exec</code> 附带参数 <code>code_object</code>。</p>
<p>注解</p>
<p> </p>
<p>内置 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#globals" title="globals"><code>globals()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 的第二个和第三个实参。</p>
<p>注解</p>
<p> </p>
<p>默认情况下，<em>locals</em> 的行为如下面 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a> 函数描述的一样：不要试图改变默认的 <em>locals</em> 字典。 如果您需要在 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 函数返回时查看代码对 <em>locals</em> 的影响，请明确地传递 <em>locals</em> 字典。</p>
<p><code>filter</code>(<em>function</em>, <em>iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#filter" title="永久链接至目标"></a></p>
<p>用 <em>iterable</em> 中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 <em>function</em> 是 <code>None</code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p>
<p>请注意， <code>filter(function, iterable)</code> 相当于一个生成器表达式，当 function 不是 <code>None</code> 的时候为 <code>(item for item in iterable if function(item))</code>；function 是 <code>None</code> 的时候为 <code>(item for item in iterable if item)</code> 。</p>
<p>请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.filterfalse" title="itertools.filterfalse"><code>itertools.filterfalse()</code></a> 了解，只有 <em>function</em> 返回 false 时才选取 <em>iterable</em> 中元素的补充函数。</p>
<p><em>class</em> <code>float</code>([<em>x</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="永久链接至目标"></a></p>
<p>返回从数字或字符串 <em>x</em> 生成的浮点数。</p>
<p>如果该参数是一个字符串，则它应当包含一个十进制数字，前面可以选择带一个符号，也可以选择嵌入空格。 可选的符号可以为 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>；<code>&#39;+&#39;</code> 符号对所产生的值没有影响。 该参数还可以是一个代表 NaN (not-a-number) 或正负无穷大的字符串。 更确切地说，在去除前导和尾随的空格之后，输入必须为符合以下语法的 <code>floatvalue</code> 产生规则:</p>
<p>**sign       ** ::&#x3D;  “+” | “-“<br>**infinity   ** ::&#x3D;  “Infinity” | “inf”<br>**nan        ** ::&#x3D;  “nan”<br>*<em>digitpart  ** ::&#x3D;  <code>digit</code> ([“_”] <code>digit</code>)</em><br>**number     ** ::&#x3D;  [<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-digitpart"><code>digitpart</code></a>] “.” <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-digitpart"><code>digitpart</code></a> | <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-digitpart"><code>digitpart</code></a> [“.”]<br>**exponent   ** ::&#x3D;  (“e” | “E”) [“+” | “-“] <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-digitpart"><code>digitpart</code></a><br><strong>floatnumber</strong> ::&#x3D;  number [<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-exponent"><code>exponent</code></a>]<br>**floatvalue ** ::&#x3D;  [<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-sign"><code>sign</code></a>] (<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-floatnumber"><code>floatnumber</code></a> | <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-infinity"><code>infinity</code></a> | <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#grammar-token-float-nan"><code>nan</code></a>)</p>
<p>在这里 <code>digit</code> 是一个 Unicode 十进制数码 (Unicode 主分类为 <code>Nd</code> 的字符)。 对大小写不敏感，因此，举例来说，”inf”, “Inf”, “INFINITY” 和 “iNfINity” 都是正无穷大的可接受拼写。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>。</p>
<p>对于一个普通 Python 对象 <code>x</code>，<code>float(x)</code> 会委托给 <code>x.__float__()</code>。 如果 <code>__float__()</code> 未定义则将回退至 <code>__index__()</code>。</p>
<p>如果没有实参，则返回 <code>0.0</code> 。</p>
<p>示例:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>float(‘+1.23’)<br>1.23<br>float(‘   -12345\n’)<br>-12345.0<br>float(‘1e-003’)<br>0.001<br>float(‘+1E6’)<br>1000000.0<br>float(‘-Infinity’)<br>-inf</p>
</blockquote>
</blockquote>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesnumeric">数字类型 — int, float, complex</a> 描述了浮点类型。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p>在 3.8 版更改: 如果 <code>__float__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<p><code>format</code>(<em>value</em>[, <em>format_spec</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="永久链接至目标"></a></p>
<p>将 <em>value</em> 转换为“格式化后”的形式，格式由 <em>format_spec</em> 进行控制。<em>format_spec</em> 的解释方式取决于 <em>value</em> 参数的类型；但大多数内置类型使用一种标准的格式化语法： <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatspec">格式规格迷你语言</a>。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常给出与调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str(value)</code></a> 相同的结果。</p>
<p>调用 <code>format(value, format_spec)</code> 会转换成 <code>type(value).__format__(value, format_spec)</code> ，所以实例字典中的 <code>__format__()</code> 方法将不会调用。如果方法搜索回退到 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a> 类但 <em>format_spec</em> 不为空，或者如果 <em>format_spec</em> 或返回值不是字符串，则会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 异常。</p>
<p>在 3.4 版更改: 当 <em>format_spec</em> 不是空字符串时， <code>object().__format__(format_spec)</code> 会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。</p>
<p><em>class</em> <code>frozenset</code>([<em>iterable</em>])</p>
<p>返回一个新的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code>frozenset</code> 是一个内置的类。有关此类的文档，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-set">集合类型 — set, frozenset</a>。</p>
<p>请参阅内建的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 类，以及 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> 模块来了解其它的容器。</p>
<p><code>getattr</code>(<em>object</em>, <em>name</em>[, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="永久链接至目标"></a></p>
<p><em>object</em> 中指定名称的属性的值。 <em>name</em> 必须是字符串。 如果该字符串是对象的某一属性的名称，则结果将为该属性的值。 例如，<code>getattr(x, &#39;foobar&#39;)</code> 等同于 <code>x.foobar</code>。 如果指定名称的属性不存在，则如果提供了 <em>default</em> 则返回该值，否则将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a>。 <em>name</em> 不必是一个 Python 标识符 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="setattr"><code>setattr()</code></a>)。</p>
<p>注解</p>
<p> </p>
<p>由于 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#private-name-mangling">私有名称混合</a> 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 来提取它。</p>
<p><code>globals</code>()<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#globals" title="永久链接至目标"></a></p>
<p>返回实现当前模块命名空间的字典。对于函数内的代码，这是在定义函数时设置的，无论函数在哪里被调用都保持不变。</p>
<p><code>hasattr</code>(<em>object</em>, <em>name</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hasattr" title="永久链接至目标"></a></p>
<p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code>True</code>，否则返回 <code>False</code>。（此功能是通过调用 <code>getattr(object, name)</code> 看是否有 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a> 异常来实现的。）</p>
<p><code>hash</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hash" title="永久链接至目标"></a></p>
<p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p>
<p>注解</p>
<p> </p>
<p>如果对象实现了自己的 <code>__hash__()</code> 方法，请注意，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hash" title="hash"><code>hash()</code></a> 根据机器的字长来截断返回值。另请参阅 <code>__hash__()</code>。</p>
<p><code>help</code>([<em>object</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#help" title="永久链接至目标"></a></p>
<p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>请注意，如果在调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#help" title="help"><code>help()</code></a> 时，目标函数的形参列表中存在斜杠（&#x2F;），则意味着斜杠之前的参数只能是位置参数。详情请参阅 <a href="https://docs.python.org/zh-cn/3.10/faq/programming.html#faq-positional-only-arguments">有关仅限位置形参的 FAQ 条目</a>。</p>
<p>该函数通过 <a href="https://docs.python.org/zh-cn/3.10/library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> 模块加入到内置命名空间。</p>
<p>在 3.4 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code>pydoc</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code>inspect</code></a> 的变更使得可调用对象的签名信息更加全面和一致。</p>
<p><code>hex</code>(<em>x</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hex" title="永久链接至目标"></a></p>
<p>将整数转换为以“0x”为前缀的小写十六进制字符串。如果 <em>x</em> 不是 Python <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 对象，则必须定义返回整数的 <code>__index__()</code> 方法。一些例子：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>hex(255)<br>‘0xff’<br>hex(-42)<br>‘-0x2a’</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘%#x’ % 255, ‘%x’ % 255, ‘%X’ % 255<br>(‘0xff’, ‘ff’, ‘FF’)<br>format(255, ‘#x’), format(255, ‘x’), format(255, ‘X’)<br>(‘0xff’, ‘ff’, ‘FF’)<br>f’{255:#x}’, f’{255:x}’, f’{255:X}’<br>(‘0xff’, ‘ff’, ‘FF’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>另见 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a> 获取更多信息。</p>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int()</code></a> 将十六进制字符串转换为以 16 为基数的整数。</p>
<p>注解</p>
<p> </p>
<p>如果要获取浮点数的十六进制字符串形式，请使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.hex" title="float.hex"><code>float.hex()</code></a> 方法。</p>
<p><code>id</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#id" title="永久链接至目标"></a></p>
<p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#id" title="id"><code>id()</code></a> 值。</p>
<p><strong>CPython 实现细节：</strong> 这是对象在内在中的地址。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>builtins.id</code>，附带参数 <code>id</code>。</p>
<p><code>input</code>([<em>prompt</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#input" title="永久链接至目标"></a></p>
<p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#EOFError" title="EOFError"><code>EOFError</code></a>。例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>s &#x3D; input(‘–&gt; ‘)<br>–&gt; Monty Python’s Flying Circus<br>s<br>“Monty Python’s Flying Circus”</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果加载了 <a href="https://docs.python.org/zh-cn/3.10/library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code>readline</code></a> 模块，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#input" title="input"><code>input()</code></a> 将使用它来提供复杂的行编辑和历史记录功能。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>builtins.input</code> 附带参数 <code>prompt</code>。</p>
<p>在成功读取输入之后引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>builtins.input/result</code> 附带结果。</p>
<p><em>class</em> <code>int</code>([<em>x</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="永久链接至目标"></a></p>
<p><em>class</em> <code>int</code>(<em>x</em>, <em>base&#x3D;10</em>)</p>
<p>返回一个基于数字或字符串 <em>x</em> 构造的整数对象，或者在未给出参数时返回 <code>0</code>。 如果 <em>x</em> 定义了 <code>__int__()</code>，<code>int(x)</code> 将返回 <code>x.__int__()</code>。 如果 <em>x</em> 定义了 <code>__index__()</code>，它将返回 <code>x.__index__()</code>。 如果 <em>x</em> 定义了 <code>__trunc__()</code>，它将返回 <code>x.__trunc__()</code>。 对于浮点数，它将向零舍入。</p>
<p>如果 <em>x</em> 不是一个数字或者如果给定了 _base_，则 <em>x</em> 必须是一个表示以 <em>base</em> 为基数的整数的字符串、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 实例。 字符串前面还能加上可选的 <code>+</code> 或 <code>-</code> (中间没有空格)，带有前导的零，带有两侧的空格，并可带有数位之间的单个下划线。</p>
<p>一个以 n 为基数的整数字符串包含多个数位，每个数位代表从 0 到 n-1 范围内的值。 0–9 的值可以用任何 Unicode 十进制数码来表示。 10–35 的值可以用 <code>a</code> 到 <code>z</code> (或 <code>A</code> 到 <code>Z</code>) 来表示。 默认的 <em>base</em> 为 10。 允许的基数为 0 和 2–36。 对于基数 2, -8 和 -16 来说字符串前面还能加上可选的 <code>0b</code>&#x2F;<code>0B</code>, <code>0o</code>&#x2F;<code>0O</code> 或 <code>0x</code>&#x2F;<code>0X</code> 前缀，就像代码中的整数字面值那样。 对于基数 0 来说，字符串会以与 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#integers">代码中的整数字面值</a> 类似的方式来解读，即实际的基数将由前缀确定为 2, 8, 10 或 16。 基数为 0 还会禁用前导的零: <code>int(&#39;010&#39;, 0)</code> 将是无效的，而 <code>int(&#39;010&#39;)</code> 和 <code>int(&#39;010&#39;, 8)</code> 则是有效的。</p>
<p>整数类型定义请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesnumeric">数字类型 — int, float, complex</a> 。</p>
<p>在 3.4 版更改: 如果 <em>base</em> 不是 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 的实例，但 <em>base</em> 对象有 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__index__" title="object.__index__"><code>base.__index__</code></a> 方法，则会调用该方法来获取进制数。以前的版本使用 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__int__" title="object.__int__"><code>base.__int__</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__index__" title="object.__index__"><code>base.__index__</code></a>。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p>在 3.8 版更改: 如果 <code>__int__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<p>在 3.10.7 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 字符串输入和字符串表示形式可受到限制以帮助避免拒绝服务攻击。 当将一个字符串 <em>x</em> 转换为 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 或者当将一个 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 转换为字符串的操作超出限制则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int-max-str-digits">整数字符串转换长度限制</a> 文档。</p>
<p><code>isinstance</code>(<em>object</em>, <em>classinfo</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="永久链接至目标"></a></p>
<p>如果 <em>object</em> 参数是 <em>classinfo</em> 参数的实例，或其（直接、间接或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-abstract-base-class">virtual</a> ）子类的实例，则返回 <code>True</code>。 如果 <em>object</em> 不是给定类型的对象，则总是返回 <code>False</code>。如果 <em>classinfo</em> 是类型对象的元组（或由该类元组递归生成）或多个类型的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-union">union 类型</a>，那么当 <em>object</em> 是其中任一类型的实例时就会返回 <code>True</code>。如果 <em>classinfo</em> 不是某个类型或类型元组，将会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 异常。</p>
<p>在 3.10 版更改: <em>classinfo</em> 可以是一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-union">union 类型</a>。</p>
<p><code>issubclass</code>(<em>class</em>, <em>classinfo</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#issubclass" title="永久链接至目标"></a></p>
<p>如果 <em>class</em> 是 <em>classinfo</em> 的子类（直接、间接或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-abstract-base-class">虚的</a> ），则返回 <code>True</code>。类将视为自己的子类。<em>classinfo</em> 可为类对象的元组（或递归地，其他这样的元组）或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-union">union 类型</a>，这时如果 <em>class</em> 是 <em>classinfo</em> 中任何条目的子类，则返回 <code>True</code> 。任何其他情况都会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 异常。</p>
<p>在 3.10 版更改: <em>classinfo</em> 可以是一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-union">union 类型</a>。</p>
<p><code>iter</code>(<em>object</em>[, <em>sentinel</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="永久链接至目标"></a></p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，<em>object</em> 必须是支持 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a> 协议（有 <code>__iter__()</code> 方法）的集合对象，或必须支持序列协议（有 <code>__getitem__()</code> 方法，且数字参数从 <code>0</code> 开始）。如果它不支持这些协议，会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。如果有第二个实参 _sentinel_，那么 <em>object</em> 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法时都会不带实参地调用 _object_；如果返回的结果是 <em>sentinel</em> 则触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>，否则返回调用结果。</p>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typeiter">迭代器类型</a>。</p>
<p>适合 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="iter"><code>iter()</code></a> 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<p>from functools import partial<br>with open(‘mydata.db’, ‘rb’) as f:<br>    for block in iter(partial(f.read, 64), b’’):<br>        process_block(block)</p>
<p><code>len</code>(<em>s</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#len" title="永久链接至目标"></a></p>
<p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
<p><strong>CPython 实现细节：</strong> <code>len</code> 对于大于 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.maxsize" title="sys.maxsize"><code>sys.maxsize</code></a> 的长度如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="range"><code>range(2 ** 100)</code></a> 会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>。</p>
<p><em>class</em> <code>list</code>([<em>iterable</em>])</p>
<p>虽然被称为函数，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 实际上是一种可变序列类型，详情请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-list">列表</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq">序列类型 — list, tuple, range</a>。</p>
<p><code>locals</code>()<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="永久链接至目标"></a></p>
<p>更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a> 时将返回自由变量。 请注意在模块层级上，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#globals" title="globals"><code>globals()</code></a> 是同一个字典。</p>
<p>注解</p>
<p> </p>
<p>不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。</p>
<p><code>map</code>(<em>function</em>, <em>iterable</em>, <em>…</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#map" title="永久链接至目标"></a></p>
<p>返回一个将 <em>function</em> 应用于 <em>iterable</em> 中每一项并输出其结果的迭代器。 如果传入了额外的 <em>iterable</em> 参数，<em>function</em> 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参数元组的情况，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.starmap" title="itertools.starmap"><code>itertools.starmap()</code></a>。</p>
<p><code>max</code>(<em>iterable</em>, <em>*</em>[, <em>key</em>, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#max" title="永久链接至目标"></a></p>
<p><code>max</code>(<em>arg1</em>, <em>arg2</em>, <em>*args</em>[, <em>key</em>])</p>
<p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个位置参数，它必须是非空 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a>，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc, reverse=True)[0]</code> 和 <code>heapq.nlargest(1, iterable, key=keyfunc)</code> 保持一致。</p>
<p>3.4 新版功能: keyword-only 实参 <em>default</em> 。</p>
<p>在 3.8 版更改: <em>key</em> 可以为 <code>None</code>。</p>
<p><em>class</em> <code>memoryview</code>(<em>object</em>)</p>
<p>返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typememoryview">内存视图</a>。</p>
<p><code>min</code>(<em>iterable</em>, <em>*</em>[, <em>key</em>, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#min" title="永久链接至目标"></a></p>
<p><code>min</code>(<em>arg1</em>, <em>arg2</em>, <em>*args</em>[, <em>key</em>])</p>
<p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个位置参数，它必须是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a>，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc)[0]</code> 和 <code>heapq.nsmallest(1, iterable, key=keyfunc)</code> 保持一致。</p>
<p>3.4 新版功能: keyword-only 实参 <em>default</em> 。</p>
<p>在 3.8 版更改: <em>key</em> 可以为 <code>None</code>。</p>
<p><code>next</code>(<em>iterator</em>[, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#next" title="永久链接至目标"></a></p>
<p>通过调用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 _default_，如果没有默认值则触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>。</p>
<p><em>class</em> <code>object</code><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="永久链接至目标"></a></p>
<p>返回一个不带特征的新对象。<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a> 是所有类的基类。它带有所有 Python 类实例均通用的方法。本函数不接受任何参数。</p>
<p>注解</p>
<p> </p>
<p>由于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a> 没有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a>，因此无法将任意属性赋给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a> 的实例。</p>
<p><code>oct</code>(<em>x</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#oct" title="永久链接至目标"></a></p>
<p>将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 对象，那它需要定义 <code>__index__()</code> 方法返回一个整数。一些例子：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>oct(8)<br>‘0o10’<br>oct(-56)<br>‘-0o70’</p>
</blockquote>
</blockquote>
</blockquote>
<p>若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘%#o’ % 10, ‘%o’ % 10<br>(‘0o12’, ‘12’)<br>format(10, ‘#o’), format(10, ‘o’)<br>(‘0o12’, ‘12’)<br>f’{10:#o}’, f’{10:o}’<br>(‘0o12’, ‘12’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>另见 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#format" title="format"><code>format()</code></a> 获取更多信息。</p>
<p><code>open</code>(<em>file</em>, <em>mode&#x3D;’r’</em>, <em>buffering&#x3D;- 1</em>, <em>encoding&#x3D;None</em>, <em>errors&#x3D;None</em>, <em>newline&#x3D;None</em>, <em>closefd&#x3D;True</em>, <em>opener&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="永久链接至目标"></a></p>
<p>打开 <em>file</em> 并返回对应的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">file object</a>。 如果该文件不能被打开，则引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a>。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/tutorial/inputoutput.html#tut-files">读写文件</a> 获取此函数的更多用法示例。</p>
<p><em>file</em> 是一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-like-object">path-like object</a>，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的 I&#x2F;O 对象关闭时它也会关闭，除非将 <em>closefd</em> 设为 <code>False</code> 。）</p>
<p><em>mode</em> 是可选的字符串，用于指定打开文件的模式。默认值是 <code>&#39;r&#39;</code> ，表示以文本模式打开并读取文件。其他常见模式有：写入模式 <code>&#39;w&#39;</code> （已存在文件会被清空）、独占创建模式 <code>&#39;x&#39;</code> 、追加写入模式 <code>&#39;a&#39;</code> （在 <em>某些</em> Unix 系统中，无论当前文件指针在什么位置，<em>所有</em> 的写入操作都会追加到文件末尾）。在文本模式，如果未指定 <em>encoding</em> ，则会根据当前平台决定编码格式：调用 <code>locale.getpreferredencoding(False)</code> 获取当前地区的编码。若要读写原生字节格式，请使用二进制模式且不要指定 _encoding_。可用的模式有：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;r&#39;</code></td>
<td>读取（默认）</td>
</tr>
<tr>
<td><code>&#39;w&#39;</code></td>
<td>写入，并先截断文件</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>排它性创建，如果文件已存在则失败</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>打开文件用于写入，如果文件存在则在末尾追加</td>
</tr>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>二进制模式</td>
</tr>
<tr>
<td><code>&#39;t&#39;</code></td>
<td>文本模式（默认）</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>打开用于更新（读取与写入）</td>
</tr>
</tbody></table>
<p>默认模式为 <code>&#39;r&#39;</code> （打开文件用于读取文本，与 <code>&#39;rt&#39;</code> 同义）。<code>&#39;w+&#39;</code> 和 <code>&#39;w+b&#39;</code> 模式将打开文件并清空内容。而 <code>&#39;r+&#39;</code> 和 <code>&#39;r+b&#39;</code> 模式将打开文件但不清空内容。</p>
<p>正如在 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io-overview">概述</a> 中提到的，Python区分二进制和文本I&#x2F;O。以二进制模式打开的文件（包括 <em>mode</em> 参数中的 <code>&#39;b&#39;</code> ）返回的内容为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，不进行任何解码。在文本模式下（默认情况下，或者在 <em>mode</em> 参数中包含 <code>&#39;t&#39;</code> ）时，文件内容返回为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> ，首先使用指定的 <em>encoding</em> （如果给定）或者使用平台默认的的字节编码解码。</p>
<p>另外还有一种模式字符 <code>&#39;U&#39;</code> 可用，不过它已失效，并视作弃用。以前它会在文本模式中启用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-universal-newlines">universal newlines</a>，这在 Python 3.0 已成为默认行为。详情请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open-newline-parameter">newline</a> 形参的文档。</p>
<p>注解</p>
<p> </p>
<p>Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。</p>
<p><em>buffering</em> 是一个可选的整数，用于设置缓冲策略。 传入 0 来关闭缓冲（只允许在二进制模式下），传入 1 来选择行缓冲（只在文本模式下可用），传入一个整数 &gt; 1 来表示固定大小的块缓冲区的字节大小。注意，这样指定缓冲区的大小适用于二进制缓冲的 I&#x2F;O ，但 <code>TextIOWrapper</code> （即用 <code>mode=&#39;r+&#39;</code> 打开的文件）会有另一种缓冲。要禁用在 <code>TextIOWrapper</code> 缓冲，考虑使用 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.TextIOWrapper.reconfigure" title="io.TextIOWrapper.reconfigure"><code>io.TextIOWrapper.reconfigure()</code></a> 的 <code>write_through</code> 标志来。当没有给出 <em>buffering</em> 参数时，默认的缓冲策略工作如下。</p>
<ul>
<li><p>二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.DEFAULT_BUFFER_SIZE" title="io.DEFAULT_BUFFER_SIZE"><code>io.DEFAULT_BUFFER_SIZE</code></a>。在许多系统上，缓冲区的长度通常为4096或8192字节。</p>
</li>
<li><p>“交互式”文本文件（ <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.IOBase.isatty" title="io.IOBase.isatty"><code>isatty()</code></a> 返回 <code>True</code> 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</p>
</li>
</ul>
<p><em>encoding</em> 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。默认编码是依赖于平台的（不 管 <a href="https://docs.python.org/zh-cn/3.10/library/locale.html#locale.getpreferredencoding" title="locale.getpreferredencoding"><code>locale.getpreferredencoding()</code></a> 返回何值），但可以使用任何Python支持的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-text-encoding">text encoding</a> 。有关支持的编码列表，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code>codecs</code></a> 模块。</p>
<p><em>errors</em> 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#error-handlers">错误处理方案</a> ），但是使用 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#codecs.register_error" title="codecs.register_error"><code>codecs.register_error()</code></a> 注册的任何错误处理名称也是有效的。标准名称包括:</p>
<ul>
<li><p>如果存在编码错误，<code>&#39;strict&#39;</code> 会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> 异常。 默认值 <code>None</code> 具有相同的效果。</p>
</li>
<li><p><code>&#39;ignore&#39;</code> 忽略错误。请注意，忽略编码错误可能会导致数据丢失。</p>
</li>
<li><p><code>&#39;replace&#39;</code> 会将替换标记（例如 <code>&#39;?&#39;</code> ）插入有错误数据的地方。</p>
</li>
<li><p><code>&#39;surrogateescape&#39;</code> 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 <code>surrogateescape</code> 错误处理句柄时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。</p>
</li>
<li><p>只有在写入文件时才支持 <code>&#39;xmlcharrefreplace&#39;</code>。编码不支持的字符将替换为相应的XML字符引用 <code>&amp;#nnn;</code>。</p>
</li>
<li><p><code>&#39;backslashreplace&#39;</code> 用Python的反向转义序列替换格式错误的数据。</p>
</li>
<li><p><code>&#39;namereplace&#39;</code> （也只在编写时支持）用 <code>\N&#123;...&#125;</code> 转义序列替换不支持的字符。</p>
</li>
</ul>
<p><em>newline</em> 决定如何解析来自流的换行符。 它可以为 <code>None</code>, <code>&#39;&#39;</code>, <code>&#39;\n&#39;</code>, <code>&#39;\r&#39;</code> 和 <code>&#39;\r\n&#39;</code>。 它的工作原理如下:</p>
<ul>
<li><p>从流中读取输入时，如果 <em>newline</em> 为 <code>None</code>，则启用通用换行模式。输入中的行可以以 <code>&#39;\n&#39;</code>，<code>&#39;\r&#39;</code> 或 <code>&#39;\r\n&#39;</code> 结尾，这些行被翻译成 <code>&#39;\n&#39;</code> 在返回呼叫者之前。如果它是 <code>&#39;&#39;</code>，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。</p>
</li>
<li><p>将输出写入流时，如果 <em>newline</em> 为 <code>None</code>，则写入的任何 <code>&#39;\n&#39;</code> 字符都将转换为系统默认行分隔符 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.linesep" title="os.linesep"><code>os.linesep</code></a>。如果 <em>newline</em> 是 <code>&#39;&#39;</code> 或 <code>&#39;\n&#39;</code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code>&#39;\n&#39;</code> 字符将被转换为给定的字符串。</p>
</li>
</ul>
<p>如果 <em>closefd</em> 为 <code>False</code> 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 <em>closefd</em> 必须为 <code>True</code> （默认值），否则将触发错误。</p>
<p>可以通过传递可调用的 <em>opener</em> 来使用自定义开启器。然后通过使用参数（ <em>file_，_flags</em> ）调用 <em>opener</em> 获得文件对象的基础文件描述符。 <em>opener</em> 必须返回一个打开的文件描述符（使用 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.open" title="os.open"><code>os.open</code></a> as <em>opener</em> 时与传递 <code>None</code> 的效果相同）。</p>
<p>新创建的文件是 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#fd-inheritance">不可继承的</a>。</p>
<p>下面的示例使用 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.open" title="os.open"><code>os.open()</code></a> 函数的 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#dir-fd">dir_fd</a> 的形参，从给定的目录中用相对路径打开文件:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>dir_fd &#x3D; os.open(‘somedir’, os.O_RDONLY)<br>def opener(path, flags):<br>…     return os.open(path, flags, dir_fd&#x3D;dir_fd)<br>…<br>with open(‘spamspam.txt’, ‘w’, opener&#x3D;opener) as f:<br>…     print(‘This will be written to somedir&#x2F;spamspam.txt’, file&#x3D;f)<br>…<br>os.close(dir_fd)  # don’t leak a file descriptor</p>
</blockquote>
</blockquote>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a> 函数所返回的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">file object</a> 类型取决于所用模式。 当使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a> 以文本模式 (<code>&#39;w&#39;</code>, <code>&#39;r&#39;</code>, <code>&#39;wt&#39;</code>, <code>&#39;rt&#39;</code> 等) 打开文件时，它将返回 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.TextIOBase" title="io.TextIOBase"><code>io.TextIOBase</code></a> (具体为 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code>io.TextIOWrapper</code></a>) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code>io.BufferedIOBase</code></a> 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.BufferedReader" title="io.BufferedReader"><code>io.BufferedReader</code></a>；在写入二进制和追加二进制模式下，它将返回 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.BufferedWriter" title="io.BufferedWriter"><code>io.BufferedWriter</code></a>，而在读&#x2F;写模式下，它将返回 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.BufferedRandom" title="io.BufferedRandom"><code>io.BufferedRandom</code></a>。 当禁用缓冲时，则会返回原始流，即 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.RawIOBase" title="io.RawIOBase"><code>io.RawIOBase</code></a> 的一个子类 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.FileIO" title="io.FileIO"><code>io.FileIO</code></a>。</p>
<p>另请参阅文件操作模块，如 <a href="https://docs.python.org/zh-cn/3.10/library/fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code>fileinput</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/io.html#module-io" title="io: Core tools for working with streams."><code>io</code></a> （声明了 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a>）、<a href="https://docs.python.org/zh-cn/3.10/library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code>os</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/os.path.html#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/tempfile.html#module-tempfile" title="tempfile: Generate temporary files and directories."><code>tempfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code>shutil</code></a>。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>open</code> 附带参数 <code>file</code>, <code>mode</code>, <code>flags</code>。</p>
<p><code>mode</code> 与 <code>flags</code> 参数可以在原始调用的基础上被修改或传递。</p>
<blockquote>
<p>在 3.3 版更改:</p>
<ul>
<li><p>增加了 <em>opener</em> 形参。</p>
</li>
<li><p>增加了 <code>&#39;x&#39;</code> 模式。</p>
</li>
<li><p>过去触发的 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IOError" title="IOError"><code>IOError</code></a>，现在是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 的别名。</p>
</li>
<li><p>如果文件已存在但使用了排它性创建模式（ <code>&#39;x&#39;</code> ），现在会触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a>。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>在 3.4 版更改:</p>
<ul>
<li>文件现在禁止继承。</li>
</ul>
</blockquote>
<p>从 3.4 版起不建议使用，已在 3.10 版中移除: <code>&#39;U&#39;</code> 模式。</p>
<blockquote>
<p>在 3.5 版更改:</p>
<ul>
<li><p>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#InterruptedError" title="InterruptedError"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>)。</p>
</li>
<li><p>增加了 <code>&#39;namereplace&#39;</code> 错误处理接口。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>在 3.6 版更改:</p>
<ul>
<li><p>增加对实现了 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> 对象的支持。</p>
</li>
<li><p>在 Windows 上，打开一个控制台缓冲区将返回 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.RawIOBase" title="io.RawIOBase"><code>io.RawIOBase</code></a> 的子类，而不是 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.FileIO" title="io.FileIO"><code>io.FileIO</code></a>。</p>
</li>
</ul>
</blockquote>
<p><code>ord</code>(<em>c</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ord" title="永久链接至目标"></a></p>
<p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code>ord(&#39;a&#39;)</code> 返回整数 <code>97</code>， <code>ord(&#39;€&#39;)</code> （欧元符号）返回 <code>8364</code> 。这是 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#chr" title="chr"><code>chr()</code></a> 的逆函数。</p>
<p><code>pow</code>(<em>base</em>, <em>exp</em>[, <em>mod</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#pow" title="永久链接至目标"></a></p>
<p>返回 <em>base</em> 的 <em>exp</em> 次幂；如果 <em>mod</em> 存在，则返回 <em>base</em> 的 <em>exp</em> 次幂对 <em>mod</em> 取余（比 <code>pow(base, exp) % mod</code> 更高效）。 两参数形式 <code>pow(base, exp)</code> 等价于乘方运算符: <code>base**exp</code>。</p>
<p>参数必须为数值类型。 对于混用的操作数类型，则适用二元算术运算符的类型强制转换规则。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 操作数，结果具有与操作数相同的类型（转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。 例如，<code>pow(10, 2)</code> 返回 <code>100</code>，但 <code>pow(10, -2)</code> 返回 <code>0.01</code>。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 类型的负基和一个非整数的指数，会产生一个复杂的结果。 例如， <code>pow(-9, 0.5)</code> 返回一个接近于 <code>3j</code> 的值。</p>
<p>对于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 操作数 <em>base</em> 和 _exp_，如果给出 _mod_，则 <em>mod</em> 必须为整数类型并且 <em>mod</em> 必须不为零。 如果给出 <em>mod</em> 并且 <em>exp</em> 为负值，则 <em>base</em> 必须相对于 <em>mod</em> 不可整除。 在这种情况下，将会返回 <code>pow(inv_base, -exp, mod)</code>，其中 <em>inv_base</em> 为 <em>base</em> 的倒数对 <em>mod</em> 取余。</p>
<p>下面的例子是 <code>38</code> 的倒数对 <code>97</code> 取余:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>pow(38, -1, mod&#x3D;97)<br>23<br>23 * 38 % 97 &#x3D;&#x3D; 1<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.8 版更改: 对于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 操作数，三参数形式的 <code>pow</code> 现在允许第二个参数为负值，即可以计算倒数的余数。</p>
<p>在 3.8 版更改: 允许关键字参数。 之前只支持位置参数。</p>
<p><code>print</code>(<em>*objects</em>, <em>sep&#x3D;’ ‘</em>, <em>end&#x3D;’\n’</em>, <em>file&#x3D;None</em>, <em>flush&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#print" title="永久链接至目标"></a></p>
<p>将 <em>objects</em> 打印输出至 <em>file</em> 指定的文本流，以 <em>sep</em> 分隔并在末尾加上 _end_。 <em>sep</em> 、 <em>end</em> 、 <em>file</em> 和 <em>flush</em> 必须以关键字参数的形式给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 一样，并会被写入到流，以 <em>sep</em> 分隔并在末尾加上 _end_。 <em>sep</em> 和 <em>end</em> 都必须为字符串；它们也可以为 <code>None</code>，这意味着使用默认值。 如果没有给出 _objects_，则 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#print" title="print"><code>print()</code></a> 将只写入 _end_。</p>
<p><em>file</em> 参数必须是一个具有 <code>write(string)</code> 方法的对象；如果参数不存在或为 <code>None</code>，则将使用 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.stdout" title="sys.stdout"><code>sys.stdout</code></a>。 由于要打印的参数会被转换为文本字符串，因此 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#print" title="print"><code>print()</code></a> 不能用于二进制模式的文件对象。 对于这些对象，应改用 <code>file.write(...)</code>。</p>
<p>输出缓冲通常由 <em>file</em> 确定。 但是，如果 <em>flush</em> 为真值，流将被强制刷新。</p>
<p>在 3.3 版更改: 增加了 <em>flush</em> 关键字参数。</p>
<p><em>class</em> <code>property</code>(<em>fget&#x3D;None</em>, <em>fset&#x3D;None</em>, <em>fdel&#x3D;None</em>, <em>doc&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#property" title="永久链接至目标"></a></p>
<p>返回 property 属性。</p>
<p><em>fget</em> 是获取属性值的函数。 <em>fset</em> 是用于设置属性值的函数。 <em>fdel</em> 是用于删除属性值的函数。并且 <em>doc</em> 为属性对象创建文档字符串。</p>
<p>一个典型的用法是定义一个托管属性 <code>x</code>:</p>
<p>class C:<br>    def <strong>init</strong>(self):<br>        self._x &#x3D; None</p>
<pre><code>def getx(self):
    return self._x

def setx(self, value):
    self._x = value

def delx(self):
    del self._x

x = property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)
</code></pre>
<p>如果 <em>c</em> 为 <em>C</em> 的实例，<code>c.x</code> 将调用 getter，<code>c.x = value</code> 将调用 setter， <code>del c.x</code> 将调用 deleter。</p>
<p>如果给出，<em>doc</em> 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 <em>fget</em> 的文档字符串（如果存在）。 这令使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#property" title="property"><code>property()</code></a> 作为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-decorator">decorator</a> 来创建只读的特征属性可以很容易地实现:</p>
<p>class Parrot:<br>    def <strong>init</strong>(self):<br>        self._voltage &#x3D; 100000</p>
<pre><code>@property
def voltage(self):
    &quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;
    return self._voltage
</code></pre>
<p>以上 <code>@property</code> 装饰器会将 <code>voltage()</code> 方法转化为一个具有相同名称的只读属性的 “getter”，并将 <em>voltage</em> 的文档字符串设置为 “Get the current voltage.”</p>
<p>特征属性对象具有 <code>getter</code>, <code>setter</code> 以及 <code>deleter</code> 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来解释:</p>
<p>class C:<br>    def <strong>init</strong>(self):<br>        self._x &#x3D; None</p>
<pre><code>@property
def x(self):
    &quot;&quot;&quot;I&#39;m the &#39;x&#39; property.&quot;&quot;&quot;
    return self._x

@x.setter
def x(self, value):
    self._x = value

@x.deleter
def x(self):
    del self._x
</code></pre>
<p>上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 <code>x</code>。)</p>
<p>返回的特征属性对象同样具有与构造器参数相对应的属性 <code>fget</code>, <code>fset</code> 和 <code>fdel</code>。</p>
<p>在 3.5 版更改: 特征属性对象的文档字符串现在是可写的。</p>
<p><em>class</em> <code>range</code>(<em>stop</em>)</p>
<p><em>class</em> <code>range</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>虽然被称为函数，但 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="range"><code>range</code></a> 实际上是一个不可变的序列类型，参见在 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-range">range 对象</a> 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq">序列类型 — list, tuple, range</a> 中的文档说明。</p>
<p><code>repr</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="永久链接至目标"></a></p>
<p>返回包含一个对象的可打印表示形式的字符串。 对于许多类型而言，此函数将会尝试返回一个具有与传给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 时相同的值的字符串；在其他情况下，其表示形式将为一个包含对象类型名称和通常包括对象名称和地址的额外信息的用尖括号括起来的字符串。 一个类可以通过定义 <code>__repr__()</code> 方法来控制此函数为其实例所返回的内容。 如果 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.displayhook" title="sys.displayhook"><code>sys.displayhook()</code></a> 不可访问，则此函数将会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>。</p>
<p><code>reversed</code>(<em>seq</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#reversed" title="永久链接至目标"></a></p>
<p>返回一个反向的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a>。 <em>seq</em> 必须是一个具有 <code>__reversed__()</code> 方法的对象或者是支持该序列协议（具有从 <code>0</code> 开始的整数类型参数的 <code>__len__()</code> 方法和 <code>__getitem__()</code> 方法）。</p>
<p><code>round</code>(<em>number</em>[, <em>ndigits</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#round" title="永久链接至目标"></a></p>
<p>返回 <em>number</em> 舍入到小数点后 <em>ndigits</em> 位精度的值。 如果 <em>ndigits</em> 被省略或为 <code>None</code>，则返回最接近输入值的整数。</p>
<p>对于支持 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#round" title="round"><code>round()</code></a> 方法的内置类型，结果值会舍入至最接近的 10 的负 <em>ndigits</em> 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，<code>round(0.5)</code> 和 <code>round(-0.5)</code> 均得出 <code>0</code> 而 <code>round(1.5)</code> 则为 <code>2</code>。<em>ndigits</em> 可为任意整数值（正数、零或负数）。如果省略了 <em>ndigits</em> 或为 <code>None</code> ，则返回值将为整数。否则返回值与 <em>number</em> 的类型相同。</p>
<p>对于一般的 Python 对象 <code>number</code>, <code>round</code> 将委托给 <code>number.__round__</code>。</p>
<p>注解</p>
<p> </p>
<p>对浮点数执行 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#round" title="round"><code>round()</code></a> 的行为可能会令人惊讶：例如，<code>round(2.675, 2)</code> 将给出 <code>2.67</code> 而不是期望的 <code>2.68</code>。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/tutorial/floatingpoint.html#tut-fp-issues">浮点算术：争议和限制</a> 了解更多信息。</p>
<p><em>class</em> <code>set</code>([<em>iterable</em>])</p>
<p>返回一个新的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 对象，可以选择带有从 <em>iterable</em> 获取的元素。 <code>set</code> 是一个内置类型。 请查看 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-set">集合类型 — set, frozenset</a> 获取关于这个类的文档。</p>
<p>有关其他容器请参看内置的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 类，以及 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> 模块。</p>
<p><code>setattr</code>(<em>object</em>, <em>name</em>, <em>value</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="永久链接至目标"></a></p>
<p>本函数与 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 <code>setattr(x, &#39;foobar&#39;, 123)</code> 等价于 <code>x.foobar = 123</code>。</p>
<p><em>name</em> 无需为在 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#identifiers">标识符和关键字</a> 中定义的 Python 标识符除非对象选择强制这样做，例如在一个自定义的 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code>__getattribute__()</code></a> 中或是通过 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__slots__" title="object.__slots__"><code>__slots__</code></a>。 一个名称不为标识符的属性将不可使用点号标记来访问，但是可以通过 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 等来访问。</p>
<p>注解</p>
<p> </p>
<p>由于 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#private-name-mangling">私有名称混合</a> 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="setattr"><code>setattr()</code></a> 来设置它。</p>
<p><em>class</em> <code>slice</code>(<em>stop</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#slice" title="永久链接至目标"></a></p>
<p><em>class</em> <code>slice</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-slice">slice</a> 对象，代表由 <code>range(start, stop, step)</code> 指定索引集的切片。 其中参数 <em>start</em> 和 <em>step</em> 的默认值为 <code>None</code>。切片对象具有只读数据属性 <code>start</code> 、<code>stop</code> 和 <code>step</code>，只是返回对应的参数值（或默认值）。这几个属性没有其他明确的功能；不过 NumPy 和其他第三方扩展会用到。在使用扩展索引语法时，也会生成切片对象。例如： <code>a[start:stop:step]</code> 或 <code>a[start:stop, i]</code>。 另一种方案是返回迭代器对象，可参阅 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.islice" title="itertools.islice"><code>itertools.islice()</code></a> 。</p>
<p><code>sorted</code>(<em>iterable</em>, <em>&#x2F;</em>, <em>*</em>, <em>key&#x3D;None</em>, <em>reverse&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted" title="永久链接至目标"></a></p>
<p>根据 <em>iterable</em> 中的项返回一个新的已排序列表。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的函数，用于从 <em>iterable</em> 的每个元素中提取用于比较的键 (例如 <code>key=str.lower</code>)。 默认值为 <code>None</code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code>functools.cmp_to_key()</code></a> 可将老式的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p>内置的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted" title="sorted"><code>sorted()</code></a> 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<p>排序算法只使用 <code>&lt;</code> 在项目之间比较。 虽然定义一个 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__lt__" title="object.__lt__"><code>__lt__()</code></a> 方法就足以进行排序，但 <a href="https://www.python.org/dev/peps/pep-0008"><strong>PEP 8</strong></a> 建议实现所有六个 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#comparisons">富比较</a> 。 这将有助于避免在与其他排序工具（如 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#max" title="max"><code>max()</code></a> ）使用相同的数据时出现错误，这些工具依赖于不同的底层方法。实现所有六个比较也有助于避免混合类型比较的混乱，因为混合类型比较可以调用反射到 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__gt__" title="object.__gt__"><code>__gt__()</code></a> 的方法。</p>
<p>有关排序示例和简要排序教程，请参阅 <a href="https://docs.python.org/zh-cn/3.10/howto/sorting.html#sortinghowto">排序指南</a> 。</p>
<p><code>@``staticmethod</code><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#staticmethod" title="永久链接至目标"></a></p>
<p>将方法转换为静态方法。</p>
<p>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法</p>
<p>class C:<br>    @staticmethod<br>    def f(arg1, arg2, …): …</p>
<p><code>@staticmethod</code> 这样的形式称为函数的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-decorator">decorator</a> – 详情参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a>。</p>
<p>静态方法既可以由类中调用（如 <code>C.f()</code>），也可以由实例中调用（如 <code>`C().f()</code>）。此外，还可以作为普通的函数进行调用（如 <code>f()</code>）。</p>
<p>Python 的静态方法与 Java 或 C++ 类似。另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#classmethod" title="classmethod"><code>classmethod()</code></a> ，可用于创建另一种类构造函数。</p>
<p>像所有装饰器一样，也可以像常规函数一样调用 <code>staticmethod</code> ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:</p>
<p>def regular_function():<br>    …</p>
<p>class C:<br>    method &#x3D; staticmethod(regular_function)</p>
<p>想了解更多有关静态方法的信息，请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#types">标准类型层级结构</a> 。</p>
<p>在 3.10 版更改: 静态方法继承了方法的多个属性（ <code>__module__</code>、 <code>__name__</code>、 <code>__qualname__</code>、 <code>__doc__</code> 和 <code>__annotations__</code>），还拥有一个新的 <code>__wrapped__</code> 属性，并且现在还可以作为普通函数进行调用。</p>
<p><em>class</em> <code>str</code>(<em>object&#x3D;’’</em>)</p>
<p><em>class</em> <code>str</code>(<em>object&#x3D;b’’</em>, <em>encoding&#x3D;’utf-8’</em>, <em>errors&#x3D;’strict’</em>)</p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 版本的 <em>object</em> 。有关详细信息，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 。</p>
<p><code>str</code> 是内置字符串 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-class">class</a> 。更多关于字符串的信息查看 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#textseq">文本序列类型 — str</a>。</p>
<p><code>sum</code>(<em>iterable</em>, <em>&#x2F;</em>, <em>start&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sum" title="永久链接至目标"></a></p>
<p>从 <em>start</em> 开始自左向右对 <em>iterable</em> 的项求和并返回总计值。 <em>iterable</em> 的项通常为数字，而 start 值则不允许为字符串。</p>
<p>对某些用例来说，存在 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sum" title="sum"><code>sum()</code></a> 的更好替代。 拼接字符串序列的更好更快方式是调用 <code>&#39;&#39;.join(sequence)</code>。 要以扩展精度对浮点值求和，请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/math.html#math.fsum" title="math.fsum"><code>math.fsum()</code></a>。 要拼接一系列可迭代对象，请考虑使用 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.chain" title="itertools.chain"><code>itertools.chain()</code></a>。</p>
<p>在 3.8 版更改: <em>start</em> 形参可用关键字参数形式来指定。</p>
<p><em>class</em> <code>super</code>([<em>type</em>[, <em>object-or-type</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="永久链接至目标"></a></p>
<p>返回一个代理对象，它会将方法调用委托给 <em>type</em> 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。</p>
<p><em>object-or-type</em> 确定用于搜索的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-method-resolution-order">method resolution order</a>。 搜索会从 <em>type</em> 之后的类开始。</p>
<p>举例来说，如果 <em>object-or-type</em> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__mro__" title="class.__mro__"><code>__mro__</code></a> 为 <code>D -&gt; B -&gt; C -&gt; A -&gt; object</code> 并且 <em>type</em> 的值为 <code>B</code>，则 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 将会搜索 <code>C -&gt; A -&gt; object</code>。</p>
<p><em>object-or-type</em> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__mro__" title="class.__mro__"><code>__mro__</code></a> 属性列出了 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 所共同使用的方法解析搜索顺序。 该属性是动态的，可以在任何继承层级结构发生更新的时候被改变。</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 <code>isinstance(obj, type)</code> 必须为真值。 如果第二个参数为一个类型，则 <code>issubclass(type2, type)</code> 必须为真值（这适用于类方法）。</p>
<p><em>super</em> 有两个典型用例。 在具有单继承的类层级结构中，<em>super</em> 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 <em>super</em> 的用法非常相似。</p>
<p>第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。</p>
<p>对于以上两个用例，典型的超类调用看起来是这样的:</p>
<p>class C(B):<br>    def method(self, arg):<br>        super().method(arg)    # This does the same thing as:</p>
<h1 id="super-C-self-method-arg"><a href="#super-C-self-method-arg" class="headerlink" title="super(C, self).method(arg)"></a>super(C, self).method(arg)</h1><p>除了方法查找之外，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-descriptor">描述器</a>。</p>
<p>请注意 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 <code>super().__getitem__(name)</code>。 它做到这一点是通过实现自己的 <code>__getattribute__()</code> 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。 对应地，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 在像 <code>super()[name]</code> 这样使用语句或操作符进行隐式查找时则未被定义。</p>
<p>还要注意的是，除了零个参数的形式以外，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。</p>
<p>对于有关如何使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#super" title="super"><code>super()</code></a> 来如何设计协作类的实用建议，请参阅 <a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/">使用 super() 的指南</a>。</p>
<p><em>class</em> <code>tuple</code>([<em>iterable</em>])</p>
<p>虽然被称为函数，但 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 实际上是一个不可变的序列类型，参见在 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-tuple">元组</a> 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq">序列类型 — list, tuple, range</a> 中的文档说明。</p>
<p><em>class</em> <code>type</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="永久链接至目标"></a></p>
<p><em>class</em> <code>type</code>(<em>name</em>, <em>bases</em>, <em>dict</em>, <em>**kwds</em>)</p>
<p>传入一个参数时，返回 <em>object</em> 的类型。 返回值是一个 type 对象，通常与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#instance.__class__" title="instance.__class__"><code>object.__class__</code></a> 所返回的对象相同。</p>
<p>推荐使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 内置函数来检测对象的类型，因为它会考虑子类的情况。</p>
<p>传入三个参数时，返回一个新的 type 对象。 这在本质上是 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#class"><code>class</code></a> 语句的一种动态形式，<em>name</em> 字符串即类名并会成为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#definition.__name__" title="definition.__name__"><code>__name__</code></a> 属性；<em>bases</em> 元组包含基类并会成为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__bases__" title="class.__bases__"><code>__bases__</code></a> 属性；如果为空则会添加所有类的终极基类 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a>。 <em>dict</em> 字典包含类主体的属性和方法定义；它在成为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性之前可能会被拷贝或包装。 下面两条语句会创建相同的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="type"><code>type</code></a> 对象:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class X:<br>…     a &#x3D; 1<br>…<br>X &#x3D; type(‘X’, (), dict(a&#x3D;1))</p>
</blockquote>
</blockquote>
</blockquote>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bltin-type-objects">类型对象</a>。</p>
<p>提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__init_subclass__" title="object.__init_subclass__"><code>__init_subclass__()</code></a>)，相当于类定义中关键字 (除了 <em>metaclass</em>) 的行为方式。</p>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#class-customization">自定义类创建</a>。</p>
<p>在 3.6 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="type"><code>type</code></a> 的子类如果未重载 <code>type.__new__</code>，将不再能使用一个参数的形式来获取对象的类型。</p>
<p><code>vars</code>([<em>object</em>])<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#vars" title="永久链接至目标"></a></p>
<p>返回模块、类、实例或任何其它具有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性的对象的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性。</p>
<p>模块和实例这样的对象具有可更新的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性；但是，其它对象的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性可能会设为限制写入（例如，类会使用 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code>types.MappingProxyType</code></a> 来防止直接更新字典）。</p>
<p>不带参数时，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#vars" title="vars"><code>vars()</code></a> 的行为类似 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#locals" title="locals"><code>locals()</code></a>。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。</p>
<p>如果指定了一个对象但它没有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 属性（例如，当它所属的类定义了 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__slots__" title="object.__slots__"><code>__slots__</code></a> 属性时）则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 异常。</p>
<p><code>zip</code>(<em>*iterables</em>, <em>strict&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="永久链接至目标"></a></p>
<p>在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。</p>
<p>示例:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>for item in zip([1, 2, 3], [‘sugar’, ‘spice’, ‘everything nice’]):<br>…     print(item)<br>…<br>(1, ‘sugar’)<br>(2, ‘spice’)<br>(3, ‘everything nice’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>更正式的说法： <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 返回元组的迭代器，其中第 <em>i</em> 个元组包含的是每个参数迭代器的第 <em>i</em> 个元素。</p>
<p>不妨换一种方式认识 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> ：它会把行变成列，把列变成行。这类似于 <a href="https://en.wikipedia.org/wiki/Transpose">矩阵转置</a> 。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 是延迟执行的：直至迭代时才会对元素进行处理，比如 <code>for</code> 循环或放入 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 中。</p>
<p>值得考虑的是，传给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python 提供了三种不同的处理方案：</p>
<ul>
<li><p>默认情况下，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>list(zip(range(3), [‘fee’, ‘fi’, ‘fo’, ‘fum’]))<br>  [(0, ‘fee’), (1, ‘fi’), (2, ‘fo’)]
  </p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>通常 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 用于可迭代对象等长的情况下。这时建议用 <code>strict=True</code> 的选项。输出与普通的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 相同：。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>list(zip((‘a’, ‘b’, ‘c’), (1, 2, 3), strict&#x3D;True))<br>  [(‘a’, 1), (‘b’, 2), (‘c’, 3)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>  与默认行为不同，如果一个可迭代对象在其他几个之前被耗尽则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>for item in zip(range(3), [‘fee’, ‘fi’, ‘fo’, ‘fum’], strict&#x3D;True):<br>  …     print(item)<br>  …<br>  (0, ‘fee’)<br>  (1, ‘fi’)<br>  (2, ‘fo’)<br>  Traceback (most recent call last):<br>    …<br>  ValueError: zip() argument 2 is longer than argument 1</p>
</blockquote>
</blockquote>
</blockquote>
<p>  如果未指定 <code>strict=True</code> 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会在程序的其他地方表现为难以发现的错误。</p>
</li>
<li><p>为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.zip_longest" title="itertools.zip_longest"><code>itertools.zip_longest()</code></a> 来完成。</p>
</li>
</ul>
<p>极端例子是只有一个可迭代对象参数，<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。</p>
<p>小技巧：</p>
<ul>
<li><p>可确保迭代器的求值顺序是从左到右的。这样就能用 <code>zip(*[iter(s)]*n, strict=True)</code> 将数据列表按长度 n 进行分组。这将重复 <em>相同</em> 的迭代器 <code>n</code> 次，输出的每个元组都包含 <code>n</code> 次调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 与 <code>*</code> 运算符相结合可以用来拆解一个列表:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>x &#x3D; [1, 2, 3]<br>y &#x3D; [4, 5, 6]<br>list(zip(x, y))<br>  [(1, 4), (2, 5), (3, 6)]<br>x2, y2 &#x3D; zip(*zip(x, y))<br>x &#x3D;&#x3D; list(x2) and y &#x3D;&#x3D; list(y2)<br>  True</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<p>在 3.10 版更改: 增加了 <code>strict</code> 参数。</p>
<p><code>__import__</code>(<em>name</em>, <em>globals&#x3D;None</em>, <em>locals&#x3D;None</em>, <em>fromlist&#x3D;()</em>, <em>level&#x3D;0</em>)<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#import__" title="永久链接至目标"></a></p>
<p>注解</p>
<p> </p>
<p>与 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.import_module" title="importlib.import_module"><code>importlib.import_module()</code></a> 不同，这是一个日常 Python 编程中不需要用到的高级函数。</p>
<p>此函数会由 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句发起调用。 它可以被替换 (通过导入 <a href="https://docs.python.org/zh-cn/3.10/library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code>builtins</code></a> 模块并赋值给 <code>builtins.__import__</code>) 以便修改 <code>import</code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <a href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#import__" title="__import__"><code>__import__()</code></a> 而应该用 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.import_module" title="importlib.import_module"><code>importlib.import_module()</code></a>。</p>
<p>本函数会导入模块 <em>name_，利用 <em>globals</em> 和 <em>locals</em> 来决定如何在包的上下文中解释该名称。_fromlist</em> 给出了应从 <em>name</em> 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到 <em>locals</em> 参数，只用到了 <em>globals</em> 用于确定 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句所在的包上下文。</p>
<p><em>level</em> 指定是使用绝对还是相对导入。 <code>0</code> (默认值) 意味着仅执行绝对导入。 <em>level</em> 为正数值表示相对于模块调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#import__" title="__import__"><code>__import__()</code></a> 的目录，将要搜索的父目录层数 (详情参见 <a href="https://www.python.org/dev/peps/pep-0328"><strong>PEP 328</strong></a>)。</p>
<p>当 <em>name</em> 变量的形式为 <code>package.module</code> 时，通常将会返回最高层级的包（第一个点号之前的名称），而 <em>不是</em> 以 <em>name</em> 命名的模块。 但是，当给出了非空的 <em>fromlist</em> 参数时，则将返回以 <em>name</em> 命名的模块。</p>
<p>例如，语句 <code>import spam</code> 的结果将为与以下代码作用相同的字节码:</p>
<p>spam &#x3D; <strong>import</strong>(‘spam’, globals(), locals(), [], 0)</p>
<p>语句 <code>import spam.ham</code> 的结果将为以下调用:</p>
<p>spam &#x3D; <strong>import</strong>(‘spam.ham’, globals(), locals(), [], 0)</p>
<p>请注意在这里 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#import__" title="__import__"><code>__import__()</code></a> 是如何返回顶层模块的，因为这是通过 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句被绑定到特定名称的对象。</p>
<p>另一方面，语句 <code>from spam.ham import eggs, sausage as saus</code> 的结果将为</p>
<p>_temp &#x3D; <strong>import</strong>(‘spam.ham’, globals(), locals(), [‘eggs’, ‘sausage’], 0)<br>eggs &#x3D; _temp.eggs<br>saus &#x3D; _temp.sausage</p>
<p>在这里， <code>spam.ham</code> 模块会由 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#import__" title="__import__"><code>__import__()</code></a> 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果您只想按名称导入模块（可能在包中），请使用 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.import_module" title="importlib.import_module"><code>importlib.import_module()</code></a></p>
<p>在 3.3 版更改: <em>level</em> 的值不再支持负数（默认值也修改为0）。</p>
<p>在 3.9 版更改: 当使用了命令行参数 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-E"><code>-E</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-I"><code>-I</code></a> 时，环境变量 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#envvar-PYTHONCASEOK"><code>PYTHONCASEOK</code></a> 现在将被忽略。</p>
]]></content>
      <tags>
        <tag>Python Python标准库 内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法如下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def 函数名(传入参数):</span></span><br><span class="line"><span class="string">	函数体</span></span><br><span class="line"><span class="string">	return 返回值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">num = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为5</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 程序中函数完成事情之后, 最后给调用者的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例1, 没有实际返回值, 所以默认返回空值None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;666&quot;</span>)</span><br><span class="line">i = show()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果为</span></span><br><span class="line"><span class="comment"># 666</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;NoneType&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">num = <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="comment"># 输出结果为</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 函数返回值为5, 并被赋值于i</span></span><br><span class="line"><span class="comment"># 调用函数的语句不可以在函数定义之前</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法如下</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    两个参数相加的功能</span></span><br><span class="line"><span class="string">    :param x: 参数1</span></span><br><span class="line"><span class="string">    :param y: 参数2</span></span><br><span class="line"><span class="string">    :return: 返回两个参数相加的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># 添加多行注释后会自动添加各个参数的</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义在函数体内的变量, 只在函数体内部生效</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">	<span class="built_in">print</span>(num)</span><br><span class="line">test()  <span class="comment"># 输出结果是100</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 报错: name &#x27;num&#x27; is not defined</span></span><br><span class="line"><span class="comment"># 在函数外部已经定义同名变量, 函数体内部也可以正常使用</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="关键词global"><a href="#关键词global" class="headerlink" title="关键词global"></a>关键词global</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">200</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">	<span class="built_in">print</span>(num)</span><br><span class="line">test()  <span class="comment"># 输出结果为100</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出结果为200</span></span><br><span class="line"><span class="comment"># 函数内部对num变量的修改没有生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数内部使用global关键词声明变量后, 即可以在全局中生效</span></span><br><span class="line">num = <span class="number">200</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">	<span class="keyword">global</span> num</span><br><span class="line">	num = <span class="number">100</span></span><br><span class="line">	<span class="built_in">print</span>(num)</span><br><span class="line">test()  <span class="comment"># 输出结果为100</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出结果为100</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python基础知识 函数 def global</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h4 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">x, y = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 结果1</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 结果2</span></span><br><span class="line"><span class="comment"># 支持不同类型的数据return</span></span><br></pre></td></tr></table></figure>


<p><br><br><br><br><br></p>
<hr>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>使用方式上的不同, 函数有4种常见参数使用方式:<br>![[Pasted image 20231223155107.png]]</p>
<ol>
<li><p><strong>位置参数</strong><br> 调用函数时根据函数定义的参数位置来传递参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;名字: <span class="subst">&#123;name&#125;</span>, 年龄: <span class="subst">&#123;age&#125;</span>, 性别: <span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 名字: TOM, 年龄: 20, 性别: 男</span></span><br></pre></td></tr></table></figure>
<div style = "color: red">注意:<br>
传递的参数和定义的参数的顺序, 以及个数必须一一对应
<b></b></div><br>
</li>
<li><p><strong>关键词参数</strong><br> 函数调用时通过”键&#x3D;值”形式传递参数<br> 作用: 可以让函数更加清晰, 容易使用, 同时也清除了参数的顺序需求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;名字: <span class="subst">&#123;name&#125;</span>, 年龄: <span class="subst">&#123;age&#125;</span>, 性别: <span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 关键词传参</span></span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>, gender = <span class="string">&quot;男&quot;</span>, age = <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 特点</span></span><br><span class="line"><span class="comment"># 可以和位置参数混用, 位置参数必须在前, 且匹配参数顺序</span></span><br><span class="line"><span class="comment"># 可以不按照固定顺序关键词传参</span></span><br></pre></td></tr></table></figure>
<div style = "color: red">注意:<br>
函数调用时, 如果有位置参数时, 位置参数必须在关键词参数的前面.<br>
但关键词参数之间不存在先后顺序
<b></b></div><br>
</li>
<li><p>缺省参数<br> 缺省参数也叫默认参数, 用于定义函数, 为参数提供默认值, 调用函数时可以不传该默认参数的值**(注意: 所有位置参数必须出现在默认参数前, 包含函数定义和调用)**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender = <span class="string">&quot;男&quot;</span></span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;名字: <span class="subst">&#123;name&#125;</span>, 年龄: <span class="subst">&#123;age&#125;</span>, 性别: <span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>, <span class="number">20</span>)</span><br><span class="line">user_info(<span class="string">&quot;ROSE&quot;</span>, <span class="number">18</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 名字: TOM, 年龄: 20, 性别: 男</span></span><br><span class="line"><span class="comment"># 名字: ROSE, 年龄: 18, 性别: 女</span></span><br></pre></td></tr></table></figure>
<div style = "color: red">注意:<br>
函数调用时, 如果为缺省参数传值, 则修改默认参数值, 否则使用默认值<br>
缺省参数的设置必须是在最后面.
<b></b></div><br>
</li>
<li><p>不定长参数<br> 不定长参数也叫可变参数, 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景<br> 当调用函数时不确定参数个数时, 可以使用不定长参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">*args</span>):</span><br><span class="line">	<span class="built_in">print</span>(args)</span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>)</span><br><span class="line">user_info(<span class="string">&quot;ROSE&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># (&#x27;TOM&#x27;,)</span></span><br><span class="line"><span class="comment"># (&#x27;ROSE&#x27;, 18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键词传递的不定长</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">**kwargs</span>)</span><br><span class="line">	<span class="built_in">print</span>(kwargs)</span><br><span class="line">user_info(name = <span class="string">&quot;TOM&quot;</span>, age = <span class="number">18</span>, <span class="built_in">id</span> = <span class="number">110</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure>
<div style = "color: red">注意:<br></li>
<li><p>传进的所有参数都会被args变量收集, 它会根据传进参数的位置合并为一个元组(tuple), args是元组类型, 这就是位置传递<br></p>
</li>
<li><p>参数是”键&#x3D;值”形式的情况下, 所有的”键&#x3D;值”都会被kwargs接收, 同时会根据”键&#x3D;值”组成字典.<br><b></b></div><br><br><br><br><br><br><br></p>
</li>
</ol>
<hr>
<h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_sum</span>(<span class="params">compute</span>):</span><br><span class="line">	result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span>(result)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute</span>(<span class="params">x, y</span>):</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">test_sum(compute)  <span class="comment"># 结果  3</span></span><br></pre></td></tr></table></figure>
<div style = "color: red">注意:<br>
1. test_sum需要一个函数作为参数传入, 这个函数需要接收2个数字进行计算, 计算逻辑由这个被传入函数决定.<br>
2. compute函数接收2个数字对其进行计算, compute函数作为参数, 传递给了test_sum函数使用<br>
3. 最终, 在test_sum函数内部, 由传入的compute函数, 完成了对数字的计算操作
4. 这是一种计算逻辑的传递, 而非数据的传递
<b></b></div><br>
<br><br><br><br><br>

<hr>
<h4 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h4><p>lambda关键词, 可以定义匿名函数(无名称)<br>有名称的函数, 可以基于名称重复使用<br>无名称的匿名函数, 只可临时使用一次<br>定义语法: lambda 传入参数: 函数体(一行代码)</p>
<ul>
<li>传入参数表示匿名函数的形式参数, 如: x, y表示接收2个形式参数</li>
<li>函数体, 就是函数的执行逻辑, 要注意: 只能写一行, 无法写多行代码<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_sum</span>(<span class="params">compute</span>):</span><br><span class="line">	result = compute(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span>(result)</span><br><span class="line">test_sum(<span class="keyword">lambda</span> x, y: x + y)</span><br><span class="line"><span class="comment"># 结果 3</span></span><br></pre></td></tr></table></figure>
<div style = "color: red">注意:<br></li>
</ul>
<ol>
<li>lambda关键词定义的函数时匿名的, 无法二次使用<br><b></b></div><br><br><br><br><br><br><br></li>
</ol>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python 函数进阶 lambda匿名函数</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%86%85%E7%BD%AE%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>在 Python 中，所有异常必须为一个派生自 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException" title="BaseException"><code>BaseException</code></a> 的类的实例。 在带有提及一个特定类的 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#except"><code>except</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#try"><code>try</code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p>
<p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p>
<p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p>
<p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="Exception"><code>Exception</code></a> 类或它的某个子类而不是从 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException" title="BaseException"><code>BaseException</code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a href="https://docs.python.org/zh-cn/3.10/tutorial/errors.html#tut-userexceptions">用户自定义异常</a> 部分查看。</p>
<h2 id="异常上下文"><a href="#异常上下文" class="headerlink" title="异常上下文"></a>异常上下文</h2><p>当有其他异常已经被处理的情况下又引发一个新异常的时候，新异常的 <code>__context__</code> 属性会被自动设为已经被处理的异常。 异常可以在使用了 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#except"><code>except</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#finally"><code>finally</code></a> 子句，或者 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句的时候被处理。</p>
<p>这个隐式异常上下文可以通过使用 <code>from</code> 配合 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#raise"><code>raise</code></a> 来补充一个显式的原因:</p>
<p>raise new_exc from original_exc</p>
<p>跟在 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#raise"><code>from</code></a> 之后一表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p>
<p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#None" title="None"><code>None</code></a> 并且 <code>__suppress_context__</code> 为假值时显示。</p>
<p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p>
<h2 id="从内置异常继承"><a href="#从内置异常继承" class="headerlink" title="从内置异常继承"></a>从内置异常继承</h2><p>用户代码可以创建继承自某个异常类型的子类。 建议每次仅子类化一个异常类型以避免多个基类处理 <code>args</code> 属性的不同方式，以及内存布局不兼容可能导致的冲突。</p>
<p><strong>CPython 实现细节：</strong> 大多数内置异常都用 C 实现以保证运行效率，参见: <a href="https://github.com/python/cpython/tree/3.10/Objects/exceptions.c">Objects&#x2F;exceptions.c</a>。 其中一些具有自定义内存布局，这使得创建继承自多个异常类型的子类成为不可能。 一个类型的内存布局属于实现细节并可能随着 Python 版本升级而改变，导致在未来可能产生新的冲突。 因此，建议完全避免子类化多个异常类型。</p>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p>
<p><em>exception</em> <code>BaseException</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException" title="永久链接至目标"></a></p>
<p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="Exception"><code>Exception</code></a>)。 如果在此类的实例上调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p>
<p><code>args</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException.args" title="永久链接至目标"></a></p>
<p>传给异常构造器的参数元组。 某些内置异常 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p>
<p><code>with_traceback</code>(<em>tb</em>)<a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException.with_traceback" title="永久链接至目标"></a></p>
<p>此方法会将 <em>tb</em> 设为新的异常回溯信息并返回异常对象。 它在 <a href="https://www.python.org/dev/peps/pep-3134"><strong>PEP 3134</strong></a> 的异常链特性可用之前更为常用。 下面的例子演示了我们如何将一个 <code>SomeException</code> 实例转换为 <code>OtherException</code> 实例而保留回溯信息。 异常一旦被引发，当前帧会被推至 <code>OtherException</code> 的回溯栈顶端，就像当我们允许原始 <code>SomeException</code> 被传播给调用方时它的回溯栈将会发生的情形一样。:</p>
<p>try:<br>    …<br>except SomeException:<br>    tb &#x3D; sys.exc_info()[2]<br>    raise OtherException(…).with_traceback(tb)</p>
<p><em>exception</em> <code>Exception</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="永久链接至目标"></a></p>
<p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p>
<p><em>exception</em> <code>ArithmeticError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ArithmeticError" title="永久链接至目标"></a></p>
<p>此基类用于派生针对各种算术类错误而引发的内置异常: <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ZeroDivisionError" title="ZeroDivisionError"><code>ZeroDivisionError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FloatingPointError" title="FloatingPointError"><code>FloatingPointError</code></a>。</p>
<p><em>exception</em> <code>BufferError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BufferError" title="永久链接至目标"></a></p>
<p>当与 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲区</a> 相关的操作无法执行时将被引发。</p>
<p><em>exception</em> <code>LookupError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#LookupError" title="永久链接至目标"></a></p>
<p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。 这可以通过 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#codecs.lookup" title="codecs.lookup"><code>codecs.lookup()</code></a> 来直接引发。</p>
<h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p>
<p><em>exception</em> <code>AssertionError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#AssertionError" title="永久链接至目标"></a></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#assert"><code>assert</code></a> 语句失败时将被引发。</p>
<p><em>exception</em> <code>AttributeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#AttributeError" title="永久链接至目标"></a></p>
<p>当属性引用 (参见 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#attribute-references">属性引用</a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。）</p>
<p><code>name</code> 和 <code>obj</code> 属性可以使用构造器的仅限关键字参数来设置。 它们如果被设置则分别代表要尝试访问的属性名称以及所访问的该属性的对象。</p>
<p>在 3.10 版更改: 增加了 <code>name</code> 和 <code>obj</code> 属性。</p>
<p><em>exception</em> <code>EOFError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#EOFError" title="永久链接至目标"></a></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#input" title="input"><code>input()</code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.IOBase.readline" title="io.IOBase.readline"><code>io.IOBase.readline()</code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p>
<p><em>exception</em> <code>FloatingPointError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FloatingPointError" title="永久链接至目标"></a></p>
<p>目前未被使用。</p>
<p><em>exception</em> <code>GeneratorExit</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#GeneratorExit" title="永久链接至目标"></a></p>
<p>当一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-coroutine">coroutine</a> 被关闭时将被引发；参见 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#generator.close" title="generator.close"><code>generator.close()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#coroutine.close" title="coroutine.close"><code>coroutine.close()</code></a>。 它直接继承自 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException" title="BaseException"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="Exception"><code>Exception</code></a>，因为从技术上来说它并不是一个错误。</p>
<p><em>exception</em> <code>ImportError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ImportError" title="永久链接至目标"></a></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。</p>
<p><code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。</p>
<p>在 3.3 版更改: 添加了 <code>name</code> 与 <code>path</code> 属性。</p>
<p><em>exception</em> <code>ModuleNotFoundError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ModuleNotFoundError" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ImportError" title="ImportError"><code>ImportError</code></a> 的子类，当一个模块无法被定位时将由 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 引发。 当在 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.modules" title="sys.modules"><code>sys.modules</code></a> 中找到 <code>None</code> 时也会被引发。</p>
<p>3.6 新版功能.</p>
<p><em>exception</em> <code>IndexError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="永久链接至目标"></a></p>
<p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 会被引发。）</p>
<p><em>exception</em> <code>KeyError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="永久链接至目标"></a></p>
<p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p>
<p><em>exception</em> <code>KeyboardInterrupt</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyboardInterrupt" title="永久链接至目标"></a></p>
<p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException" title="BaseException"><code>BaseException</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="Exception"><code>Exception</code></a> 的代码意外捕获，这样可以避免退出解释器。</p>
<p>注解</p>
<p> </p>
<p>捕获 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> 需要特别考虑。 因为它可能会在不可预知的点位被引发，在某些情况下，它可能使运行中的程序陷入不一致的状态。 通常最好是让 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code>KeyboardInterrupt</code></a> 尽快结束程序或者完全避免引发它。 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/signal.html#handlers-and-exceptions">有关信号处理句柄和异常的注释</a>。)</p>
<p><em>exception</em> <code>MemoryError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#MemoryError" title="永久链接至目标"></a></p>
<p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p>
<p><em>exception</em> <code>NameError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#NameError" title="永久链接至目标"></a></p>
<p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p>
<p><code>name</code> 属性可以使用构造器的仅限关键字参数来设置。 它如果被设置则代表要尝试访问的变量名称。</p>
<p>在 3.10 版更改: 增加了 <code>name</code> 属性。</p>
<p><em>exception</em> <code>NotImplementedError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#NotImplementedError" title="永久链接至目标"></a></p>
<p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p>
<p>注解</p>
<p> </p>
<p>它不应当用来表示一个运算符或方法根本不能被支持 – 在此情况下应当让特定运算符 &#x2F; 方法保持未定义，或者在子类中将其设为 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#None" title="None"><code>None</code></a>。</p>
<p>注解</p>
<p> </p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#NotImplemented" title="NotImplemented"><code>NotImplemented</code></a> 了解有关何时使用它们的详细说明。</p>
<p><em>exception</em> <code>OSError</code>([<em>arg</em>])<a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="永久链接至目标"></a></p>
<p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p>
<p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I&#x2F;O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p>
<p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#None" title="None"><code>None</code></a>。 为了能向下兼容，如果传入了三个参数，则 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException.args" title="BaseException.args"><code>args</code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p>
<p>构造器实际返回的往往是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 的某个子类，如下文 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#os-exceptions">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.errno" title="OSError.errno"><code>errno</code></a> 值。 此行为仅在直接或通过别名来构造 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 时发生，并且在子类化时不会被继承。</p>
<p><code>errno</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.errno" title="永久链接至目标"></a></p>
<p>来自于 C 变量 <code>errno</code> 的数字错误码。</p>
<p><code>winerror</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.winerror" title="永久链接至目标"></a></p>
<p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.errno" title="OSError.errno"><code>errno</code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。</p>
<p>在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.errno" title="OSError.errno"><code>errno</code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.winerror" title="OSError.winerror"><code>winerror</code></a> 属性将不存在。</p>
<p><code>strerror</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.strerror" title="永久链接至目标"></a></p>
<p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p>
<p><code>filename</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.filename" title="永久链接至目标"></a></p>
<p><code>filename2</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.filename2" title="永久链接至目标"></a></p>
<p>对于与文件系统路径有关 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.unlink" title="os.unlink"><code>os.unlink()</code></a>) 的异常，<a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.filename" title="OSError.filename"><code>filename</code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.rename" title="os.rename"><code>os.rename()</code></a>)，<a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.filename2" title="OSError.filename2"><code>filename2</code></a> 将是传给函数的第二个文件名。</p>
<p>在 3.3 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#EnvironmentError" title="EnvironmentError"><code>EnvironmentError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IOError" title="IOError"><code>IOError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#WindowsError" title="WindowsError"><code>WindowsError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/socket.html#socket.error" title="socket.error"><code>socket.error</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/select.html#select.error" title="select.error"><code>select.error</code></a> 与 <code>mmap.error</code> 已被合并到 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a>，构造器可能返回其中一个子类。</p>
<p>在 3.4 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError.filename" title="OSError.filename"><code>filename</code></a> 属性现在是传给函数的原始文件名，而不是基于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-filesystem-encoding-and-error-handler">filesystem encoding and error handler</a> 进行编码或解码之后的名称。 此外，还添加了 <em>filename2</em> 构造器参数和属性。</p>
<p><em>exception</em> <code>OverflowError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="永久链接至目标"></a></p>
<p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#MemoryError" title="MemoryError"><code>MemoryError</code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p>
<p><em>exception</em> <code>RecursionError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RecursionError" title="永久链接至目标"></a></p>
<p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.getrecursionlimit" title="sys.getrecursionlimit"><code>sys.getrecursionlimit()</code></a>) 时被引发。</p>
<p>3.5 新版功能: 在此之前将只引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>。</p>
<p><em>exception</em> <code>ReferenceError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ReferenceError" title="永久链接至目标"></a></p>
<p>此异常将在使用 <a href="https://docs.python.org/zh-cn/3.10/library/weakref.html#weakref.proxy" title="weakref.proxy"><code>weakref.proxy()</code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code>weakref</code></a> 模块。</p>
<p><em>exception</em> <code>RuntimeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="永久链接至目标"></a></p>
<p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p>
<p><em>exception</em> <code>StopIteration</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="永久链接至目标"></a></p>
<p>由内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#next" title="next"><code>next()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法所引发，用来表示该迭代器不能产生下一项。</p>
<p>该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#None" title="None"><code>None</code></a>。</p>
<p>当一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-coroutine">coroutine</a> 函数返回时，将引发一个新的 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。</p>
<p>如果某个生成器代码直接或间接地引发了 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>，它会被转换为 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> (并将 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 保留为导致新异常的原因)。</p>
<p>在 3.3 版更改: 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。</p>
<p>在 3.5 版更改: 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479"><strong>PEP 479</strong></a>。</p>
<p>在 3.7 版更改: 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479"><strong>PEP 479</strong></a>: 在生成器中引发的 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 错误将被转换为 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a>。</p>
<p><em>exception</em> <code>StopAsyncIteration</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopAsyncIteration" title="永久链接至目标"></a></p>
<p>必须由一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-iterator">asynchronous iterator</a> 对象的 <code>__anext__()</code> 方法来引发以停止迭代操作。</p>
<p>3.5 新版功能.</p>
<p><em>exception</em> <code>SyntaxError</code>(<em>message</em>, <em>details</em>)<a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="永久链接至目标"></a></p>
<p>当解析器遇到语法错误时引发。 这可以发生在 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句，对内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#compile" title="compile"><code>compile()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。</p>
<p>异常实例的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获取。</p>
<p><code>filename</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.filename" title="永久链接至目标"></a></p>
<p>发生语法错误所在文件的名称。</p>
<p><code>lineno</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.lineno" title="永久链接至目标"></a></p>
<p>发生错误所在文件中的行号。 行号索引从 1 开始：文件中首行的 <code>lineno</code> 为 1。</p>
<p><code>offset</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.offset" title="永久链接至目标"></a></p>
<p>发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 <code>offset</code> 为 1。</p>
<p><code>text</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.text" title="永久链接至目标"></a></p>
<p>错误所涉及的源代码文本。</p>
<p><code>end_lineno</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.end_lineno" title="永久链接至目标"></a></p>
<p>发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 <code>lineno</code> 为 1。</p>
<p><code>end_offset</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.end_offset" title="永久链接至目标"></a></p>
<p>发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 <code>offset</code> 为 1。</p>
<p>对于 f-字符串字段中的错误，消息会带有 “f-string: “ 前缀并且其位置是基于替换表达式构建的文本中的位置。 例如，编译 f’Bad {a b} field’ 将产生这样的 args 属性: (‘f-string: …’, (‘’, 1, 2, ‘(a b)n’, 1, 5))。</p>
<p>在 3.10 版更改: 增加了 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.end_lineno" title="SyntaxError.end_lineno"><code>end_lineno</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError.end_offset" title="SyntaxError.end_offset"><code>end_offset</code></a> 属性。</p>
<p><em>exception</em> <code>IndentationError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndentationError" title="永久链接至目标"></a></p>
<p>与不正确的缩进相关的语法错误的基类。 这是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxError" title="SyntaxError"><code>SyntaxError</code></a> 的一个子类。</p>
<p><em>exception</em> <code>TabError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TabError" title="永久链接至目标"></a></p>
<p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndentationError" title="IndentationError"><code>IndentationError</code></a> 的一个子类。</p>
<p><em>exception</em> <code>SystemError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SystemError" title="永久链接至目标"></a></p>
<p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。</p>
<p>你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p>
<p><em>exception</em> <code>SystemExit</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SystemExit" title="永久链接至目标"></a></p>
<p>此异常由 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.exit" title="sys.exit"><code>sys.exit()</code></a> 函数引发。 它继承自 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BaseException" title="BaseException"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="Exception"><code>Exception</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Exception" title="Exception"><code>Exception</code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.exit" title="sys.exit"><code>sys.exit()</code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。</p>
<p>对 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.exit" title="sys.exit"><code>sys.exit()</code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#try"><code>try</code></a> 语句的 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#finally"><code>finally</code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.fork" title="os.fork"><code>os.fork()</code></a> 之后的子进程中）则可使用 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os._exit" title="os._exit"><code>os._exit()</code></a>.</p>
<p><code>code</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SystemExit.code" title="永久链接至目标"></a></p>
<p>传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p>
<p><em>exception</em> <code>TypeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="永久链接至目标"></a></p>
<p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。</p>
<p>此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a>。</p>
<p>传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p><em>exception</em> <code>UnboundLocalError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnboundLocalError" title="永久链接至目标"></a></p>
<p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#NameError" title="NameError"><code>NameError</code></a> 的一个子类。</p>
<p><em>exception</em> <code>UnicodeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="永久链接至目标"></a></p>
<p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> 的一个子类。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。</p>
<p><code>encoding</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError.encoding" title="永久链接至目标"></a></p>
<p>引发错误的编码名称。</p>
<p><code>reason</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError.reason" title="永久链接至目标"></a></p>
<p>描述特定编解码器错误的字符串。</p>
<p><code>object</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError.object" title="永久链接至目标"></a></p>
<p>编解码器试图要编码或解码的对象。</p>
<p><code>start</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError.start" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a> 中无效数据的开始位置索引。</p>
<p><code>end</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError.end" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#object" title="object"><code>object</code></a> 中无效数据的末尾位置索引（不含）。</p>
<p><em>exception</em> <code>UnicodeEncodeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeEncodeError" title="永久链接至目标"></a></p>
<p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a> 的一个子类。</p>
<p><em>exception</em> <code>UnicodeDecodeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeDecodeError" title="永久链接至目标"></a></p>
<p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a> 的一个子类。</p>
<p><em>exception</em> <code>UnicodeTranslateError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeTranslateError" title="永久链接至目标"></a></p>
<p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a> 的一个子类。</p>
<p><em>exception</em> <code>ValueError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="永久链接至目标"></a></p>
<p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> 来描述时将被引发。</p>
<p><em>exception</em> <code>ZeroDivisionError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ZeroDivisionError" title="永久链接至目标"></a></p>
<p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p>
<p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 的别名。</p>
<p><em>exception</em> <code>EnvironmentError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#EnvironmentError" title="永久链接至目标"></a></p>
<p><em>exception</em> <code>IOError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IOError" title="永久链接至目标"></a></p>
<p><em>exception</em> <code>WindowsError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#WindowsError" title="永久链接至目标"></a></p>
<p>限在 Windows 中可用。</p>
<h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 的子类，它们将根据系统错误代码被引发。</p>
<p><em>exception</em> <code>BlockingIOError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BlockingIOError" title="永久链接至目标"></a></p>
<p>当一个操作将会在设置为非阻塞操作的对象（例如套接字）上发生阻塞时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EAGAIN" title="errno.EAGAIN"><code>EAGAIN</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EALREADY" title="errno.EALREADY"><code>EALREADY</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EWOULDBLOCK" title="errno.EWOULDBLOCK"><code>EWOULDBLOCK</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EINPROGRESS" title="errno.EINPROGRESS"><code>EINPROGRESS</code></a>。</p>
<p>除了 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 已有的属性，<a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BlockingIOError" title="BlockingIOError"><code>BlockingIOError</code></a> 还有一个额外属性：</p>
<p><code>characters_written</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BlockingIOError.characters_written" title="永久链接至目标"></a></p>
<p>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#module-io" title="io: Core tools for working with streams."><code>io</code></a> 模块的带缓冲 I&#x2F;O 类时此属性可用。</p>
<p><em>exception</em> <code>ChildProcessError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ChildProcessError" title="永久链接至目标"></a></p>
<p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ECHILD" title="errno.ECHILD"><code>ECHILD</code></a>。</p>
<p><em>exception</em> <code>ConnectionError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionError" title="永久链接至目标"></a></p>
<p>与连接相关问题的基类。</p>
<p>其子类有 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BrokenPipeError" title="BrokenPipeError"><code>BrokenPipeError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionAbortedError" title="ConnectionAbortedError"><code>ConnectionAbortedError</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionRefusedError" title="ConnectionRefusedError"><code>ConnectionRefusedError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionResetError" title="ConnectionResetError"><code>ConnectionResetError</code></a>。</p>
<p><em>exception</em> <code>BrokenPipeError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BrokenPipeError" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionError" title="ConnectionError"><code>ConnectionError</code></a> 的子类，当试图写入一个管道而该管道的另一端已关闭，或者试图写入一个套接字而该套接字已关闭写入时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EPIPE" title="errno.EPIPE"><code>EPIPE</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ESHUTDOWN" title="errno.ESHUTDOWN"><code>ESHUTDOWN</code></a>。</p>
<p><em>exception</em> <code>ConnectionAbortedError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionAbortedError" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionError" title="ConnectionError"><code>ConnectionError</code></a> 的子类，当一个连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ECONNABORTED" title="errno.ECONNABORTED"><code>ECONNABORTED</code></a>。</p>
<p><em>exception</em> <code>ConnectionRefusedError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionRefusedError" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionError" title="ConnectionError"><code>ConnectionError</code></a> 的子类，当一个连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ECONNREFUSED" title="errno.ECONNREFUSED"><code>ECONNREFUSED</code></a>。</p>
<p><em>exception</em> <code>ConnectionResetError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionResetError" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ConnectionError" title="ConnectionError"><code>ConnectionError</code></a> 的子类，当一个连接尝试被对端重置时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ECONNRESET" title="errno.ECONNRESET"><code>ECONNRESET</code></a>。</p>
<p><em>exception</em> <code>FileExistsError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FileExistsError" title="永久链接至目标"></a></p>
<p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EEXIST" title="errno.EEXIST"><code>EEXIST</code></a>。</p>
<p><em>exception</em> <code>FileNotFoundError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FileNotFoundError" title="永久链接至目标"></a></p>
<p>将所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ENOENT" title="errno.ENOENT"><code>ENOENT</code></a>。</p>
<p><em>exception</em> <code>InterruptedError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#InterruptedError" title="永久链接至目标"></a></p>
<p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EINTR" title="errno.EINTR"><code>EINTR</code></a>。</p>
<p>在 3.5 版更改: 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475"><strong>PEP 475</strong></a>) 而不是引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#InterruptedError" title="InterruptedError"><code>InterruptedError</code></a>。</p>
<p><em>exception</em> <code>IsADirectoryError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IsADirectoryError" title="永久链接至目标"></a></p>
<p>当请求对一个目录执行文件操作 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.remove" title="os.remove"><code>os.remove()</code></a>) 时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EISDIR" title="errno.EISDIR"><code>EISDIR</code></a>。</p>
<p><em>exception</em> <code>NotADirectoryError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#NotADirectoryError" title="永久链接至目标"></a></p>
<p>当请求对一个非目录执行目录操作 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.listdir" title="os.listdir"><code>os.listdir()</code></a>) 时将被引发。 在大多数 POSIX 平台上，它还可能在某个操作试图将一个非目录作为目录打开或遍历时被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ENOTDIR" title="errno.ENOTDIR"><code>ENOTDIR</code></a>。</p>
<p><em>exception</em> <code>PermissionError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#PermissionError" title="永久链接至目标"></a></p>
<p>当在没有足够访问权限的情况下试图执行某个操作时将被引发 —— 例如文件系统权限。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EACCES" title="errno.EACCES"><code>EACCES</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.EPERM" title="errno.EPERM"><code>EPERM</code></a>。</p>
<p><em>exception</em> <code>ProcessLookupError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ProcessLookupError" title="永久链接至目标"></a></p>
<p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ESRCH" title="errno.ESRCH"><code>ESRCH</code></a>。</p>
<p><em>exception</em> <code>TimeoutError</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TimeoutError" title="永久链接至目标"></a></p>
<p>当一个系统函数在系统层级发生超时的情况下将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.10/library/errno.html#errno.ETIMEDOUT" title="errno.ETIMEDOUT"><code>ETIMEDOUT</code></a>。</p>
<p>3.3 新版功能: 添加了以上所有 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OSError" title="OSError"><code>OSError</code></a> 的子类。</p>
<p>参见</p>
<p> </p>
<p><a href="https://www.python.org/dev/peps/pep-3151"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别；请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/warnings.html#warning-categories">警告类别</a> 文档了解详情。</p>
<p><em>exception</em> <code>Warning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#Warning" title="永久链接至目标"></a></p>
<p>警告类别的基类。</p>
<p><em>exception</em> <code>UserWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UserWarning" title="永久链接至目标"></a></p>
<p>用户代码所产生警告的基类。</p>
<p><em>exception</em> <code>DeprecationWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#DeprecationWarning" title="永久链接至目标"></a></p>
<p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p>
<p>会被默认警告过滤器忽略，在 <code>__main__</code> 模块中的情况除外 (<a href="https://www.python.org/dev/peps/pep-0565"><strong>PEP 565</strong></a>)。 启用 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 时会显示此警告。</p>
<p>这个弃用政策是在 <a href="https://www.python.org/dev/peps/pep-0387"><strong>PEP 387</strong></a> 中描述的。</p>
<p><em>exception</em> <code>PendingDeprecationWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#PendingDeprecationWarning" title="永久链接至目标"></a></p>
<p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。</p>
<p>这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a>。</p>
<p>会被默认警告过滤器忽略。 启用 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 时会显示此警告。</p>
<p>这个弃用政策是在 <a href="https://www.python.org/dev/peps/pep-0387"><strong>PEP 387</strong></a> 中描述的。</p>
<p><em>exception</em> <code>SyntaxWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#SyntaxWarning" title="永久链接至目标"></a></p>
<p>与模糊的语法相关的警告的基类。</p>
<p><em>exception</em> <code>RuntimeWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeWarning" title="永久链接至目标"></a></p>
<p>与模糊的运行时行为相关的警告的基类。</p>
<p><em>exception</em> <code>FutureWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#FutureWarning" title="永久链接至目标"></a></p>
<p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p>
<p><em>exception</em> <code>ImportWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ImportWarning" title="永久链接至目标"></a></p>
<p>与在模块导入中可能的错误相关的警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 时会显示此警告。</p>
<p><em>exception</em> <code>UnicodeWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeWarning" title="永久链接至目标"></a></p>
<p>与 Unicode 相关的警告的基类。</p>
<p><em>exception</em> <code>EncodingWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#EncodingWarning" title="永久链接至目标"></a></p>
<p>与编码格式相关的警告的基类。</p>
<p>请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io-encoding-warning">选择性的 EncodingWarning</a> 来了解详情。</p>
<p>3.10 新版功能.</p>
<p><em>exception</em> <code>BytesWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#BytesWarning" title="永久链接至目标"></a></p>
<p>与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 相关的警告的基类。</p>
<p><em>exception</em> <code>ResourceWarning</code><a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ResourceWarning" title="永久链接至目标"></a></p>
<p>资源使用相关警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 时会显示此警告。</p>
<p>3.2 新版功能.</p>
<h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p>内置异常的类层级结构如下：</p>
<p>BaseException<br> +– SystemExit<br> +– KeyboardInterrupt<br> +– GeneratorExit<br> +– Exception<br>      +– StopIteration<br>      +– StopAsyncIteration<br>      +– ArithmeticError<br>      |    +– FloatingPointError<br>      |    +– OverflowError<br>      |    +– ZeroDivisionError<br>      +– AssertionError<br>      +– AttributeError<br>      +– BufferError<br>      +– EOFError<br>      +– ImportError<br>      |    +– ModuleNotFoundError<br>      +– LookupError<br>      |    +– IndexError<br>      |    +– KeyError<br>      +– MemoryError<br>      +– NameError<br>      |    +– UnboundLocalError<br>      +– OSError<br>      |    +– BlockingIOError<br>      |    +– ChildProcessError<br>      |    +– ConnectionError<br>      |    |    +– BrokenPipeError<br>      |    |    +– ConnectionAbortedError<br>      |    |    +– ConnectionRefusedError<br>      |    |    +– ConnectionResetError<br>      |    +– FileExistsError<br>      |    +– FileNotFoundError<br>      |    +– InterruptedError<br>      |    +– IsADirectoryError<br>      |    +– NotADirectoryError<br>      |    +– PermissionError<br>      |    +– ProcessLookupError<br>      |    +– TimeoutError<br>      +– ReferenceError<br>      +– RuntimeError<br>      |    +– NotImplementedError<br>      |    +– RecursionError<br>      +– SyntaxError<br>      |    +– IndentationError<br>      |         +– TabError<br>      +– SystemError<br>      +– TypeError<br>      +– ValueError<br>      |    +– UnicodeError<br>      |         +– UnicodeDecodeError<br>      |         +– UnicodeEncodeError<br>      |         +– UnicodeTranslateError<br>      +– Warning<br>           +– DeprecationWarning<br>           +– PendingDeprecationWarning<br>           +– RuntimeWarning<br>           +– SyntaxWarning<br>           +– UserWarning<br>           +– FutureWarning<br>           +– ImportWarning<br>           +– UnicodeWarning<br>           +– BytesWarning<br>           +– EncodingWarning<br>           +– ResourceWarning</p>
]]></content>
      <tags>
        <tag>Python Python标准库 异常上下文 从内置异常继承 基类 具体异常 警告 异常层次结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用中括号, 里面书写各个元素, 数据类型不限制</span></span><br><span class="line">name_list = [<span class="string">&quot;张三&quot;</span>, <span class="number">1995</span>, <span class="number">100</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list) <span class="comment"># 输出为[&quot;张三&quot;, 1995, 100]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_list)) <span class="comment"># 输出为 &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套列表</span></span><br><span class="line">num = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出为[[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num)) <span class="comment"># 输出为 &lt;class &#x27;list&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="下标索引"><a href="#下标索引" class="headerlink" title="下标索引"></a>下标索引</h4><p><strong>正向索引</strong><br>![[Pasted image 20231217222426.png]]</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正向索引从0开始, 依次+1</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">0</span>])  <span class="comment"># 输出1</span></span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">1</span>])  <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">2</span>])  <span class="comment"># 输出3</span></span><br><span class="line"><span class="comment"># 错误示范, 超出范围报错</span></span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<br>

<p><strong>反向索引</strong><br>![[Pasted image 20231217222702.png]]<br>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反向索引从-1开始, 依次-1</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(num[-<span class="number">1</span>])  <span class="comment"># 输出3</span></span><br><span class="line"><span class="built_in">print</span>(num[-<span class="number">2</span>])  <span class="comment"># 输出2</span></span><br><span class="line"><span class="built_in">print</span>(num[-<span class="number">3</span>])  <span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure>
<br>

<p><strong>嵌套列表索引</strong><br>![[Pasted image 20231217222902.png]]<br>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反向索引从-1开始, 依次-1</span></span><br><span class="line">num = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">1</span>][<span class="number">2</span>])  <span class="comment"># 输出6</span></span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">2</span>][<span class="number">1</span>])  <span class="comment"># 输出8</span></span><br><span class="line"><span class="built_in">print</span>(num[-<span class="number">2</span>][-<span class="number">2</span>])  <span class="comment"># 输出5</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="列表方法"><a href="#列表方法" class="headerlink" title="列表方法"></a>列表方法</h4><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法如下</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">index = num.index(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(index) <span class="comment"># 输出结果为1</span></span><br><span class="line"><span class="comment"># 查询的结果是第一个, 且为正向索引查询</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法如下</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(num[<span class="number">2</span>]) <span class="comment"># 输出结果100</span></span><br><span class="line"><span class="comment"># 正向反向索引都可以正常赋值</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num.insert(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出[1, &#x27;A&#x27;, 2, 3, 2]</span></span><br><span class="line">num.insert(-<span class="number">1</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出[1, &#x27;A&#x27;, 2, 3, &#x27;B&#x27;, 2]</span></span><br><span class="line"><span class="comment"># 可以发现insert方法会在指定索引的位置插入新元素</span></span><br><span class="line"><span class="comment"># 并且将其他元素位置挪后或是靠前</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num.append(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出[1, 2, 3, 2, &#x27;A&#x27;]</span></span><br><span class="line">num.append(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出[1, 2, 3, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line"><span class="comment"># 固定在正向索引最后的位置增加一个新元素</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以在正向索引的最后追加一批元素</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num.extend([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出[1, 2, 3, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># num.exten(4) 语法错误</span></span><br><span class="line"></span><br><span class="line">num.extend([<span class="number">2</span>]) <span class="comment">#也可以和append一样追加一个元素</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># [1, 2, 3, 2, 3, 4, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="del和pop"><a href="#del和pop" class="headerlink" title="del和pop"></a>del和pop</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法如下, 删除指定索引的元素</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">del</span> num[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># [1, 3, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定索引的元素, 并且可以将删除的元素赋值于变量</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num1 = num.pop(<span class="number">2</span>) <span class="comment"># [1, 3, 2]</span></span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># [1, 2, 2]</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除指定的元素, 并非按索引来删除</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># [1, 3, 2]</span></span><br><span class="line"><span class="comment"># 只会删除遇到的第一个元素.</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清空列表的所有元素</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">num.clear()</span><br><span class="line"><span class="built_in">print</span>(num) <span class="comment"># 输出空值[]</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计列表中有多少个相同的元素</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">count = num.count(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(count) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h5 id="len"><a href="#len" class="headerlink" title="len"></a>len</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计列表中总共有多少个元素</span></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(num)) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python基础知识 列表 下标索引 列表方法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h4><p>在程序运行时, 能储存计算结果或能表示值的抽象概念.<br>简单来说, 变量就是在程序运行时, 记录数据用的</p>
<h4 id="变量的定义格式"><a href="#变量的定义格式" class="headerlink" title="变量的定义格式"></a>变量的定义格式</h4><p>变量名称 &#x3D; 变量的值</p>
<p><strong>实际展示如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个变量, 用来记录钱包余额</span></span><br><span class="line">money = <span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;钱包还有: &quot;</span>, money, <span class="string">&quot;元&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果为</strong>: </p>
<blockquote>
<p>钱包还有: 50元</p>
</blockquote>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 变量</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h4 id="操作总结"><a href="#操作总结" class="headerlink" title="操作总结"></a>操作总结</h4><p>![[Pasted image 20231223134721.png]]</p>
<p><br><br><br><br><br></p>
<hr>
<h4 id="字典定义"><a href="#字典定义" class="headerlink" title="字典定义"></a>字典定义</h4><p>字典的定义, 和集合一样使用{}, 不过存储的元素是一个个的: 键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义字典字面量</span></span><br><span class="line">&#123;key: value, key1: value, key2: value&#125;</span><br><span class="line"><span class="comment"># 定义字典变量</span></span><br><span class="line">my_dict = &#123;key: value, key1: value, key2: value&#125;</span><br><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">my_dict = &#123;&#125;    <span class="comment"># 方式1</span></span><br><span class="line">my_dict = <span class="built_in">dict</span>()    <span class="comment"># 方式2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义重复key的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">12</span>, <span class="string">&quot;B&quot;</span>: <span class="number">16</span>, <span class="string">&quot;C&quot;</span>: <span class="number">19</span>, <span class="string">&quot;A&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_dict)</span><br><span class="line"><span class="comment"># 结果: 后面重复的key覆盖了前面的key值</span></span><br><span class="line"><span class="comment"># &#123;&#x27;A&#x27;: 17, &#x27;B&#x27;: 16, &#x27;C&#x27;: 19&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从字典中获取value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">12</span>, <span class="string">&quot;B&quot;</span>: <span class="number">16</span>, <span class="string">&quot;C&quot;</span>: <span class="number">19</span>, <span class="string">&quot;A&quot;</span>, <span class="number">17</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_dict[<span class="string">&quot;B&quot;</span>])</span><br><span class="line"><span class="comment"># 结果: 16</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义嵌套字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;  </span><br><span class="line">    <span class="string">&quot;A&quot;</span>: &#123;  </span><br><span class="line">        <span class="string">&quot;语文&quot;</span>: <span class="number">77</span>, <span class="string">&quot;数学&quot;</span>: <span class="number">88</span>, <span class="string">&quot;英语&quot;</span>: <span class="number">99</span>  </span><br><span class="line">    &#125;, <span class="string">&quot;B&quot;</span>: &#123;  </span><br><span class="line">        <span class="string">&quot;语文&quot;</span>: <span class="number">11</span>, <span class="string">&quot;数学&quot;</span>: <span class="number">22</span>, <span class="string">&quot;英语&quot;</span>: <span class="number">33</span>  </span><br><span class="line">    &#125;, <span class="string">&quot;C&quot;</span>: &#123;  </span><br><span class="line">        <span class="string">&quot;语文&quot;</span>: <span class="number">55</span>, <span class="string">&quot;数学&quot;</span>: <span class="number">66</span>, <span class="string">&quot;英语&quot;</span>: <span class="number">77</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;学生A的语文成绩是: <span class="subst">&#123;my_dict[<span class="string">&quot;A&quot;</span>][<span class="string">&quot;语文&quot;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 学生A的语文成绩是: 77</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="增加与更新"><a href="#增加与更新" class="headerlink" title="增加与更新"></a>增加与更新</h4><p>语法: 字典[key] &#x3D; value, 结果: 字典被修改, 新增了元素<br>语法: 字典[kye] &#x3D; value, 结果: 字典被修改, 元素被更新</p>
<div style = "color: red"><b>key不可以重复, 所以对已存在的key赋值就是更新value值</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">44</span>, <span class="string">&quot;B&quot;</span>: <span class="number">55</span>, <span class="string">&quot;C&quot;</span>: <span class="number">77</span>, <span class="string">&quot;D&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="comment"># 新增元素, D的考试成绩99</span></span><br><span class="line">stu_score[<span class="string">&quot;D&quot;</span>] = <span class="number">99</span></span><br><span class="line"><span class="built_in">print</span>(stu_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># &#123;&#x27;A&#x27;: 44, &#x27;B&#x27;: 55, &#x27;C&#x27;: 77, &#x27;D&#x27;: 99&#125;</span></span><br><span class="line"></span><br><span class="line">stu_score[<span class="string">&quot;D&quot;</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(stu_score)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># &#123;&#x27;A&#x27;: 44, &#x27;B&#x27;: 55, &#x27;C&#x27;: 77, &#x27;D&#x27;: 100&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法pop"><a href="#方法pop" class="headerlink" title="方法pop"></a>方法pop</h4><p>语法: 字典.pop(key), 结果: 获得指定key的value, 同时字典被修改, 指定key的数据被删除. <strong>返回值是被删除的值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">44</span>, <span class="string">&quot;B&quot;</span>: <span class="number">55</span>, <span class="string">&quot;C&quot;</span>: <span class="number">77</span>, <span class="string">&quot;D&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">value = stu_score.pop(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"><span class="built_in">print</span>(stu_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 99</span></span><br><span class="line"><span class="comment"># &#123;&#x27;A&#x27;: 44, &#x27;B&#x27;: 55, &#x27;C&#x27;: 77&#125;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法clear"><a href="#方法clear" class="headerlink" title="方法clear"></a>方法clear</h4><p>语法: 字典.clear, 结果: 字典被修改, 元素被清空. <strong>返回值空</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">44</span>, <span class="string">&quot;B&quot;</span>: <span class="number">55</span>, <span class="string">&quot;C&quot;</span>: <span class="number">77</span>, <span class="string">&quot;D&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">stu_score.clear()</span><br><span class="line"><span class="built_in">print</span>(stu_score)</span><br><span class="line"><span class="comment"># 结果  &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="方法keys"><a href="#方法keys" class="headerlink" title="方法keys"></a>方法keys</h4><p>语法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">44</span>, <span class="string">&quot;B&quot;</span>: <span class="number">55</span>, <span class="string">&quot;C&quot;</span>: <span class="number">77</span>, <span class="string">&quot;D&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line">my_list = stu_score.keys()</span><br><span class="line"><span class="built_in">print</span>(stu_score)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(stu_score))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># &#123;&#x27;A&#x27;: 44, &#x27;B&#x27;: 55, &#x27;C&#x27;: 77, &#x27;D&#x27;: 99&#125;</span></span><br><span class="line"><span class="comment"># dict_keys([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;])</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;dict_keys&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法len"><a href="#方法len" class="headerlink" title="方法len"></a>方法len</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">44</span>, <span class="string">&quot;B&quot;</span>: <span class="number">55</span>, <span class="string">&quot;C&quot;</span>: <span class="number">77</span>, <span class="string">&quot;D&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典中的元素数量有<span class="subst">&#123;<span class="built_in">len</span>(stu_score)&#125;</span>个&quot;</span>)</span><br><span class="line"><span class="comment"># 结果  </span></span><br><span class="line"><span class="comment"># 字典中的元素数量有4个</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;<span class="string">&quot;A&quot;</span>: <span class="number">44</span>, <span class="string">&quot;B&quot;</span>: <span class="number">55</span>, <span class="string">&quot;C&quot;</span>: <span class="number">77</span>, <span class="string">&quot;D&quot;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> stu_score.keys:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;字典的key是: <span class="subst">&#123;key&#125;</span>&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;字典的value是: <span class="subst">&#123;stu_score[key]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 字典的key是: A 字典的value是: 44</span></span><br><span class="line"><span class="comment"># 字典的key是: B 字典的value是: 55</span></span><br><span class="line"><span class="comment"># 字典的key是: C 字典的value是: 77</span></span><br><span class="line"><span class="comment"># 字典的key是: D 字典的value是: 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> stu_score:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;字典的key是: <span class="subst">&#123;key&#125;</span>&quot;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;字典的value是: <span class="subst">&#123;stu_score[key]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 字典的key是: A 字典的value是: 44</span></span><br><span class="line"><span class="comment"># 字典的key是: B 字典的value是: 55</span></span><br><span class="line"><span class="comment"># 字典的key是: C 字典的value是: 77</span></span><br><span class="line"><span class="comment"># 字典的key是: D 字典的value是: 99</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>![[Pasted image 20231223135055.png]]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cp_list = &#123;  </span><br><span class="line"><span class="string">&quot;王力鸿&quot;</span>: &#123;  </span><br><span class="line">    <span class="string">&quot;部门&quot;</span>: <span class="string">&quot;科技部&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;工资&quot;</span>: <span class="number">3000</span>,  </span><br><span class="line">    <span class="string">&quot;级别&quot;</span>: <span class="number">1</span>  </span><br><span class="line">&#125;,  </span><br><span class="line"><span class="string">&quot;周杰轮&quot;</span> :&#123;  </span><br><span class="line">    <span class="string">&quot;部门&quot;</span>: <span class="string">&quot;市场部&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;工资&quot;</span>: <span class="number">5000</span>,  </span><br><span class="line">    <span class="string">&quot;级别&quot;</span>: <span class="number">2</span>  </span><br><span class="line">&#125;,  </span><br><span class="line"><span class="string">&quot;林俊节&quot;</span>: &#123;  </span><br><span class="line">    <span class="string">&quot;部门&quot;</span>: <span class="string">&quot;市场部&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;工资&quot;</span>: <span class="number">7000</span>,  </span><br><span class="line">    <span class="string">&quot;级别&quot;</span>: <span class="number">3</span>  </span><br><span class="line">&#125;,  </span><br><span class="line"><span class="string">&quot;张学油&quot;</span>: &#123;  </span><br><span class="line">    <span class="string">&quot;部门&quot;</span>: <span class="string">&quot;科技部&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;工资&quot;</span>: <span class="number">4000</span>,  </span><br><span class="line">    <span class="string">&quot;级别&quot;</span>: <span class="number">1</span>  </span><br><span class="line">&#125;,  </span><br><span class="line"><span class="string">&quot;刘德滑&quot;</span>: &#123;  </span><br><span class="line">    <span class="string">&quot;部门&quot;</span>: <span class="string">&quot;市场部&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;工资&quot;</span>: <span class="number">6000</span>,  </span><br><span class="line">    <span class="string">&quot;级别&quot;</span>: <span class="number">2</span>  </span><br><span class="line">&#125;&#125;  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cp_list:  </span><br><span class="line">    <span class="keyword">if</span> cp_list[i][<span class="string">&quot;级别&quot;</span>] == <span class="number">1</span>:  </span><br><span class="line">        cp_list[i][<span class="string">&quot;工资&quot;</span>] += <span class="number">1000</span>  </span><br><span class="line">        cp_list[i][<span class="string">&quot;级别&quot;</span>] += <span class="number">1</span>  </span><br><span class="line"><span class="built_in">print</span>(cp_list)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>{‘王力鸿’: {‘部门’: ‘科技部’, ‘工资’: 4000, ‘级别’: 2}, ‘周杰轮’: {‘部门’: ‘市场部’, ‘工资’: 5000, ‘级别’: 2}, ‘林俊节’: {‘部门’: ‘市场部’, ‘工资’: 7000, ‘级别’: 3}, ‘张学油’: {‘部门’: ‘科技部’, ‘工资’: 5000, ‘级别’: 2}, ‘刘德滑’: {‘部门’: ‘市场部’, ‘工资’: 6000, ‘级别’: 2}}</p>
</blockquote>
<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python 字典定义</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h4 id="字符串3种定义方式"><a href="#字符串3种定义方式" class="headerlink" title="字符串3种定义方式"></a>字符串3种定义方式</h4><p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串在Python中有以下定义方式:</span></span><br><span class="line">name = <span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">name = <span class="string">&quot;AAA&quot;</span></span><br><span class="line">name = <span class="string">&quot;&quot;&quot;AAA</span></span><br><span class="line"><span class="string">BBB</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 3对双引号可以多行, 和多行注释的写法一样</span></span><br><span class="line"><span class="comment"># 使用变量接收, 就是字符串</span></span><br><span class="line"><span class="comment"># 不使用变量接收, 就是多行注释</span></span><br></pre></td></tr></table></figure>
<p><strong>引号嵌套</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;&quot;AAA&quot;&#x27;</span></span><br><span class="line">name2 = <span class="string">&quot;&#x27;AAA&#x27;&quot;</span></span><br><span class="line">name3 = <span class="string">&quot;\&quot;AAA\&quot;&quot;</span></span><br><span class="line">name4 = <span class="string">&#x27;\&#x27;AAA\&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name1)</span><br><span class="line"><span class="built_in">print</span>(name2)</span><br><span class="line"><span class="built_in">print</span>(name3)</span><br><span class="line"><span class="built_in">print</span>(name4)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>“AAA”<br>‘AAA’<br>“AAA”<br>‘AAA’</p>
</blockquote>
<h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h4><p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用+号来连接两个字符串</span></span><br><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我的名字是&quot;</span> + name + <span class="string">&quot;, 我又犯罪了&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>我的名字是张三, 我又犯罪了</p>
</blockquote>
<p><strong>错误示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">25</span></span><br><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name + age)</span><br></pre></td></tr></table></figure>
<p><strong>输出报错, 数据类型不符</strong></p>
<blockquote>
<p>TypeError: can only concatenate str (not “int”) to str</p>
</blockquote>
<h4 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h4><p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">age = <span class="number">50</span></span><br><span class="line">deposit = <span class="number">500.5555</span></span><br><span class="line">message = <span class="string">&quot;我叫%s, 已经%d岁了, 目前有存款%f元&quot;</span> % (name, age, deposit)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>我叫张三, 已经50岁了, 目前有存款500.555500元</p>
</blockquote>
<h4 id="格式化的精度控制"><a href="#格式化的精度控制" class="headerlink" title="格式化的精度控制"></a>格式化的精度控制</h4><p>我们可以使用辅助符号”m.n”来控制数据的宽度和精度</p>
<ul>
<li>m,  控制宽度, 要求是数字(很少使用), 设置的宽度小于数字自身, 不生效</li>
<li>n, 控制小数点精度, 要求是数字, 会进行小数的四舍五入</li>
</ul>
<p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">age = <span class="number">50</span></span><br><span class="line">deposit = <span class="number">500.5555</span></span><br><span class="line">message = <span class="string">&quot;我叫%s, 已经%d岁了, 目前有存款%.2f元&quot;</span> % (name, age, deposit)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>我叫张三, 已经50岁了, 目前有存款500.56元</p>
</blockquote>
<h4 id="快捷格式化"><a href="#快捷格式化" class="headerlink" title="快捷格式化"></a>快捷格式化</h4><p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">age = <span class="number">50</span></span><br><span class="line">deposit = <span class="number">500.5555</span></span><br><span class="line"><span class="comment"># f即是fomat格式化的英文首字母</span></span><br><span class="line">message = <span class="string">f&quot;我叫<span class="subst">&#123;name&#125;</span>, 已经<span class="subst">&#123;age&#125;</span>岁了, 目前有存款<span class="subst">&#123;deposit&#125;</span>元&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>我叫张三, 已经50岁了, 目前有存款500.5555元</p>
</blockquote>
<h4 id="表达式格式化"><a href="#表达式格式化" class="headerlink" title="表达式格式化"></a>表达式格式化</h4><p>表达式: 一条具有明确执行结果的代码语句</p>
<p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">company_name = <span class="string">&quot;AAA&quot;</span>  </span><br><span class="line">stock_code = <span class="string">&quot;003032&quot;</span>  </span><br><span class="line">stock_price = <span class="number">19.99</span>  </span><br><span class="line">stock_price_daily_growth_factor = <span class="number">1.2</span>   <span class="comment"># 股票增长系数  </span></span><br><span class="line">growth_days = <span class="number">7</span> <span class="comment"># 股票增长天数  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;公司: <span class="subst">&#123;company_name&#125;</span>, 股票代码: <span class="subst">&#123;stock_code&#125;</span>, 当前股价: <span class="subst">&#123;stock_price&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每日的增长系数: %s, 经过%d天的增长之后, 股价达到了: %.2f&quot;</span> % (stock_price_daily_growth_factor, growth_days, stock_price * stock_price_daily_growth_factor **growth_days))</span><br><span class="line"><span class="comment"># 表达式可以直接格式化占位显示</span></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>公司: AAA, 股票代码: 003032, 当前股价: 19.99<br>每日的增长系数: 1.2, 经过7天的增长之后, 股价达到了: 71.63</p>
</blockquote>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 字符串</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%AD%97%E7%AC%A6%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h4 id="操作汇总"><a href="#操作汇总" class="headerlink" title="操作汇总"></a>操作汇总</h4><p>![[Pasted image 20231223105056.png]]<br><br><br><br><br><br></p>
<hr>
<h4 id="方法index"><a href="#方法index" class="headerlink" title="方法index"></a>方法index</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;hello world i am&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;在字符串<span class="subst">&#123;my_str&#125;</span>中查找world, 其起始下标是: <span class="subst">&#123;my_str.index(<span class="string">&quot;world&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是:　在字符串hello world i am中查找world, 其起始下标是: 6</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="方法replace"><a href="#方法replace" class="headerlink" title="方法replace"></a>方法replace</h4><div style = "color: red"><b>语法: 字符串.replace(字符串1, 字符串2)</b></div>
<div style = "color: red"><b>功能: 将字符串内的全部: 字符串1, 替换为字符串2</b></div>
<div style = "color: red"><b>注意: 不是修改字符串本身, 而是得到一个新字符串</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;hello world i am python, think , thank&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;将字符串<span class="subst">&#123;my_str&#125;</span>中的th替换新字符程序的结果是: <span class="subst">&#123;my_str.replace(<span class="string">&quot;th&quot;</span>, <span class="string">&quot;程序&quot;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果是</p>
<blockquote>
<p>将字符串hello world i am python, think , thank中th替换新字符程序的结果是: hello world i am py程序on, 程序ink , 程序ank<br><br><br><br><br><br></p>
</blockquote>
<hr>
<h4 id="方法split"><a href="#方法split" class="headerlink" title="方法split"></a>方法split</h4><div style = "color: red"><b>语法: 字符串.split(分割字符串)</b></div>
<div style = "color: red"><b>功能: 按照指定的分隔符字符串, 将字符串划分为多个字符串, 并存入列表对象中</b></div>
<div style = "color: red"><b>注意: 字符串本身不变, 而是得到了一个列表对象</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;hello, world, I, am, python&quot;</span></span><br><span class="line"><span class="comment"># 按照分隔符&quot;,&quot;来分割的结果是</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;原字符串<span class="subst">&#123;my_str&#125;</span>, 切割后列表<span class="subst">&#123;my_str.split(<span class="string">&quot;,&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_str.split(<span class="string">&quot;,&quot;</span>)))</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>原字符串hello, world, I, am, python, 切割后列表[‘hello’, ‘ world’, ‘ I’, ‘ am’, ‘ python’]<br>&lt;class ‘list’&gt;</p>
</blockquote>
<p><br><br><br><br><br></p>
<hr>
<h4 id="方法strip"><a href="#方法strip" class="headerlink" title="方法strip"></a>方法strip</h4><p>字符串的规整操作1(去除前后空格以及换行符)<br>语法: 字符串.strip()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;  hello world  \n&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_str.strip())</span><br><span class="line"><span class="comment"># 结果是: hello world, 前后空格加上换行符都去除了</span></span><br></pre></td></tr></table></figure>

<p>字符串的规整操作2(去除前后指定字符串)<br>语法: 字符串.strip(字符串)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;322   Hello World2   223&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_str.strip(<span class="string">&quot;23&quot;</span>))</span><br><span class="line"><span class="comment"># 结果是:    Hello World2   </span></span><br><span class="line"><span class="comment"># 还有空格, 但是23, 32都已经去除了. 去除是去除前后相连的字符串中的相同字符. 并不是字符串23一起去除</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="方法count"><a href="#方法count" class="headerlink" title="方法count"></a>方法count</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;l字符的数量有<span class="subst">&#123;my_str.count(<span class="string">&quot;l&quot;</span>)&#125;</span>个&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是: l字符的数量有3个</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="方法len"><a href="#方法len" class="headerlink" title="方法len"></a>方法len</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符的长度是<span class="subst">&#123;<span class="built_in">len</span>(my_str)&#125;</span>个&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是: 字符的长度是11个</span></span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br></p>
<hr>
<h4 id="字符串大小比较"><a href="#字符串大小比较" class="headerlink" title="字符串大小比较"></a>字符串大小比较</h4><p>![[Pasted image 20231223144235.png]]</p>
<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python 字符容器 字符串 replace strip split</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%AD%97%E9%9D%A2%E9%87%8F/</url>
    <content><![CDATA[<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p><strong>字面量</strong>: 在代码中, 被写下来的固定的值, 称之为字面量<br>Python中常见的值有以下6种:<br>![[Pasted image 20231214132812.png]]</p>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 字面量</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>update_time_20231225 对象 class 构造方法 魔术方法 封装 继承 单继承 多继承 复写父类 多态</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">10</span>  </span><br><span class="line">num2 = <span class="number">15</span>  </span><br><span class="line">str1 = <span class="string">&quot;AA&quot;</span>  </span><br><span class="line">str2 = <span class="string">&quot;CC&quot;</span>  </span><br><span class="line">str3 = <span class="string">&quot;BB&quot;</span>  </span><br><span class="line">str4 = <span class="string">&quot;AABB&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 == 15的结果是: <span class="subst">&#123;num1 == num2&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 != 15的结果是: <span class="subst">&#123;num1 != num2&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 &gt; 15的结果是: <span class="subst">&#123;num1 &gt; num2&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;10 &lt; 15的结果是: <span class="subst">&#123;num1 &lt; num2&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;AA == CC的结果是: <span class="subst">&#123;str1 == str2&#125;</span>&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;AA+BB == AABB的结果是: <span class="subst">&#123;str1+str3 == str4&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<blockquote>
<p>10 &#x3D;&#x3D; 15的结果是: False<br>10 !&#x3D; 15的结果是: True<br>10 &gt; 15的结果是: False<br>10 &lt; 15的结果是: True<br>AA &#x3D;&#x3D; CC的结果是: False<br>AA+BB &#x3D;&#x3D; AABB的结果是: True</p>
</blockquote>
<hr>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="序列定义"><a href="#序列定义" class="headerlink" title="序列定义"></a>序列定义</h4><p>序列是指: 内容连续, 有序, 可使用下标索引的一类数据容器</p>
<div style = "color: red"><b>列表, 元组, 字符串, 均可以视为序列</b></div>


<p><br><br><br><br><br></p>
<hr>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>序列支持切片, 即: 列表, 元组, 字符串, 均支持进行切片操作<br>切片: 从一个序列中, 取出一个子序列**(新)**</p>
<p>语法: 序列[起始下标:结束下标:步长]<br>表示从序列中, 从指定位置开始, 依次去除元素, 到指定位置结束, 得到一个<strong>新序列</strong>:</p>
<ul>
<li>起始下表表示从何处开始, 可以留空, 留空视作从头开始</li>
<li>结束下标(不含)表示何处结束, 可以留空, 留空视作截取到结尾</li>
<li>步长表示, 依次取元素的间隔<ul>
<li>步长1表示, 一个个取元素</li>
<li>步长2表示, 每次跳过1个元素取</li>
<li>步长N表示, 每次跳过N-1个元素取</li>
<li>步长为负数表示, 反向取(注意, 起始下标和结束下标也要反向标记)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;my_str[<span class="number">1</span>:<span class="number">4</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果: ell</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;my_str[-<span class="number">4</span>:-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果: orl</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;my_str[-<span class="number">1</span>:-<span class="number">4</span>:-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果: dlr</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;my_str[::-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果是反转序列: dlroWolleH</span></span><br><span class="line"><span class="comment"># 其余序列也是同样的表现</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python 序列 切片</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%88%A4%E6%96%ADif%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h3 id="语句if"><a href="#语句if" class="headerlink" title="语句if"></a>语句if</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入身高&quot;</span>))</span><br><span class="line">vip_level = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入等级&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> height &gt; <span class="number">100</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> vip_level &gt;<span class="number">3</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"><span class="comment"># 身高大于100 或 VIP等级大于3, 就是A, 其余情况 B</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h3 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  random  </span><br><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">10</span>)  </span><br><span class="line">times = <span class="number">1</span>  </span><br><span class="line">guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入你要猜测的数字&quot;</span>))  </span><br><span class="line"><span class="keyword">if</span> guess_num == num:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恭喜你, 第%d次就猜对了&quot;</span> % times)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="keyword">if</span> guess_num &gt; num:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;过大&quot;</span>)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;过小&quot;</span>)  </span><br><span class="line">    <span class="comment"># 第二次猜测  </span></span><br><span class="line">    times += <span class="number">1</span>  </span><br><span class="line">    guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入你要猜测的数字&quot;</span>))  </span><br><span class="line">    <span class="keyword">if</span> guess_num == num:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;恭喜你, 第%d次就猜对了&quot;</span> % times)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">if</span> guess_num &gt; num:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;过大&quot;</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;过小&quot;</span>)  </span><br><span class="line">		<span class="comment"># 第三次猜测</span></span><br><span class="line">        times += <span class="number">1</span>  </span><br><span class="line">        guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入你要猜测的数字&quot;</span>))  </span><br><span class="line">        <span class="keyword">if</span> guess_num == num:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;恭喜你, 第%d次就猜对了&quot;</span> % times)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">if</span> guess_num &gt; num:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;过大&quot;</span>)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;很抱歉, 你猜了%d次也没有猜中&quot;</span> % times)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;正确答案是: %d&quot;</span> % num)  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;过小&quot;</span>)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;很抱歉, 你猜了%d次也没有猜中&quot;</span> % times)  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;正确答案是: %d&quot;</span> % num)</span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python if</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%BE%AA%E7%8E%AFfor/</url>
    <content><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>for循环是一种轮询机制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法如下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">for 临时变量 in 待处理数据集</span></span><br><span class="line"><span class="string">	循环满足条件是执行的代码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 无法定义循环条件, 只能被动取出数据处理</span></span><br><span class="line"><span class="string">2. 循环内的语句需要有Tab缩进</span></span><br><span class="line"><span class="string">3. 待处理数据集, 严格称之为: 序列类型</span></span><br><span class="line"><span class="string">4. 序列类型包含: 字符串, 列表, 元组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="语句range"><a href="#语句range" class="headerlink" title="语句range"></a>语句range</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 语法1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">range(num)</span></span><br><span class="line"><span class="string">获取一个从零开始, 到num结束的数字序列(不含num本身)</span></span><br><span class="line"><span class="string">例如: range(5)</span></span><br><span class="line"><span class="string">则取得的数据是: [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">range(num1, num2, step)</span></span><br><span class="line"><span class="string">获取一个从num1开始, 到num2结束的数字序列(不含num2本身)</span></span><br><span class="line"><span class="string">数字之间的步进量, 以step为准, 不传参的情况下, 默认为1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">例如: range(5, 15, 2)</span></span><br><span class="line"><span class="string">取得的数据是: [5, 7, 9, 11, 13]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也可以反着来: range(15, 5, -2)</span></span><br><span class="line"><span class="string">取得的数据是: [15, 13, 11, 9, 7]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="临时变量作用域"><a href="#临时变量作用域" class="headerlink" title="临时变量作用域"></a>临时变量作用域</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># for循环语法</span></span><br><span class="line"><span class="string">for 临时变量 in 序列类型</span></span><br><span class="line"><span class="string">	循环满足条件时执行的代码</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">1. 临时变量, 在编程规范上, 作用域只限定在for循环内部</span></span><br><span class="line"><span class="string">2. for循环外访问临时变量也是可以成功访问的</span></span><br><span class="line"><span class="string">3. 但是编程规范上, 是不允许, 不建议这么做的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">    <span class="keyword">continue</span>  </span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 结果输出为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例2</span></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 结果输出为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量i被for循环内临时变量覆盖, 且可以再次被外部访问.</span></span><br><span class="line"><span class="comment"># 如果一定要访问临时变量, 可以在外部先声明同名全局变量</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="乘法表"><a href="#乘法表" class="headerlink" title="乘法表"></a>乘法表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>x<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i*j&#125;</span> \t&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>![[Pasted image 20231217212803.png]]</p>
</blockquote>
<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python基础知识 循环for</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5while/</url>
    <content><![CDATA[<h3 id="语句while"><a href="#语句while" class="headerlink" title="语句while"></a>语句while</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 累加到100</span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    <span class="built_in">sum</span> += i  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h3 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  random  </span><br><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">100</span>)  </span><br><span class="line">times = <span class="number">0</span>  </span><br><span class="line">flag = <span class="literal">True</span>  </span><br><span class="line"><span class="keyword">while</span> flag:  </span><br><span class="line">    guess_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你猜的数字: &quot;</span>))  </span><br><span class="line">    times += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">if</span> guess_num == num:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;恭喜你%d次就猜对了正确答案(%d)&quot;</span> % (times, num))  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">if</span> guess_num &gt; num:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;过大&quot;</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;过小&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h3 id="乘法表"><a href="#乘法表" class="headerlink" title="乘法表"></a>乘法表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span>  </span><br><span class="line"><span class="comment"># 用i控制列, 用j控制行  </span></span><br><span class="line"><span class="comment"># 第一行打印一个, 第二行打印2个  </span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">9</span>:  </span><br><span class="line">    j = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> j &lt;= i:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%d * %d = %d \t&quot;</span> % (j, i, i * j), end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">        j += <span class="number">1</span>  </span><br><span class="line">    <span class="built_in">print</span>()  </span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<blockquote>
<p>![[Pasted image 20231216204923.png]]</p>
</blockquote>
<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 循环语句 while</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>当我们的程序遇到了BUG, 会有两种情况<br>1, 整个程序因为一个BUG停止运行<br>2, 对BUG进行提醒, 整个程序继续运行<br>在真实工作中, 肯定不能因为一个小的BUG就让整个程序全部崩溃, 而是希望达到第2种情况, 这样就需要捕获异常了.</p>
<p>捕获异常的作用在于: 提前假设某处会出现异常, 做好提前准备, 当真的出现异常的时候, 可以有后续手段. </p>
<p>基本语法:<br>try: 可能发生错误的代码<br>except: 如果出现异常执行的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获全部异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获指定异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	name += <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获多个异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	name += <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常 或者 除以零的异常错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获所有异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	name += <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有异常else</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	name += <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;没有异常&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后finally</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	name += <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;出现了变量未定义的异常&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;没有异常&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;我就是要执行&quot;</span>)</span><br></pre></td></tr></table></figure>


<p><br><br><br><br><br></p>
<hr>
<h4 id="异常传递性"><a href="#异常传递性" class="headerlink" title="异常传递性"></a>异常传递性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func01</span>():  <span class="comment"># 异常在func01中没有被捕获</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是func01开始&quot;</span>)</span><br><span class="line">	num = <span class="number">1</span> /<span class="number">0</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是func01结尾&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func02</span>(): <span class="comment"># 异常在func02中没有被捕获</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是func02开始&quot;</span>)</span><br><span class="line">	func01()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是func02结尾&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  <span class="comment"># 异常在main中被捕获</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		func02()</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">		<span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>


<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>update_time_20231224 了解异常 异常捕获 异常的传递性 try except</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>![[Pasted image 20231223135634.png]]</p>
<p><br><br><br><br><br></p>
<hr>
<h4 id="特点对比"><a href="#特点对比" class="headerlink" title="特点对比"></a>特点对比</h4><p>![[Pasted image 20231223135654.png]]</p>
<p><br><br><br><br><br></p>
<hr>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>![[Pasted image 20231223135807.png]]<br><br><br><br><br><br></p>
<hr>
<h4 id="通用操作-遍历"><a href="#通用操作-遍历" class="headerlink" title="通用操作-遍历"></a>通用操作-遍历</h4><p>![[Pasted image 20231223135918.png]]<br><br><br><br><br><br></p>
<hr>
<h4 id="通用统计"><a href="#通用统计" class="headerlink" title="通用统计"></a>通用统计</h4><p>![[Pasted image 20231223140131.png]]<br><br><br><br><br><br></p>
<hr>
<h4 id="通用功能"><a href="#通用功能" class="headerlink" title="通用功能"></a>通用功能</h4><p>![[Pasted image 20231223143431.png]]</p>
<h5 id="容器转列表"><a href="#容器转列表" class="headerlink" title="容器转列表"></a>容器转列表</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">my_str = <span class="string">&quot;abcdefa&quot;</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_dict = &#123;<span class="string">&quot;key1&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;key2&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;key3&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表转列表的结果是: \t\t<span class="subst">&#123;<span class="built_in">list</span>(my_list)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组转列表的结果是: \t\t<span class="subst">&#123;<span class="built_in">list</span>(my_tuple)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串转列表的结果是: \t<span class="subst">&#123;<span class="built_in">list</span>(my_str)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合转列表的结果是: \t\t<span class="subst">&#123;<span class="built_in">list</span>(my_set)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典转列表的结果是: \t\t<span class="subst">&#123;<span class="built_in">list</span>(my_dict)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>列表转列表的结果是: 		[1, 2, 3, 4, 5, 2]<br>元组转列表的结果是: 		[1, 2, 3, 4, 5, 2]<br>字符串转列表的结果是: 	[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘a’]<br>集合转列表的结果是: 		[1, 2, 3, 4, 5]<br>字典转列表的结果是: 		[‘key1’, ‘key2’, ‘key3’]</p>
</blockquote>
<p><br><br><br><br><br></p>
<hr>
<h5 id="容器转元组"><a href="#容器转元组" class="headerlink" title="容器转元组"></a>容器转元组</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">my_str = <span class="string">&quot;abcdefa&quot;</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_dict = &#123;<span class="string">&quot;key1&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;key2&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;key3&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表转元组的结果是: \t\t<span class="subst">&#123;<span class="built_in">tuple</span>(my_list)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组转元组的结果是: \t\t<span class="subst">&#123;<span class="built_in">tuple</span>(my_tuple)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串转元组的结果是: \t<span class="subst">&#123;<span class="built_in">tuple</span>(my_str)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合转元组的结果是: \t\t<span class="subst">&#123;<span class="built_in">tuple</span>(my_set)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典转元组的结果是: \t\t<span class="subst">&#123;<span class="built_in">tuple</span>(my_dict)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>列表转元组的结果是: 		(1, 2, 3, 4, 5, 2)<br>元组转元组的结果是: 		(1, 2, 3, 4, 5, 2)<br>字符串转元组的结果是: 	(‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘a’)<br>集合转元组的结果是: 		(1, 2, 3, 4, 5)<br>字典转元组的结果是: 		(‘key1’, ‘key2’, ‘key3’)</p>
</blockquote>
<p><br><br><br><br><br></p>
<hr>
<h5 id="容器转字符串"><a href="#容器转字符串" class="headerlink" title="容器转字符串"></a>容器转字符串</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">my_str = <span class="string">&quot;abcdefa&quot;</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_dict = &#123;<span class="string">&quot;key1&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;key2&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;key3&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表转字符串的结果是: \t\t<span class="subst">&#123;<span class="built_in">str</span>(my_list)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组转字符串的结果是: \t\t<span class="subst">&#123;<span class="built_in">str</span>(my_tuple)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串转字符串的结果是: \t<span class="subst">&#123;<span class="built_in">str</span>(my_str)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合转字符串的结果是: \t\t<span class="subst">&#123;<span class="built_in">str</span>(my_set)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典转字符串的结果是: \t\t<span class="subst">&#123;<span class="built_in">str</span>(my_dict)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>列表转字符串的结果是: 		[1, 2, 3, 4, 5, 2]<br>元组转字符串的结果是: 		(1, 2, 3, 4, 5, 2)<br>字符串转字符串的结果是: 	abcdefa<br>集合转字符串的结果是: 		{1, 2, 3, 4, 5}<br>字典转字符串的结果是: 		{‘key1’: None, ‘key2’: None, ‘key3’: None}</p>
</blockquote>
<div style = "color: red"><b>注意: 字典转字符串, 会将key和值全部转换</b></div>


<p><br><br><br><br><br></p>
<hr>
<h5 id="容器转集合"><a href="#容器转集合" class="headerlink" title="容器转集合"></a>容器转集合</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">my_str = <span class="string">&quot;abcdefa&quot;</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_dict = &#123;<span class="string">&quot;key1&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;key2&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;key3&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表转集合的结果是: \t\t<span class="subst">&#123;<span class="built_in">set</span>(my_list)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组转集合的结果是: \t\t<span class="subst">&#123;<span class="built_in">set</span>(my_tuple)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串转集合的结果是: \t<span class="subst">&#123;<span class="built_in">set</span>(my_str)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合转集合的结果是: \t\t<span class="subst">&#123;<span class="built_in">set</span>(my_set)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典转集合的结果是: \t\t<span class="subst">&#123;<span class="built_in">set</span>(my_dict)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>列表转集合的结果是: 		{1, 2, 3, 4, 5}<br>元组转集合的结果是: 		{1, 2, 3, 4, 5}<br>字符串转集合的结果是: 	{‘d’, ‘c’, ‘a’, ‘e’, ‘b’, ‘f’}<br>集合转集合的结果是: 		{1, 2, 3, 4, 5}<br>字典转集合的结果是: 		{‘key2’, ‘key1’, ‘key3’}</p>
</blockquote>
<div style = "color: red"><b>注意: 转换成集合的时候会自动去重, 导致数据失真</b></div>


<p><br><br><br><br><br></p>
<hr>
<h4 id="通用排序-sorted方法"><a href="#通用排序-sorted方法" class="headerlink" title="通用排序(sorted方法)"></a>通用排序(sorted方法)</h4><p>语法: sorted(容器, [reverse&#x3D; True])<br>功能: 将给定容器进行排序.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">my_tuple = (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">my_str = <span class="string">&quot;fbadcea&quot;</span></span><br><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">my_dict = &#123;<span class="string">&quot;key3&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;key1&quot;</span>:<span class="literal">None</span>, <span class="string">&quot;key2&quot;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表对象的排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_list)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组对象的排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_tuple)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串对象的排序结果是: \t<span class="subst">&#123;<span class="built_in">sorted</span>(my_str)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合对象的排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_set)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典对象的排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_dict)&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表对象的反向排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_list, reverse  = <span class="literal">True</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组对象的反向排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_tuple, reverse  = <span class="literal">True</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字符串对象反向的排序结果是: \t<span class="subst">&#123;<span class="built_in">sorted</span>(my_str, reverse  = <span class="literal">True</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合对象的反向排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_set, reverse  = <span class="literal">True</span>)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;字典对象的反向排序结果是: \t\t<span class="subst">&#123;<span class="built_in">sorted</span>(my_dict, reverse  = <span class="literal">True</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>列表对象的排序结果是: 		[1, 2, 2, 3, 4, 5]<br>元组对象的排序结果是: 		[1, 2, 2, 3, 4, 5]<br>字符串对象的排序结果是: 	[‘a’, ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]<br>集合对象的排序结果是: 		[1, 2, 3, 4, 5]<br>字典对象的排序结果是: 		[‘key1’, ‘key2’, ‘key3’]</p>
</blockquote>
<blockquote>
<p>列表对象的反向排序结果是: 		[5, 4, 3, 2, 2, 1]<br>元组对象的反向排序结果是: 		[5, 4, 3, 2, 2, 1]<br>字符串对象反向的排序结果是: 	[‘f’, ‘e’, ‘d’, ‘c’, ‘b’, ‘a’, ‘a’]<br>集合对象的反向排序结果是: 		[5, 4, 3, 2, 1]<br>字典对象的反向排序结果是: 		[‘key3’, ‘key2’, ‘key1’]</p>
</blockquote>
<div style = "color: red"><b>注意: <br>
1. 排序后的结果是一个新的列表<br>
2. 字母排序按ASCII码进行<br>
3. reverse属性, True表示从大到小, 默认为False从小到大<br>
</b></div>

<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>数据容器分类 数据容器特点对比 类型转换 max min sorted</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="主要三类数据类型"><a href="#主要三类数据类型" class="headerlink" title="主要三类数据类型"></a>主要三类数据类型</h4><p>![[Pasted image 20231214204602.png]]</p>
<h4 id="验证数据类型"><a href="#验证数据类型" class="headerlink" title="验证数据类型"></a>验证数据类型</h4><p><strong>可以通过type()语句来得到数据的类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用print()直接输出类型信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">666</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">11.11</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;string&quot;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>&lt;class: ‘int’&gt;<br>&lt;class: ‘float’&gt;<br>&lt;class: ‘str’&gt;</p>
</blockquote>
<p><strong>可以将type()语句的返回结果赋值于一个变量, 并打印类型信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用变量存储类型信息并打印</span></span><br><span class="line">int_type = <span class="built_in">type</span>(<span class="number">666</span>)</span><br><span class="line">float_type = <span class="built_in">type</span>(<span class="number">11.11</span>)</span><br><span class="line">str_type = <span class="built_in">type</span>(<span class="string">&quot;string&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(int_type)</span><br><span class="line"><span class="built_in">print</span>(float_type)</span><br><span class="line"><span class="built_in">print</span>(str_type)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>&lt;class: ‘int’&gt;<br>&lt;class: ‘float’&gt;<br>&lt;class: ‘str’&gt;</p>
</blockquote>
<p><strong>使用type()语句, 查看变量中存储的数据类型信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;AAA&quot;</span></span><br><span class="line">name_type = <span class="built_in">type</span>(name)</span><br><span class="line"><span class="built_in">print</span>(name_type)</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>&lt;class: ‘str’&gt;</p>
</blockquote>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="常用转换语句"><a href="#常用转换语句" class="headerlink" title="常用转换语句"></a>常用转换语句</h4><p>![[Pasted image 20231214213110.png]]</p>
<p><strong>将数字类型转换成字符串</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">27</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(age))</span><br><span class="line">age_str = <span class="built_in">str</span>(age)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(age_str))</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong>:</p>
<blockquote>
<p>&lt;class ‘int’&gt;<br>&lt;class ‘str’&gt;</p>
</blockquote>
<p><strong>将字符串转换成数字</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="string">&quot;27&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(age))</span><br><span class="line">age_num = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(age_num))</span><br><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line">name = <span class="string">&quot;AAA&quot;</span></span><br><span class="line">name_num = <span class="built_in">int</span>(name) <span class="comment"># 非数字类型不可强制转换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name_num))</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<blockquote>
<p>ValueError: invalid literal for int() with base 10: ‘AAA’<br>&lt;class ‘str’&gt;<br>&lt;class ‘int’&gt;</p>
</blockquote>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 数据类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>![[Pasted image 20231224105633.png]]</p>
<h4 id="文件编码概念"><a href="#文件编码概念" class="headerlink" title="文件编码概念"></a>文件编码概念</h4><p>编码技术即: 翻译的规则, 记录了如何将内容翻译成二进制, 以及如何将二进制翻译回可识别内容. </p>
<p>需要使用正确的编码, 才能对文件进行正确的读写操作</p>
<p>计算机只认识0和1, 所以需要将内容翻译成0和1才能保存在计算机中. 同时也需要编码, 将计算机保存的0和1, 反向翻译回可以识别的内容.</p>
<p><br><br><br><br><br></p>
<hr>
<h4 id="文件读取open"><a href="#文件读取open" class="headerlink" title="文件读取open"></a>文件读取open</h4><p>在Python, 使用open函数, 可以打开一个已经存在的文件, 或者创建一个新文件, 语法如下</p>
<p>open(name, mode, encoding)</p>
<p>name: 是要打开的目标文件名的字符串(可以包含文件所在的具体路径)<br>mode: 设置打开文件的模式(访问模式): 只读, 写入, 追加等.<br>encoding: 编码格式(推荐使用UTF-8)<br>示例代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;Python.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"><span class="comment"># encoding的顺序不是第三位, 所以不能用位置传参, 用关键词传参</span></span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
此时的f是open函数的文件对象, 对象是Python中一种特殊的数据类型, 拥有属性和方法, 可以使用[对象.属性]或[对象.方法]对其进行访问. 
</b></div>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法read-readlines-readline"><a href="#方法read-readlines-readline" class="headerlink" title="方法read-readlines-readline"></a>方法read-readlines-readline</h4><p>语法: 文件对象.read(num)</p>
<p>num表示要从文件中读取的数据的长度(单位是字节), <strong>如果没有传入num, 那么就表示读取文件中所有的数据.</strong> </p>
<p>readlines可以按照行的方式把整个文件中的内容进行一次性读取, 并且返回的时候一个列表, 其中每一行的数据为一个元素. </p>
<p><strong>readline()方法, 一次读取一行内容. 每次调用从上次读取的记录点开始重新读取</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件内容</span></span><br><span class="line">hello world</span><br><span class="line">abcdefg</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>)</span><br><span class="line">content = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&quot;hello world\n&quot;, &quot;abcdefg\n&quot;, &quot;aaa\n&quot;, &quot;bbb\n&quot;, &quot;ccc&quot;]</span></span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
1. 读取方法进行读取之后, 再次读取都是从上次读取的记录点开始继续读取
</b></div>

<p><br><br><br><br><br></p>
<hr>
<h4 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;Python.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&quot;每一行的数据是: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>


<p><br><br><br><br><br></p>
<hr>
<h4 id="语句with-open-as"><a href="#语句with-open-as" class="headerlink" title="语句with-open-as"></a>语句with-open-as</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&quot;每一行的数据是: <span class="subst">&#123;line&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
1. 打开文件的操作会占用文件, 需要使用close方法解除占用<br>
2. 避免忘记手动解除占用, 使用with-open方法打开文件后, 在内部语句结束执行后会自动解除文件占用
</b></div>

<p><br><br><br><br><br></p>
<hr>
<h4 id="写入操作"><a href="#写入操作" class="headerlink" title="写入操作"></a>写入操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 文件写入</span></span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 内容刷新</span></span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
1. 直接调用write, 内容并未真正写入文件, 而是会积攒在程序的内存中, 称之为缓冲区. <br>
2. 当调用flush方法的时候, 内容会真正写入文件<br>
3. 这样做是避免频繁的操作硬盘, 导致效率下降(攒一堆, 一次性写磁盘)<br>
4. w模式下, 如果文件不存在会自动创建<br>
5. close方法, 内置了flush功能<br>
6. w模式下, 对已存在文件的内容写入, 将会把文件原有内容覆盖<br>
</b></div>

<p><br><br><br><br><br></p>
<hr>
<h4 id="追加写入"><a href="#追加写入" class="headerlink" title="追加写入"></a>追加写入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件, 通过a模式打开即可</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 文件写入</span></span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 内容刷新</span></span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
1. a模式, 文件不存在会创建文件. <br>
2. 文件存在会在原有内容的最后, 追加写入文件. 如果原有内容带有换行, 则新起一行追加, 如果原有内容不带有换行, 则需要手动追加换行符\n
</b></div>]]></content>
      <tags>
        <tag>update_time-20231224 文件操作 read readlines readline</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>本章介绍的模块提供了广泛的字符串操作和其他文本处理服务。</p>
<p>在 [二进制数据服务]之下描述的 [codecs]模块也与文本处理高度相关。 此外也请参阅 Python 内置字符串类型的文档 [文本序列类型 — str]</p>
<ul>
<li>[[string — 常见的字符串操作]]<ul>
<li>字符串常量</li>
<li>自定义字符串格式化</li>
<li>格式字符串语法<ul>
<li>格式规格迷你语言</li>
<li>格式示例</li>
</ul>
</li>
<li>模板字符串</li>
<li>辅助函数</li>
</ul>
</li>
<li>[[re — 正则表达式操作]]<ul>
<li>正则表达式语法</li>
<li>模块内容<ul>
<li>标志</li>
<li>函数</li>
<li>异常</li>
</ul>
</li>
<li>正则表达式对象 （正则对象）</li>
<li>匹配对象</li>
<li>正则表达式例子<ul>
<li>检查对子</li>
<li>模拟 scanf()</li>
<li>search() vs. match()</li>
<li>制作一个电话本</li>
<li>文字整理</li>
<li>查找所有副词</li>
<li>查找所有的副词及其位置</li>
<li>原始字符串标记</li>
<li>写一个词法分析器</li>
</ul>
</li>
</ul>
</li>
<li>[[difflib — 计算差异的辅助工具]]<ul>
<li>SequenceMatcher 对象</li>
<li>SequenceMatcher 的示例</li>
<li>Differ 对象</li>
<li>Differ 示例</li>
<li>difflib 的命令行接口</li>
</ul>
</li>
<li>[[textwrap — 文本自动换行与填充]]</li>
<li>[[unicodedata — Unicode 数据库]]</li>
<li>[[stringprep — 因特网字符串预备]]</li>
<li>[[readline — GNU readline 接口]]<ul>
<li>初始化文件</li>
<li>行缓冲区</li>
<li>历史文件</li>
<li>历史列表</li>
<li>启动钩子</li>
<li>Completion</li>
<li>示例</li>
</ul>
</li>
<li>[[rlcompleter — GNU readline 的补全函数]]<ul>
<li>Completer 对象</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python Python标准库 string re difflib textwrap unicodedata stringprep readline rlcompleter</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><h4 id="什么是标识符"><a href="#什么是标识符" class="headerlink" title="什么是标识符"></a>什么是标识符</h4><p>在Python程序中, 我们可以给很多东西起名字, 比如:</p>
<ul>
<li>变量的名字</li>
<li>方法的名字</li>
<li>类的名字, 等等<br>这些名字, 我们把它统一的称之为标识符, 用来做内容的标识</li>
</ul>
<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><ul>
<li><p><strong>内容限定</strong></p>
<p>  标识符命名中, 只允许出现: </p>
<ul>
<li>英文</li>
<li>中文</li>
<li>数字</li>
<li>下划线<br>  不推荐使用中文, 数字不可以开头<br>  见名知意, 下划线命名法, 引文字母全小写</li>
</ul>
<p>  <strong>命名错误示例</strong><br>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">1_name = <span class="string">&quot;张三&quot;</span></span><br></pre></td></tr></table></figure><br>  <strong>运行报错</strong></p>
<blockquote>
<p>SyntaxError: invalid decimal literal</p>
</blockquote>
</li>
<li><p><strong>大小写敏感</strong></p>
</li>
<li>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以定义变量为例: </span></span><br><span class="line">Andy = <span class="string">&quot;安迪1&quot;</span></span><br><span class="line">andy = <span class="string">&quot;安迪2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Andy)</span><br><span class="line"><span class="built_in">print</span>(andy)</span><br></pre></td></tr></table></figure>
<p>  <strong>输出结果</strong></p>
<blockquote>
<p>安迪1<br>安迪2
  </p>
</blockquote>
</li>
<li><p><strong>不可使用关键词</strong></p>
<p>  关键词在Python中都有特定的用途, 不可以使用它们作为标识符</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">None</span>, <span class="keyword">and</span>, <span class="keyword">as</span>, <span class="keyword">assert</span>, <span class="keyword">break</span>, <span class="keyword">class</span>, <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">def</span>, <span class="keyword">del</span>, <span class="keyword">elif</span>, <span class="keyword">else</span>, <span class="keyword">except</span>, <span class="keyword">finally</span>, <span class="keyword">for</span>, <span class="keyword">from</span>, <span class="keyword">global</span></span><br><span class="line"><span class="keyword">if</span>, <span class="keyword">import</span>, <span class="keyword">in</span>, <span class="keyword">is</span>, <span class="keyword">lambda</span>, <span class="keyword">nonlocal</span>, <span class="keyword">not</span>, <span class="keyword">or</span>, <span class="keyword">pass</span>, <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">try</span>, <span class="keyword">while</span>, <span class="keyword">with</span>, <span class="keyword">yield</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 标识符</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>“Python 库”中包含了几种不同的组件。</p>
<p>它包含通常被视为语言“核心”中的一部分的数据类型，例如数字和列表。对于这些类型，Python语言核心定义了文字的形式，并对它们的语义设置了一些约束，但没有完全定义语义。（另一方面，语言核心确实定义了语法属性，如操作符的拼写和优先级。）</p>
<p>这个库也包含了内置函数和异常 — 不需要 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句就可以在所有Python代码中使用的对象。有一些是由语言核心定义的，但是许多对于核心语义不是必需的，并且仅在这里描述。</p>
<p>不过这个库主要是由一系列的模块组成。这些模块集可以不同方式分类。有些模块是用 C 编写并内置于 Python 解释器中；另一些模块则是用 Python 编写并以源码形式导入。有些模块提供专用于 Python 的接口，例如打印栈追踪信息；有些模块提供专用于特定操作系统的接口，例如操作特定的硬件；另一些模块则提供针对特定应用领域的接口，例如万维网。有些模块在所有更新和移植版本的 Python 中可用；另一些模块仅在底层系统支持或要求时可用；还有些模块则仅当编译和安装 Python 时选择了特定配置选项时才可用。</p>
<p>本手册以 “从内到外” 的顺序组织：首先描述内置函数、数据类型和异常，最后是根据相关性进行分组的各种模块。</p>
<p>这意味着如果你从头开始阅读本手册，并在感到厌烦时跳到下一章，你仍能对 Python 库的可用模块和所支持的应用领域有个大致了解。当然，你并非 <em>必须</em> 如同读小说一样从头读到尾 — 你也可以先浏览内容目录 (在手册开头)，或在索引 (在手册末尾) 中查找某个特定函数、模块或条目。最后，如果你喜欢随意学习某个主题，你可以选择一个随机页码 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code>random</code></a> 模块) 并读上一两小节。无论你想以怎样的顺序阅读本手册，还是建议先从 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#built-in-funcs">内置函数</a> 这一章开始，因为本手册的其余内容都需要你熟悉其中的基本概念。</p>
<p>让我们开始吧！</p>
<h2 id="可用性注释"><a href="#可用性注释" class="headerlink" title="可用性注释"></a>可用性注释</h2><ul>
<li><p>如果出现“适用：Unix”注释，意味着相应函数通常存在于 Unix 系统中。 但这并不保证其存在于某个特定的操作系统中。</p>
</li>
<li><p>如果没有单独说明，所有注明 “可用性: Unix” 的函数都在 macOS 上受到支持，因为此系统是基于 Unix 内核的。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python Python标准库 可用性注释</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h4 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h4><p>Python模块(Module), 是一个Python文件, 以.py结尾. 模块能定义函数, 类和变量, 模块里也能包含可执行的代码.</p>
<p>模块的作用: Python中有很多各种不同的模块, 每一个模块都可以帮助我们快速的实现一些功能, 比如实现和时间相关的功能, 就可以使用time模块, 我们可以认为一个模块就是一个工具包, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能. </p>
<h4 id="模块导入方式"><a href="#模块导入方式" class="headerlink" title="模块导入方式"></a>模块导入方式</h4><p>模块在使用前需要先导入 导入的语法如下: </p>
<p>[from 模块名] import [模块 | 类 | 变量 | 函数| * ] [as 别名]</p>
<p>常用的组合形式如: </p>
<ul>
<li>import 模块名</li>
<li>from 模块名 import 类, 变量, 方法等</li>
<li>from 模块名 import *</li>
<li>import 模块名 as 别名</li>
<li>from 模块名 import 功能名 as 别名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入时间模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line"><span class="comment"># 让程序睡眠2s(阻塞)</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块1代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_test</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块2代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_test</span>(<span class="params">a, b</span>)</span><br><span class="line">	<span class="built_in">print</span>(a - b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入模块和调用功能代码</span></span><br><span class="line"><span class="keyword">from</span> my_module1 <span class="keyword">import</span> my_test</span><br><span class="line"><span class="keyword">from</span> my_module2 <span class="keyword">import</span> my_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_test函数时模块2中的函数</span></span><br><span class="line">my_test(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
1. 当导入多个模块的时候, 且模块内有同名功能, 当调用这个同名功能的时候, 调用到的时候后面导入的模块的功能.<br>
2. 自定义模块就是专门的一个定义函数或类的.py文件
</b></div>


<p><br><br><br><br><br></p>
<hr>
<h4 id="模块测试"><a href="#模块测试" class="headerlink" title="模块测试"></a>模块测试</h4><p>实际开发中, 当一个开发人员编写完一个模块后, 为了让模块能够在项目中达到想要的效果, 这个开发人员会自行在py文件中添加一些测试信息, 例如, 在my_module1.py文件中添加测试代码test(1, 1)</p>
<p>问题: 无论是当前文件, 还是其他已经导入了该模块的文件, 在运行的时候都会自动执行test函数的调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">	<span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在当前文件中调用该函数, 其他导入的文件内不执行</span></span><br><span class="line">if__name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	test(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<div style = "color: red"><b>注意: <br>
1. 在模块内测试的称为main变量, 目的是测试模块是否正常运行的时候, 不会在其他调用场景执行测试代码<br>
2. __all__变量, 当使用'from xxx import * '导入是, 只能导入这个列表中的元素.
</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块文件</span></span><br><span class="line">__all__ = [<span class="string">&#x27;test_A&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_A</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;testA&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_B</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;testB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用模块的文件</span></span><br><span class="line"><span class="keyword">from</span> my_module1 <span class="keyword">import</span> *</span><br><span class="line">test_A()  <span class="comment"># 这里只能使用test_A函数</span></span><br></pre></td></tr></table></figure>


<p><br><br><br><br><br></p>
<hr>
<h4 id="自定义包"><a href="#自定义包" class="headerlink" title="自定义包"></a>自定义包</h4><p>![[Pasted image 20231224164241.png]]</p>
<div style = "color: red"><b>包的作用: 当我们的模块文件越来越多时, 包可以帮助我们管理这些模块, 包的作用就是包含多个模块, 但包的本质依然是模块</b></div>


<p><br><br><br><br><br></p>
<hr>
<h4 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h4><p>![[Pasted image 20231224164747.png]]</p>
<p>![[Pasted image 20231224164911.png]]</p>
<p>![[Pasted image 20231224165026.png]]</p>
<p>网站: <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>编程语言 Python 模块 自定义模块 class 安装第三方包 pip __main__ __all__ update_time_20231224</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<h3 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h3><p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入你的名字&quot;</span>)</span><br><span class="line">name = <span class="built_in">input</span>() <span class="comment"># 键盘输入张三</span></span><br><span class="line"><span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># input可自带提示词</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字&quot;</span>)  <span class="comment"># 键盘输入张三</span></span><br><span class="line"><span class="built_in">print</span>(name, <span class="built_in">type</span>(name)) <span class="comment"># 统一保存为字符串类型</span></span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<blockquote>
<p>张三<br>张三&lt;class: ‘str’&gt;</p>
</blockquote>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python input</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>![[Pasted image 20231214211739.png]]</p>
<p><strong>语法如下</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 + 3的结果是: &quot;</span>, a + b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 - 3的结果是: &quot;</span>, a - b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 * 3的结果是: &quot;</span>, a * b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 / 3的结果是: &quot;</span>, a / b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 // 3的结果是: &quot;</span>, a // b) <span class="comment"># 取整除</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 % 3的结果是: &quot;</span>, a % b) <span class="comment"># 取余数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 ** 3的结果是: &quot;</span>, a ** b) <span class="comment"># 指数</span></span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>:</p>
<blockquote>
<p>10 + 3的结果是:  13<br>10 - 3的结果是:  7<br>10 * 3的结果是:  30<br>10 &#x2F; 3的结果是:  3.3333333333333335<br>10 &#x2F;&#x2F; 3的结果是:  3<br>10 % 3的结果是:  1<br>10 ** 3的结果是:  1000</p>
</blockquote>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>![[Pasted image 20231214212825.png]]</p>
<h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h4><p>![[Pasted image 20231214212854.png]]</p>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 运算符</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E8%AF%AD%E5%8F%A5continue%E5%92%8Cbreak/</url>
    <content><![CDATA[<h4 id="关键词continue"><a href="#关键词continue" class="headerlink" title="关键词continue"></a>关键词continue</h4><p>continue关键词用于: 中断本次循环, 直接进入下一次循环<br>continue可以用于: for和while循环, 效果一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">	语句<span class="number">1</span></span><br><span class="line">	<span class="keyword">continue</span></span><br><span class="line">	语句<span class="number">2</span></span><br><span class="line"><span class="comment"># 语句2不会被执行</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="关键词break"><a href="#关键词break" class="headerlink" title="关键词break"></a>关键词break</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">	<span class="keyword">break</span></span><br><span class="line">	语句<span class="number">1</span></span><br><span class="line"><span class="comment"># 语句1不会被执行, 语句2执行</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python基础知识 continue break</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E7%BC%96%E8%BE%91%E5%99%A8PyCharm%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="PyCharm快捷键"><a href="#PyCharm快捷键" class="headerlink" title="PyCharm快捷键"></a>PyCharm快捷键</h3><p>Ctrl + Alt + S: 打开软件设置<br>Ctrl + D: 复制当前行代码<br>Shift + Alt + 上\下: 将当前代码上移或是下移<br>Crtl + Shift + F10: 运行当前代码文件<br>Shift + F6: 重命名文件<br>Ctrl + F: 搜索</p>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python PyCharm快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h4 id="操作总结"><a href="#操作总结" class="headerlink" title="操作总结"></a>操作总结</h4><p>![[Pasted image 20231223121136.png]]</p>
<p><br><br><br><br><br></p>
<hr>
<h4 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h4><p>主要特点: 不支持元素重复(自带去重功能), 并且内容无序<br>基本语法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义集合字面量</span></span><br><span class="line">&#123;元素, 元素, 元素...., 元素&#125;</span><br><span class="line"><span class="comment"># 定义集合变量</span></span><br><span class="line">变量名称 = &#123;元素, 元素,..., 元素&#125;</span><br><span class="line"><span class="comment"># 定义空集合</span></span><br><span class="line">变量名称 = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment"># 不可以直接使用: 变量名称=&#123;&#125;, 因为空字典占用了这个语法</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法add"><a href="#方法add" class="headerlink" title="方法add"></a>方法add</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line">my_set.add(<span class="string">&quot;JAVA&quot;</span>)</span><br><span class="line">my_set.add(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">my_set.add(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;结果是: <span class="subst">&#123;my_set&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果: </span></span><br><span class="line"><span class="comment"># 结果是: &#123;&#x27;I&#x27;, &#x27;world&#x27;, &#x27;Hello&#x27;, &#x27;hello&#x27;, &#x27;am&#x27;, &#x27;JAVA&#x27;, &#x27;python&#x27;&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. add方法是在原集合中添加元素, 自身没有返回值</span></span><br><span class="line"><span class="string">2. 集合中的顺序是无序的</span></span><br><span class="line"><span class="string">3. 字符区分大小写</span></span><br><span class="line"><span class="string">4. 没有重复元素</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法remove"><a href="#方法remove" class="headerlink" title="方法remove"></a>方法remove</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line">my_set.remove(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;结果是: <span class="subst">&#123;my_set&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 结果: </span></span><br><span class="line"><span class="comment"># 结果是: &#123;&#x27;am&#x27;, &#x27;world&#x27;, &#x27;I&#x27;, &#x27;python&#x27;&#125;</span></span><br><span class="line"><span class="comment"># remove方法在原集合操作, 无返回值</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法pop"><a href="#方法pop" class="headerlink" title="方法pop"></a>方法pop</h4><p>语法: 集合.pop()功能, 从集合中随机取出一个元素<br>结果: 会得到一个元素的结果. 同时集合本身被修改, 元素被移除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line">element = my_set.pop()</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="built_in">print</span>(element)</span><br><span class="line">element = my_set.pop()</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"><span class="built_in">print</span>(element)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果: </span></span><br><span class="line"><span class="comment"># &#123;&#x27;hello&#x27;, &#x27;I&#x27;, &#x27;world&#x27;, &#x27;am&#x27;&#125;</span></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># &#123;&#x27;I&#x27;, &#x27;world&#x27;, &#x27;am&#x27;&#125;</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法clear"><a href="#方法clear" class="headerlink" title="方法clear"></a>方法clear</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;am&quot;</span>, <span class="string">&quot;python&quot;</span>&#125;</span><br><span class="line">my_set.clear()</span><br><span class="line"><span class="built_in">print</span>(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果: set()</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法difference"><a href="#方法difference" class="headerlink" title="方法difference"></a>方法difference</h4><p>语法: 集合1.difference(集合2), <strong>返回新集合</strong><br>功能: 取出集合1和集合2的差集(集合1有而集合2没有的)</p>
<div style = "color: red"><b>结果: 得到一个新集合, 集合1和集合2不变</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合1: <span class="subst">&#123;set1&#125;</span>, 集合2: <span class="subst">&#123;set2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;取集合1: <span class="subst">&#123;set1.difference(set2)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;取集合2: <span class="subst">&#123;set2.difference(set1)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果: </span></span><br><span class="line"><span class="comment"># 集合1: &#123;1, 2, 3, 4&#125;, 集合2: &#123;3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment"># 取集合1: &#123;1, 2&#125;</span></span><br><span class="line"><span class="comment"># 取集合2: &#123;5, 6&#125;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法difference-update"><a href="#方法difference-update" class="headerlink" title="方法difference_update"></a>方法difference_update</h4><p>语法: 集合1.difference_update(集合2), <strong>在原有集合上修改, 无返回值</strong><br>功能: 对比集合1和集合2, 在集合1内, 删除和集合2相同的元素.</p>
<div style = "color: red"><b>结果: 集合1被修改, 集合2不变</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">set1.difference_update(set2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合1: <span class="subst">&#123;set1&#125;</span>, 集合2: <span class="subst">&#123;set2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 集合1: &#123;1, 2&#125;, 集合2: &#123;3, 4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法union"><a href="#方法union" class="headerlink" title="方法union"></a>方法union</h4><p>语法: 集合1.union(集合2), <strong>返回新集合</strong><br>功能: 将集合1和集合2组合成新集合</p>
<div style = "color: red"><b>结果: 得到新集合, 集合1和集合2不变</b></div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">set3 = set1.union(set2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合1: <span class="subst">&#123;set1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合2: <span class="subst">&#123;set2&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;集合3: <span class="subst">&#123;set3&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 集合1: &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment"># 集合2: &#123;3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="comment"># 集合3: &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="方法len"><a href="#方法len" class="headerlink" title="方法len"></a>方法len</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">len</span>(set1)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果: 4</span></span><br></pre></td></tr></table></figure>

<p><br><br><br><br><br></p>
<hr>
<h4 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不支持下标索引, 所以while循环不可以</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> set1:</span><br><span class="line">	<span class="built_in">print</span>(element)</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>编程语言 Python 非序列 集合 add remove pop clear difference difference_update union len</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%B3%A8%E9%87%8A/</url>
    <content><![CDATA[<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>注释作用</strong>: 易于阅读代码</p>
<p>注释语法分为单行注释和多行注释</p>
<ul>
<li><p>单行注释在行前使用”#”号键+空格+注释内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行注释包含在3对双引号之间, 可以换行注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">一个</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><br><br><br><br></p>
<hr>
]]></content>
      <tags>
        <tag>Python 注释</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<p><code>&gt;&gt;&gt;</code></p>
<p>交互式终端中默认的 Python 提示符。往往会显示于能以交互方式在解释器里执行的样例代码之前。</p>
<p><code>...</code></p>
<p>具有以下含义：</p>
<ul>
<li><p>交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代码块，成对的分隔符之内（圆括号、方括号、花括号或三重引号），或是指定一个装饰器之后。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/constants.html#Ellipsis" title="Ellipsis"><code>Ellipsis</code></a> 内置常量。</p>
</li>
</ul>
<hr>
<p><strong>2to3</strong></p>
<p>把 Python 2.x 代码转换为 Python 3.x 代码的工具，通过解析源码，遍历解析树，处理绝大多数检测到的不兼容问题。</p>
<p>2to3 包含在标准库中，模块名为 <a href="https://docs.python.org/zh-cn/3.10/library/2to3.html#module-lib2to3" title="lib2to3: The 2to3 library"><code>lib2to3</code></a>；提供了独立入口点 <code>Tools/scripts/2to3</code>。详见 <a href="https://docs.python.org/zh-cn/3.10/library/2to3.html#to3-reference">2to3 — 自动化的 Python 2 到 3 代码转写</a>。</p>
<hr>
<p><strong>abstract base class – 抽象基类</strong></p>
<p>抽象基类简称 ABC，是对 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-duck-typing">duck-typing</a> 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hasattr" title="hasattr"><code>hasattr()</code></a> 显得过于笨拙或有微妙错误（例如使用 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#special-lookup">魔术方法</a>）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> 所认可；详见 <a href="https://docs.python.org/zh-cn/3.10/library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code>abc</code></a> 模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code>collections.abc</code></a> 模块中）、数字（在 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code>numbers</code></a> 模块中）、流（在 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#module-io" title="io: Core tools for working with streams."><code>io</code></a> 模块中）、导入查找器和加载器（在 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code>importlib.abc</code></a> 模块中）。你可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code>abc</code></a> 模块来创建自己的 ABC。</p>
<hr>
<p><strong>annotation – 标注</strong></p>
<p>关联到某个变量、类属性、函数形参或返回值的标签，被约定作为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-type-hint">类型注解</a> 来使用。</p>
<p>局部变量的标注在运行时不可访问，但全局变量、类属性和函数的标注会分别存放模块、类和函数的 <code>__annotations__</code> 特殊属性中。</p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-variable-annotation">variable annotation</a>, <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-function-annotation">function annotation</a>, <a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>，对此功能均有介绍。 另请参见 <a href="https://docs.python.org/zh-cn/3.10/howto/annotations.html#annotations-howto">对象注解属性的最佳实践</a> 了解使用标注的最佳实践。</p>
<hr>
<p><strong>argument – 参数</strong></p>
<p>在调用函数时传给 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-function">function</a> （或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-method">method</a> ）的值。参数分为两种：</p>
<ul>
<li><p><em>关键字参数</em>: 在函数调用中前面带有标识符（例如 <code>name=</code>）或者作为包含在前面带有 <code>**</code> 的字典里的值传入。举例来说，<code>3</code> 和 <code>5</code> 在以下对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex()</code></a> 的调用中均属于关键字参数:</p>
<p>  complex(real&#x3D;3, imag&#x3D;5)<br>  complex(**{‘real’: 3, ‘imag’: 5})</p>
</li>
<li><p><em>位置参数</em>: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及&#x2F;或者作为前面带有 <code>*</code> 的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a> 里的元素被传入。举例来说，<code>3</code> 和 <code>5</code> 在以下调用中均属于位置参数:</p>
<p>  complex(3, 5)<br>  complex(*(3, 5))</p>
</li>
</ul>
<p>参数会被赋值给函数体中对应的局部变量。有关赋值规则参见 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#calls">调用</a> 一节。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</p>
<p>另参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-parameter">parameter</a> 术语表条目，常见问题中 <a href="https://docs.python.org/zh-cn/3.10/faq/programming.html#faq-argument-vs-parameter">参数与形参的区别</a> 以及 <a href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a>。</p>
<p>asynchronous context manager – 异步上下文管理器</p>
<p>此种对象通过定义 <code>__aenter__()</code> 和 <code>__aexit__()</code> 方法来对 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p>
<hr>
<p><strong>asynchronous generator – 异步生成器</strong></p>
<p>返回值为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-generator-iterator">asynchronous generator iterator</a> 的函数。它与使用 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-def"><code>async def</code></a> 定义的协程函数很相似，不同之处在于它包含 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#yield"><code>yield</code></a> 表达式以产生一系列可在 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-for"><code>async for</code></a> 循环中使用的值。</p>
<p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 _异步生成器迭代器_。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<p>一个异步生成器函数可能包含 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#await"><code>await</code></a> 表达式或者 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-for"><code>async for</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-with"><code>async with</code></a> 语句。</p>
<hr>
<p><strong>asynchronous generator iterator – 异步生成器迭代器</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-generator">asynchronous generator</a> 函数所创建的对象。</p>
<p>此对象属于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>，当使用 <code>__anext__()</code> 方法调用时会返回一个可等待对象来执行异步生成器函数的代码直到下一个 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#yield"><code>yield</code></a> 表达式。</p>
<p>每个 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#yield"><code>yield</code></a> 会临时暂停处理，记住当前位置执行状态 (包括局部变量和挂起的 try 语句)。当该 <em>异步生成器迭代器</em> 与其他 <code>__anext__()</code> 返回的可等待对象有效恢复时，它会从离开位置继续执行。参见 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0525"><strong>PEP 525</strong></a>。</p>
<p>asynchronous iterable – 异步可迭代对象</p>
<p>可在 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-for"><code>async for</code></a> 语句中被使用的对象。必须通过它的 <code>__aiter__()</code> 方法返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-asynchronous-iterator">asynchronous iterator</a>。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p>
<hr>
<p><strong>asynchronous iterator – 异步迭代器</strong></p>
<p>实现了 <code>__aiter__()</code> 和 <code>__anext__()</code> 方法的对象。<code>__anext__</code> 必须返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-awaitable">awaitable</a> 对象。<a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-for"><code>async for</code></a> 会处理异步迭代器的 <code>__anext__()</code> 方法所返回的可等待对象，直到其引发一个 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code>StopAsyncIteration</code></a> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入。</p>
<hr>
<p><strong>attribute – 属性</strong></p>
<p>关联到一个对象的值，通常使用点号表达式按名称来引用。 举例来说，如果对象 <em>o</em> 具有属性 <em>a</em> 则可以用 <em>o.a</em> 来引用它。</p>
<p>如果对象允许，将未被定义为 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#identifiers">标识符和关键字</a> 的非标识名称用作一个对象的属性也是可以的，例如使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#setattr" title="setattr"><code>setattr()</code></a>。 这样的属性将无法使用点号表达式来访问，而是必须通过 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#getattr" title="getattr"><code>getattr()</code></a> 来获取。</p>
<hr>
<p><strong>awaitable – 可等待对象</strong></p>
<p>能在 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#await"><code>await</code></a> 表达式中使用的对象。可以是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-coroutine">coroutine</a> 或是具有 <code>__await__()</code> 方法的对象。参见 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>。</p>
<hr>
<p><strong>BDFL</strong></p>
<p>“终身仁慈独裁者”的英文缩写，即 <a href="https://gvanrossum.github.io/">Guido van Rossum</a>，Python 的创造者。</p>
<hr>
<p><strong>binary file – 二进制文件</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">file object</a> 能够读写 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">字节类对象</a>。二进制文件的例子包括以二进制模式（<code>&#39;rb&#39;</code>, <code>&#39;wb&#39;</code> or <code>&#39;rb+&#39;</code>）打开的文件、<code>sys.stdin.buffer</code>、<code>sys.stdout.buffer</code> 以及 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code>gzip.GzipFile</code></a> 的实例。</p>
<p>另请参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-text-file">text file</a> 了解能够读写 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 对象的文件对象。</p>
<hr>
<p><strong>borrowed reference – 借入引用</strong></p>
<p>在 Python 的 C API 中，借用引用是指一种对象引用，使用该对象的代码并不持有该引用。 如果对象被销毁则它就会变成一个悬空指针。 例如，垃圾回收器可以移除对象的最后一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-strong-reference">strong reference</a> 来销毁它。</p>
<p>推荐在 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-borrowed-reference">borrowed reference</a> 上调用 <a href="https://docs.python.org/zh-cn/3.10/c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code>Py_INCREF()</code></a> 以将其原地转换为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-strong-reference">strong reference</a>，除非是当该对象无法在借入引用的最后一次使用之前被销毁。 <a href="https://docs.python.org/zh-cn/3.10/c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code>Py_NewRef()</code></a> 函数可以被用来创建一个新的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-strong-reference">strong reference</a>。</p>
<hr>
<p><strong>bytes-like object – 字节类对象</strong></p>
<p>支持 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲协议</a> 并且能导出 C-<a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-contiguous">contiguous</a> 缓冲的对象。这包括所有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/array.html#array.array" title="array.array"><code>array.array</code></a> 对象，以及许多普通 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>
<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a>。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a>。</p>
<hr>
<p><strong>bytecode – 字节码</strong></p>
<p>Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在 <code>.pyc</code> 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 “中间语言” 运行在根据字节码执行相应机器码的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-virtual-machine">virtual machine</a> 之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。</p>
<p>字节码指令列表可以在 <a href="https://docs.python.org/zh-cn/3.10/library/dis.html#bytecodes">dis 模块</a> 的文档中查看。</p>
<hr>
<p><strong>callable – 可调用对象</strong></p>
<p>可调用对象就是可以执行调用运算的对象，并可能附带一组参数 (参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">argument</a>)，使用以下语法:</p>
<hr>
<p><strong>callable(argument1, argument2, …)</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-function">function</a>，还可扩展到 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-method">method</a> 等，就属于可调用对象。 实现了 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__call__" title="object.__call__"><code>__call__()</code></a> 方法的类的实例也属于可调用对象。</p>
<hr>
<p><strong>callback – 回调</strong></p>
<p>一个作为参数被传入以用以在未来的某个时刻被调用的子例程函数。</p>
<hr>
<p><strong>class</strong></p>
<p>用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p>
<hr>
<p><strong>class variable – 类变量</strong></p>
<p>在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p>
<hr>
<p><strong>coercion – 强制类型转换</strong></p>
<p>在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，<code>int(3.15)</code> 是将原浮点数转换为整型数 <code>3</code>，但在 <code>3+4.5</code> 中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 <code>float(3)+4.5</code> 而不是 <code>3+4.5</code>。</p>
<hr>
<p><strong>complex number – 复数</strong></p>
<p>对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位（<code>-1</code> 的平方根）的实倍数，通常在数学中写为 <code>i</code>，在工程学中写为 <code>j</code>。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个 <code>j</code> 后缀，例如 <code>3+1j</code>。如果需要 <a href="https://docs.python.org/zh-cn/3.10/library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code>math</code></a> 模块内对象的对应复数版本，请使用 <a href="https://docs.python.org/zh-cn/3.10/library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code>cmath</code></a>，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。</p>
<hr>
<p><strong>context manager – 上下文管理器</strong></p>
<p>在 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句中使用，通过定义 <code>__enter__()</code> 和 <code>__exit__()</code> 方法来控制环境状态的对象。参见 <a href="https://www.python.org/dev/peps/pep-0343"><strong>PEP 343</strong></a>。</p>
<hr>
<p><strong>context variable – 上下文变量</strong></p>
<p>一种根据其所属的上下文可以具有不同的值的变量。 这类似于在线程局部存储中每个执行线程可以具有不同的变量值。 不过，对于上下文变量来说，一个执行线程中可能会有多个上下文，而上下文变量的主要用途是对并发异步任务中变量进行追踪。 参见 <a href="https://docs.python.org/zh-cn/3.10/library/contextvars.html#module-contextvars" title="contextvars: Context Variables"><code>contextvars</code></a>。</p>
<hr>
<p><strong>contiguous – 连续</strong></p>
<p>一个缓冲如果是 <em>C 连续</em> 或 <em>Fortran 连续</em> 就会被认为是连续的。零维缓冲是 C 和 Fortran 连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。</p>
<hr>
<p><strong>coroutine – 协程</strong></p>
<p>协程是子例程的更一般形式。 子例程可以在某一点进入并在另一点退出。 协程则可以在许多不同的点上进入、退出和恢复。 它们可通过 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-def"><code>async def</code></a> 语句来实现。 参见 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a>。</p>
<hr>
<p><strong>coroutine function – 协程函数</strong></p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-coroutine">coroutine</a> 对象的函数。协程函数可通过 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-def"><code>async def</code></a> 语句来定义，并可能包含 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#await"><code>await</code></a>、<a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-for"><code>async for</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-with"><code>async with</code></a> 关键字。这些特性是由 <a href="https://www.python.org/dev/peps/pep-0492"><strong>PEP 492</strong></a> 引入的。</p>
<hr>
<p><strong>CPython</strong></p>
<p>Python 编程语言的规范实现，在 <a href="https://www.python.org/">python.org</a> 上发布。”CPython” 一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。</p>
<hr>
<p><strong>decorator – 装饰器</strong></p>
<p>返回值为另一个函数的函数，通常使用 <code>@wrapper</code> 语法形式来进行函数变换。 装饰器的常见例子包括 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#classmethod" title="classmethod"><code>classmethod()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#staticmethod" title="staticmethod"><code>staticmethod()</code></a>。</p>
<p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p>
<p>def f(arg):<br>    …<br>f &#x3D; staticmethod(f)</p>
<p>@staticmethod<br>def f(arg):<br>    …</p>
<p>同样的概念也适用于类，但通常较少这样使用。有关装饰器的详情可参见 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#class">类定义</a> 的文档。</p>
<hr>
<p><strong>descriptor – 描述器</strong></p>
<p>任何定义了 <code>__get__()</code>, <code>__set__()</code> 或 <code>__delete__()</code> 方法的对象。当一个类属性为描述器时，它的特殊绑定行为就会在属性查找时被触发。通常情况下，使用 <em>a.b</em> 来获取、设置或删除一个属性时会在 <em>a</em> 的类字典中查找名称为 <em>b</em> 的对象，但如果 <em>b</em> 是一个描述器，则会调用对应的描述器方法。理解描述器的概念是更深层次理解 Python 的关键，因为这是许多重要特性的基础，包括函数、方法、属性、类方法、静态方法以及对超类的引用等等。</p>
<p>有关描述器的方法的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#descriptors">实现描述器</a> 或 <a href="https://docs.python.org/zh-cn/3.10/howto/descriptor.html#descriptorhowto">描述器使用指南</a>。</p>
<hr>
<p><strong>dictionary – 字典</strong></p>
<p>一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <code>__hash__()</code> 和 <code>__eq__()</code> 方法的对象。在 Perl 语言中称为 hash。</p>
<hr>
<p><strong>dictionary comprehension – 字典推导式</strong></p>
<p>处理一个可迭代对象中的所有或部分元素并返回结果字典的一种紧凑写法。 <code>results = &#123;n: n ** 2 for n in range(10)&#125;</code> 将生成一个由键 <code>n</code> 到值 <code>n ** 2</code> 的映射构成的字典。 参见 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#comprehensions">列表、集合与字典的显示</a>。</p>
<hr>
<p><strong>dictionary view – 字典视图</strong></p>
<p>从 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.keys" title="dict.keys"><code>dict.keys()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.values" title="dict.values"><code>dict.values()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.items" title="dict.items"><code>dict.items()</code></a> 返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用 <code>list(dictview)</code>。参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict-views">字典视图对象</a>。</p>
<hr>
<p><strong>docstring – 文档字符串</strong></p>
<p>作为类、函数或模块之内的第一个表达式出现的字符串字面值。它在代码执行时会被忽略，但会被解释器识别并放入所在类、函数或模块的 <code>__doc__</code> 属性中。由于它可用于代码内省，因此是对象存放文档的规范位置。</p>
<hr>
<p><strong>duck-typing – 鸭子类型</strong></p>
<p>指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="type"><code>type()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 检测。(但要注意鸭子类型可以使用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-abstract-base-class">抽象基类</a> 作为补充。) 而往往会采用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hasattr" title="hasattr"><code>hasattr()</code></a> 检测或是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-EAFP">EAFP</a> 编程。</p>
<hr>
<p><strong>EAFP</strong></p>
<p>“求原谅比求许可更容易”的英文缩写。这种 Python 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#try"><code>try</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#except"><code>except</code></a> 语句。于其相对的则是所谓 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-LBYL">LBYL</a> 风格，常见于 C 等许多其他语言。</p>
<hr>
<p><strong>expression – 表达式</strong></p>
<p>可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-statement">statement</a>，例如 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#while"><code>while</code></a>。 赋值也是属于语句而非表达式。</p>
<hr>
<p><strong>extension module – 扩展模块</strong></p>
<p>以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。</p>
<hr>
<p><strong>f-string – f-字符串</strong></p>
<p>带有 <code>&#39;f&#39;</code> 或 <code>&#39;F&#39;</code> 前缀的字符串字面值通常被称为“f-字符串”即 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#f-strings">格式化字符串字面值</a> 的简写。参见 <a href="https://www.python.org/dev/peps/pep-0498"><strong>PEP 498</strong></a>。</p>
<hr>
<p><strong>file object – 文件对象</strong></p>
<p>对外提供面向文件 API 以使用下层资源的对象（带有 <code>read()</code> 或 <code>write()</code> 这样的方法）。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入&#x2F;输出、内存缓冲区、套接字、管道等等）。文件对象也被称为 <em>文件类对象</em> 或 _流_。</p>
<p>实际上共有三种类别的文件对象: 原始 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-binary-file">二进制文件</a>, 缓冲 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-binary-file">二进制文件</a> 以及 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-text-file">文本文件</a>。它们的接口定义均在 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#module-io" title="io: Core tools for working with streams."><code>io</code></a> 模块中。创建文件对象的规范方式是使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a> 函数。</p>
<hr>
<p><strong>file-like object – 文件类对象</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">file object</a> 的同义词。</p>
<p>filesystem encoding and error handler – 文件系统编码格式与错误处理句柄</p>
<p>Python 用来从操作系统解码字节串和向操作系统编码 Unicode 的编码格式与错误处理句柄。</p>
<p>文件系统编码格式必须保证能成功解码长度在 128 以下的所有字节串。 如果文件系统编码格式无法提供此保证，则 API 函数可能会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a>。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code>sys.getfilesystemencoding()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code>sys.getfilesystemencodeerrors()</code></a> 函数可被用来获取文件系统编码格式与错误处理句柄。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-filesystem-encoding-and-error-handler">filesystem encoding and error handler</a> 是在 Python 启动时通过 <code>PyConfig_Read()</code> 函数来配置的：请参阅 <a href="https://docs.python.org/zh-cn/3.10/c-api/init_config.html#c.PyConfig" title="PyConfig"><code>PyConfig</code></a> 的 <a href="https://docs.python.org/zh-cn/3.10/c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code>filesystem_encoding</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code>filesystem_errors</code></a> 等成员。</p>
<p>另请参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-locale-encoding">locale encoding</a>。</p>
<hr>
<p><strong>finder – 查找器</strong></p>
<p>一种会尝试查找被导入模块的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-loader">loader</a> 的对象。</p>
<p>从 Python 3.3 起存在两种类型的查找器: <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-meta-path-finder">元路径查找器</a> 配合 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a> 使用，以及 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry-finder">path entry finders</a> 配合 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.path_hooks" title="sys.path_hooks"><code>sys.path_hooks</code></a> 使用。</p>
<p>更多详情可参见 <a href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>, <a href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0451"><strong>PEP 451</strong></a>。</p>
<hr>
<p><strong>floor division – 向下取整除法</strong></p>
<p>向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 <code>//</code> 。例如，表达式 <code>11 // 4</code> 的计算结果是 <code>2</code> ，而与之相反的是浮点数的真正除法返回 <code>2.75</code> 。注意 <code>(-11) // 4</code> 会返回 <code>-3</code> 因为这是 <code>-2.75</code> <em>向下</em> 舍入得到的结果。见 <a href="https://www.python.org/dev/peps/pep-0238"><strong>PEP 238</strong></a> 。</p>
<hr>
<p><strong>function – 函数</strong></p>
<p>可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">参数</a> 并在函数体执行中被使用。另见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-parameter">parameter</a>, <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-method">method</a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a> 等节。</p>
<hr>
<p><strong>function annotation – 函数标注</strong></p>
<p>即针对函数形参或返回值的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">annotation</a> 。</p>
<p>函数标注通常用于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-type-hint">类型提示</a>：例如以下函数预期接受两个 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 参数并预期返回一个 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 值:</p>
<p>def sum_two_numbers(a: int, b: int) -&gt; int:<br>   return a + b</p>
<p>函数标注语法的详解见 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a> 一节。</p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-variable-annotation">variable annotation</a> 和 <a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>，其中描述了此功能。 另请参阅 <a href="https://docs.python.org/zh-cn/3.10/howto/annotations.html#annotations-howto">对象注解属性的最佳实践</a> 以了解使用标的最佳实践。</p>
<hr>
<p><strong>future</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#future">future 语句</a>, <code>from __future__ import &lt;feature&gt;</code> 指示编译器使用将在未来的 Python 发布版中成为标准的语法和语义来编译当前模块。 <a href="https://docs.python.org/zh-cn/3.10/library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code>__future__</code></a> 模块文档记录了可能 的 <em>feature</em> 取值。 通过导入此模块并对其变量求值，你可以看到每项新特性在何时被首次加入到该语言中以及它将（或已）在何时成为默认:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import <strong>future</strong><br><strong>future</strong>.division<br>_Feature((2, 2, 0, ‘alpha’, 2), (3, 0, 0, ‘alpha’, 0), 8192)</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p><strong>garbage collection – 垃圾回收</strong></p>
<p>释放不再被使用的内存空间的过程。Python 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code>gc</code></a> 模块来控制垃圾回收器。</p>
<hr>
<p><strong>generator – 生成器</strong></p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator-iterator">generator iterator</a> 的函数。它看起来很像普通函数，不同点在于其包含 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#yield"><code>yield</code></a> 表达式以便产生一系列值供给 for-循环使用或是通过 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#next" title="next"><code>next()</code></a> 函数逐一获取。</p>
<p>通常是指生成器函数，但在某些情况下也可能是指 _生成器迭代器_。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<hr>
<p><strong>generator iterator – 生成器迭代器</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator">generator</a> 函数所创建的对象。</p>
<p>每个 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#yield"><code>yield</code></a> 会临时暂停处理，记住当前位置执行状态（包括局部变量和挂起的 try 语句）。当该 <em>生成器迭代器</em> 恢复时，它会从离开位置继续执行（这与每次调用都从新开始的普通函数差别很大）。</p>
<hr>
<p><strong>generator expression – 生成器表达式</strong></p>
<p>返回一个迭代器的表达式。 它看起来很像普通表达式后面带有定义了一个循环变量、范围的 <code>for</code> 子句，以及一个可选的 <code>if</code> 子句。 以下复合表达式会为外层函数生成一系列值:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>sum(i*i for i in range(10))         # sum of squares 0, 1, 4, … 81<br>285</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p><strong>generic function – 泛型函数</strong></p>
<p>为不同的类型实现相同操作的多个函数所组成的函数。在调用时会由调度算法来确定应该使用哪个实现。</p>
<p>另请参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-single-dispatch">single dispatch</a> 术语表条目、<a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.singledispatch" title="functools.singledispatch"><code>functools.singledispatch()</code></a> 装饰器以及 <a href="https://www.python.org/dev/peps/pep-0443"><strong>PEP 443</strong></a>。</p>
<hr>
<p><strong>generic type – 泛型</strong></p>
<p>可参数化的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-type">type</a>；通常为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 这样的 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#sequence-types">容器类</a>。用于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-type-hint">类型提示</a> 和 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">注解</a>。</p>
<p>更多细节参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-genericalias">泛型别名类型</a>、<a href="https://www.python.org/dev/peps/pep-0483"><strong>PEP 483</strong></a>、<a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>、<a href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code>typing</code></a> 模块。</p>
<hr>
<p><strong>GIL</strong></p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-global-interpreter-lock">global interpreter lock</a>。</p>
<hr>
<p><strong>global interpreter lock – 全局解释器锁</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-CPython">CPython</a> 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytecode">bytecode</a>。此机制通过设置对象模型（包括 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p>
<p>不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。 此外，在执行 I&#x2F;O 操作时也总是会释放 GIL。</p>
<p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p>
<hr>
<p><strong>hash-based pyc – 基于哈希的 pyc</strong></p>
<p>使用对应源文件的哈希值而非最后修改时间来确定其有效性的字节码缓存文件。 参见 <a href="https://docs.python.org/zh-cn/3.10/reference/import.html#pyc-invalidation">已缓存字节码的失效</a>。</p>
<hr>
<p><strong>hashable – 可哈希</strong></p>
<p>一个对象的哈希值如果在其生命周期内绝不改变，就被称为 <em>可哈希</em> （它需要具有 <code>__hash__()</code> 方法），并可以同其他对象进行比较（它需要具有 <code>__eq__()</code> 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。</p>
<p>可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。</p>
<p>大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。 它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#id" title="id"><code>id()</code></a>。</p>
<hr>
<p><strong>IDLE</strong></p>
<p>Python 的集成开发与学习环境。 <a href="https://docs.python.org/zh-cn/3.10/library/idle.html#idle">IDLE</a> 是 Python 标准发行版附带的基本编辑器和解释器环境。</p>
<hr>
<p><strong>immutable – 不可变对象</strong></p>
<p>具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。</p>
<hr>
<p><strong>import path – 导入路径</strong></p>
<p>由多个位置（或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry">路径条目</a>）组成的列表，会被模块的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-based-finder">path based finder</a> 用来查找导入目标。在导入时，此位置列表通常来自 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.path" title="sys.path"><code>sys.path</code></a>，但对次级包来说也可能来自上级包的 <code>__path__</code> 属性。</p>
<hr>
<p><strong>importing – 导入</strong></p>
<p>令一个模块中的 Python 代码能为另一个模块中的 Python 代码所使用的过程。</p>
<hr>
<p><strong>importer – 导入器</strong></p>
<p>查找并加载模块的对象；此对象既属于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-finder">finder</a> 又属于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-loader">loader</a>。</p>
<hr>
<p><strong>interactive – 交互</strong></p>
<p>Python 带有一个交互式解释器，即你可以在解释器提示符后输入语句和表达式，立即执行并查看其结果。只需不带参数地启动 <code>python</code> 命令（也可以在你的计算机开始菜单中选择相应菜单项）。在测试新想法或检验模块和包的时候用这种方式会非常方便（请记得使用 <code>help(x)</code>）。</p>
<hr>
<p><strong>interpreted – 解释型</strong></p>
<p>Python 一是种解释型语言，与之相对的是编译型语言，虽然两者的区别由于字节码编译器的存在而会有所模糊。这意味着源文件可以直接运行而不必显式地创建可执行文件再运行。解释型语言通常具有比编译型语言更短的开发&#x2F;调试周期，但是其程序往往运行得更慢。参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-interactive">interactive</a>。</p>
<hr>
<p><strong>interpreter shutdown – 解释器关闭</strong></p>
<p>当被要求关闭时，Python 解释器将进入一个特殊运行阶段并逐步释放所有已分配资源，例如模块和各种关键内部结构等。它还会多次调用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-garbage-collection">垃圾回收器</a>。这会触发用户定义析构器或弱引用回调中的代码执行。在关闭阶段执行的代码可能会遇到各种异常，因为其所依赖的资源已不再有效（常见的例子有库模块或警告机制等）。</p>
<p>解释器需要关闭的主要原因有 <code>__main__</code> 模块或所运行的脚本已完成执行。</p>
<hr>
<p><strong>iterable – 可迭代对象</strong></p>
<p>能够逐一返回其成员项的对象。 可迭代对象的例子包括所有序列类型 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a>) 以及某些非序列类型例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a>, <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">文件对象</a> 以及定义了 <code>__iter__()</code> 方法或是实现了 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-sequence">序列</a> 语义的 <code>__getitem__()</code> 方法的任意自定义类对象。</p>
<p>可迭代对象被可用于 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for"><code>for</code></a> 循环以及许多其他需要一个序列的地方（<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#map" title="map"><code>map()</code></a> …）。当一个可迭代对象作为参数传给内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="iter"><code>iter()</code></a> 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="iter"><code>iter()</code></a> 或者自己处理迭代器对象。<code>for</code> 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a>、<a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-sequence">sequence</a> 以及 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator">generator</a>。</p>
<hr>
<p><strong>iterator – 迭代器</strong></p>
<p>用来表示一连串数据流的对象。重复调用迭代器的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法（或将其传给内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#next" title="next"><code>next()</code></a>）将逐个返回流中的项。当没有数据可用时则将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 <code>__next__()</code> 方法只会再次引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 异常。迭代器必须具有 <code>__iter__()</code> 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>）在你每次向其传入 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#iter" title="iter"><code>iter()</code></a> 函数或是在 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for"><code>for</code></a> 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p>
<p>更多信息可查看 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typeiter">迭代器类型</a>。</p>
<p><strong>CPython 实现细节：</strong> CPython 没有统一应用迭代器定义 <code>__iter__()</code> 的要求。</p>
<hr>
<p><strong>key function – 键函数</strong></p>
<p>键函数或称整理函数，是能够返回用于排序或排位的值的可调用对象。例如，<a href="https://docs.python.org/zh-cn/3.10/library/locale.html#locale.strxfrm" title="locale.strxfrm"><code>locale.strxfrm()</code></a> 可用于生成一个符合特定区域排序约定的排序键。</p>
<p>Python 中有许多工具都允许用键函数来控制元素的排位或分组方式。其中包括 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#min" title="min"><code>min()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#max" title="max"><code>max()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted" title="sorted"><code>sorted()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/heapq.html#heapq.merge" title="heapq.merge"><code>heapq.merge()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code>heapq.nsmallest()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code>heapq.nlargest()</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.groupby" title="itertools.groupby"><code>itertools.groupby()</code></a>。</p>
<p>要创建一个键函数有多种方式。例如，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.lower" title="str.lower"><code>str.lower()</code></a> 方法可以用作忽略大小写排序的键函数。另外，键函数也可通过 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#lambda"><code>lambda</code></a> 表达式来创建，例如 <code>lambda r: (r[0], r[2])</code>。还有 <a href="https://docs.python.org/zh-cn/3.10/library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code>operator</code></a> 模块提供了三个键函数构造器：<a href="https://docs.python.org/zh-cn/3.10/library/operator.html#operator.attrgetter" title="operator.attrgetter"><code>attrgetter()</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/operator.html#operator.itemgetter" title="operator.itemgetter"><code>itemgetter()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/operator.html#operator.methodcaller" title="operator.methodcaller"><code>methodcaller()</code></a>。请查看 <a href="https://docs.python.org/zh-cn/3.10/howto/sorting.html#sortinghowto">如何排序</a> 一节以获取创建和使用键函数的示例。</p>
<hr>
<p><strong>keyword argument – 关键字参数</strong></p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">argument</a>。</p>
<hr>
<p><strong>lambda</strong></p>
<p>由一个单独 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-expression">expression</a> 构成的匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为 <code>lambda [parameters]: expression</code></p>
<hr>
<p><strong>LBYL</strong></p>
<p>“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件。此风格与 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-EAFP">EAFP</a> 方式恰成对比，其特点是大量使用 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#if"><code>if</code></a> 语句。</p>
<p>在多线程环境中，LBYL 方式会导致“查看”和“跳跃”之间发生条件竞争风险。例如，以下代码 <code>if key in mapping: return mapping[key]</code> 可能由于在检查操作之后其他线程从 <em>mapping</em> 中移除了 <em>key</em> 而出错。这种问题可通过加锁或使用 EAFP 方式来解决。</p>
<hr>
<p><strong>locale encoding – 语言区域编码格式</strong></p>
<p>在 Unix 上，它是 LC_CTYPE 语言区域的编码格式。 它可以通过 <code>locale.setlocale(locale.LC_CTYPE, new_locale)</code> 来设置。</p>
<p>在 Windows 上，它是 ANSI 代码页 (例如: <code>cp1252</code>)。</p>
<p><code>locale.getpreferredencoding(False)</code> 可被用来获取语言区域编码格式。</p>
<p>Python 使用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-filesystem-encoding-and-error-handler">filesystem encoding and error handler</a> 在 Unicode 文件名和字节串文件名之间进行转换。</p>
<hr>
<p><strong>list</strong></p>
<p>Python 内置的一种 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-sequence">sequence</a>。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p>
<hr>
<p><strong>list comprehension – 列表推导式</strong></p>
<p>处理一个序列中的所有或部分元素并返回结果列表的一种紧凑写法。<code>result = [&#39;&#123;:#04x&#125;&#39;.format(x) for x in range(256) if x % 2 == 0]</code> 将生成一个 0 到 255 范围内的十六进制偶数对应字符串（0x..）的列表。其中 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#if"><code>if</code></a> 子句是可选的，如果省略则 <code>range(256)</code> 中的所有元素都会被处理。</p>
<hr>
<p><strong>loader – 加载器</strong></p>
<p>负责加载模块的对象。它必须定义名为 <code>load_module()</code> 的方法。加载器通常由一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-finder">finder</a> 返回。详情参见 <a href="https://www.python.org/dev/peps/pep-0302"><strong>PEP 302</strong></a>，对于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-abstract-base-class">abstract base class</a> 可参见 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code>importlib.abc.Loader</code></a>。</p>
<hr>
<p><strong>magic method – 魔术方法</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-special-method">special method</a> 的非正式同义词 。</p>
<hr>
<p><strong>mapping – 映射</strong></p>
<p>一种支持任意键查找并实现了 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>MutableMapping</code></a> <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections-abstract-base-classes">抽象基类</a> 中所规定方法的容器对象。 此类对象的例子包括 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.defaultdict" title="collections.defaultdict"><code>collections.defaultdict</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.Counter" title="collections.Counter"><code>collections.Counter</code></a>。</p>
<hr>
<p><strong>meta path finder – 元路径查找器</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a> 的搜索所返回的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-finder">finder</a>。元路径查找器与 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry-finder">path entry finders</a> 存在关联但并不相同。</p>
<p>请查看 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code>importlib.abc.MetaPathFinder</code></a> 了解元路径查找器所实现的方法。</p>
<hr>
<p><strong>metaclass – 元类</strong></p>
<p>一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。Python 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p>
<p>更多详情参见 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#metaclasses">元类</a>。</p>
<hr>
<p><strong>method – 方法</strong></p>
<p>在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">argument</a> (通常命名为 <code>self</code>)。参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-function">function</a> 和 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-nested-scope">nested scope</a>。</p>
<hr>
<p><strong>method resolution order – 方法解析顺序</strong></p>
<p>方法解析顺序就是在查找成员时搜索全部基类所用的先后顺序。请查看 <a href="https://www.python.org/download/releases/2.3/mro/">Python 2.3 方法解析顺序</a> 了解自 2.3 版起 Python 解析器所用相关算法的详情。</p>
<hr>
<p><strong>module</strong></p>
<p>此对象是 Python 代码的一种组织单位。各模块具有独立的命名空间，可包含任意 Python 对象。模块可通过 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-importing">importing</a> 操作被加载到 Python 中。</p>
<p>另见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-package">package</a>。</p>
<hr>
<p><strong>module spec – 模块规格</strong></p>
<p>一个命名空间，其中包含用于加载模块的相关导入信息。是 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code>importlib.machinery.ModuleSpec</code></a> 的实例。</p>
<hr>
<p><strong>MRO</strong></p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-method-resolution-order">method resolution order</a>。</p>
<hr>
<p><strong>mutable – 可变对象</strong></p>
<p>可变对象可以在其 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#id" title="id"><code>id()</code></a> 保持固定的情况下改变其取值。另请参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-immutable">immutable</a>。</p>
<hr>
<p><strong>named tuple – 具名元组</strong></p>
<p>术语“具名元组”可用于任何继承自元组，并且其中的可索引元素还能使用名称属性来访问的类型或类。 这样的类型或类还可能拥有其他特性。</p>
<p>有些内置类型属于具名元组，包括 <a href="https://docs.python.org/zh-cn/3.10/library/time.html#time.localtime" title="time.localtime"><code>time.localtime()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.stat" title="os.stat"><code>os.stat()</code></a> 的返回值。 另一个例子是 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.float_info" title="sys.float_info"><code>sys.float_info</code></a>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>sys.float_info[1]                   # indexed access<br>1024<br>sys.float_info.max_exp              # named field access<br>1024<br>isinstance(sys.float_info, tuple)   # kind of tuple<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>有些具名元组是内置类型（例如上面的例子）。 此外，具名元组还可通过常规类定义从 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 继承并定义名称字段的方式来创建。 这样的类可以手工编写，或者使用工厂函数 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.namedtuple" title="collections.namedtuple"><code>collections.namedtuple()</code></a> 创建。 后一种方式还会添加一些手工编写或内置具名元组所没有的额外方法。</p>
<hr>
<p><strong>namespace – 命名空间</strong></p>
<p>命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。命名空间通过防止命名冲突来支持模块化。例如，函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>builtins.open</code></a> 与 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.open" title="os.open"><code>os.open()</code></a> 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。例如，<a href="https://docs.python.org/zh-cn/3.10/library/random.html#random.seed" title="random.seed"><code>random.seed()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#itertools.islice" title="itertools.islice"><code>itertools.islice()</code></a> 这种写法明确了这些函数是由 <a href="https://docs.python.org/zh-cn/3.10/library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code>random</code></a> 与 <a href="https://docs.python.org/zh-cn/3.10/library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code>itertools</code></a> 模块分别实现的。</p>
<hr>
<p><strong>namespace package – 命名空间包</strong></p>
<p><a href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a> 所引入的一种仅被用作子包的容器的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-package">package</a>，命名空间包可以没有实体表示物，其描述方式与 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-regular-package">regular package</a> 不同，因为它们没有 <code>__init__.py</code> 文件。</p>
<p>另可参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-module">module</a>。</p>
<hr>
<p><strong>nested scope – 嵌套作用域</strong></p>
<p>在一个定义范围内引用变量的能力。例如，在另一函数之内定义的函数可以引用前者的变量。请注意嵌套作用域默认只对引用有效而对赋值无效。局部变量的读写都受限于最内层作用域。类似的，全局变量的读写则作用于全局命名空间。通过 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#nonlocal"><code>nonlocal</code></a> 关键字可允许写入外层作用域。</p>
<hr>
<p><strong>new-style class – 新式类</strong></p>
<p>对于目前已被应于所有类对象的类形式的旧称谓。在早先的 Python 版本中，只有新式类能够使用 Python 新增的更灵活特性，例如 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__slots__" title="object.__slots__"><code>__slots__</code></a>、描述符、特征属性、<code>__getattribute__()</code>、类方法和静态方法等。</p>
<hr>
<p><strong>object – 对象</strong></p>
<p>任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-new-style-class">new-style class</a> 的最顶层基类名。</p>
<hr>
<p><strong>包</strong></p>
<p>一种可包含子模块或递归地包含子包的 Python <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-module">module</a>。 从技术上说，包是具有 <code>__path__</code> 属性的 Python 模块。</p>
<p>另参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-regular-package">regular package</a> 和 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-namespace-package">namespace package</a>。</p>
<hr>
<p><strong>parameter – 形参</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-function">function</a> （或方法）定义中的命名实体，它指定函数可以接受的一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">argument</a> （或在某些情况下，多个实参）。有五种形参：</p>
<ul>
<li><p>_positional-or-keyword_：位置或关键字，指定一个可以作为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">位置参数</a> 传入也可以作为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">关键字参数</a> 传入的实参。这是默认的形参类型，例如下面的 <em>foo</em> 和 <em>bar</em>:</p>
<p>  def func(foo, bar&#x3D;None): …</p>
</li>
<li><p>_positional-only_：仅限位置，指定一个只能通过位置传入的参数。 仅限位置形参可通过在函数定义的形参列表中它们之后包含一个 <code>/</code> 字符来定义，例如下面的 <em>posonly1</em> 和 <em>posonly2</em>:</p>
<p>  def func(posonly1, posonly2, &#x2F;, positional_or_keyword): …</p>
</li>
<li><p>_keyword-only_：仅限关键字，指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 <code>*</code> 来定义，例如下面的 <em>kw_only1</em> 和 <em>kw_only2</em>:</p>
<p>  def func(arg, *, kw_only1, kw_only2): …</p>
</li>
<li><p>_var-positional_：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 <code>*</code> 来定义，例如下面的 <em>args</em>:</p>
<p>  def func(*args, **kwargs): …</p>
</li>
<li><p>_var-keyword_：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 <code>**</code> 来定义，例如上面的 _kwargs_。</p>
</li>
</ul>
<p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p>
<p>另参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">argument</a> 术语表条目、<a href="https://docs.python.org/zh-cn/3.10/faq/programming.html#faq-argument-vs-parameter">参数与形参的区别</a> 中的常见问题、<a href="https://docs.python.org/zh-cn/3.10/library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code>inspect.Parameter</code></a> 类、<a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a> 一节以及 <a href="https://www.python.org/dev/peps/pep-0362"><strong>PEP 362</strong></a>。</p>
<hr>
<p><strong>path entry – 路径入口</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-import-path">import path</a> 中的一个单独位置，会被 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-based-finder">path based finder</a> 用来查找要导入的模块。</p>
<hr>
<p><strong>path entry finder – 路径入口查找器</strong></p>
<p>任一可调用对象使用 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.path_hooks" title="sys.path_hooks"><code>sys.path_hooks</code></a> (即 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry-hook">path entry hook</a>) 返回的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-finder">finder</a>，此种对象能通过 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry">path entry</a> 来定位模块。</p>
<p>请参看 <a href="https://docs.python.org/zh-cn/3.10/library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code>importlib.abc.PathEntryFinder</code></a> 以了解路径入口查找器所实现的各个方法。</p>
<hr>
<p><strong>path entry hook – 路径入口钩子</strong></p>
<p>一种可调用对象，在知道如何查找特定 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry">path entry</a> 中的模块的情况下能够使用 <code>sys.path_hook</code> 列表返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-path-entry-finder">path entry finder</a>。</p>
<hr>
<p><strong>path based finder – 基于路径的查找器</strong></p>
<p>默认的一种 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-meta-path-finder">元路径查找器</a>，可在一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-import-path">import path</a> 中查找模块。</p>
<hr>
<p><strong>path-like object – 路径类对象</strong></p>
<p>代表一个文件系统路径的对象。路径类对象可以是一个表示路径的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，还可以是一个实现了 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> 协议的对象。一个支持 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> 协议的对象可通过调用 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.fspath" title="os.fspath"><code>os.fspath()</code></a> 函数转换为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类型的文件系统路径；<a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.fsdecode" title="os.fsdecode"><code>os.fsdecode()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.fsencode" title="os.fsencode"><code>os.fsencode()</code></a> 可被分别用来确保获得 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类型的结果。此对象是由 <a href="https://www.python.org/dev/peps/pep-0519"><strong>PEP 519</strong></a> 引入的。</p>
<hr>
<p><strong>PEP</strong></p>
<p>“Python 增强提议”的英文缩写。一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p>
<p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 Python 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p>
<p>参见 <a href="https://www.python.org/dev/peps/pep-0001"><strong>PEP 1</strong></a>。</p>
<hr>
<p><strong>portion – 部分</strong></p>
<p>构成一个命名空间包的单个目录内文件集合（也可能存放于一个 zip 文件内），具体定义见 <a href="https://www.python.org/dev/peps/pep-0420"><strong>PEP 420</strong></a>。</p>
<hr>
<p><strong>positional argument – 位置参数</strong></p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-argument">argument</a>。</p>
<hr>
<p><strong>provisional API – 暂定 API</strong></p>
<p>暂定 API 是指被有意排除在标准库的向后兼容性保证之外的应用编程接口。虽然此类接口通常不会再有重大改变，但只要其被标记为暂定，就可能在核心开发者确定有必要的情况下进行向后不兼容的更改（甚至包括移除该接口）。此种更改并不会随意进行 – 仅在 API 被加入之前未考虑到的严重基础性缺陷被发现时才可能会这样做。</p>
<p>即便是对暂定 API 来说，向后不兼容的更改也会被视为“最后的解决方案” —— 任何问题被确认时都会尽可能先尝试找到一种向后兼容的解决方案。</p>
<p>这种处理过程允许标准库持续不断地演进，不至于被有问题的长期性设计缺陷所困。详情见 <a href="https://www.python.org/dev/peps/pep-0411"><strong>PEP 411</strong></a>。</p>
<hr>
<p><strong>provisional package – 暂定包</strong></p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-provisional-API">provisional API</a>。</p>
<hr>
<p><strong>Python 3000</strong></p>
<p>Python 3.x 发布路线的昵称（这个名字在版本 3 的发布还遥遥无期的时候就已出现了）。有时也被缩写为“Py3k”。</p>
<hr>
<p><strong>Pythonic</strong></p>
<p>指一个思路或一段代码紧密遵循了 Python 语言最常用的风格和理念，而不是使用其他语言中通用的概念来实现代码。例如，Python 的常用风格是使用 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for"><code>for</code></a> 语句循环来遍历一个可迭代对象中的所有元素。许多其他语言没有这样的结构，因此不熟悉 Python 的人有时会选择使用一个数字计数器:</p>
<p>for i in range(len(food)):<br>    print(food[i])</p>
<p>而相应的更简洁更 Pythonic 的方法是这样的:</p>
<p>for piece in food:<br>    print(piece)</p>
<hr>
<p><strong>qualified name – 限定名称</strong></p>
<p>一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类、函数或方法的“路径”，相关定义见 <a href="https://www.python.org/dev/peps/pep-3155"><strong>PEP 3155</strong></a>。对于最高层级的函数和类，限定名称与对象名称一致:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class C:<br>…     class D:<br>…         def meth(self):<br>…             pass<br>…<br>C.<strong>qualname</strong><br>‘C’<br>C.D.<strong>qualname</strong><br>‘C.D’<br>C.D.meth.<strong>qualname</strong><br>‘C.D.meth’</p>
</blockquote>
</blockquote>
</blockquote>
<p>当被用于引用模块时，<em>完整限定名称</em> 意为标示该模块的以点号分隔的整个路径，其中包含其所有的父包，例如 <code>email.mime.text</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import email.mime.text<br>email.mime.text.<strong>name</strong><br>‘email.mime.text’</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p><strong>reference count – 引用计数</strong></p>
<p>对特定对象的引用的数量。当一个对象的引用计数降为零时，所分配资源将被释放。引用计数对 Python 代码来说通常是不可见的，但它是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-CPython">CPython</a> 实现的一个关键元素。<a href="https://docs.python.org/zh-cn/3.10/library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code>sys</code></a> 模块定义了一个 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.getrefcount" title="sys.getrefcount"><code>getrefcount()</code></a> 函数，程序员可调用它来返回特定对象的引用计数。</p>
<hr>
<p><strong>regular package – 常规包</strong></p>
<p>传统型的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-package">package</a>，例如包含有一个 <code>__init__.py</code> 文件的目录。</p>
<p>另参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-namespace-package">namespace package</a>。</p>
<hr>
<p><strong>slots</strong></p>
<p>一种写在类内部的声明，通过预先声明实例属性等对象并移除实例字典来节省内存。虽然这种技巧很流行，但想要用好却并不容易，最好是只保留在少数情况下采用，例如极耗内存的应用程序，并且其中包含大量实例。</p>
<hr>
<p><strong>sequence</strong></p>
<p>一种 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a>，它支持通过 <code>__getitem__()</code> 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 <code>__len__()</code> 方法。内置的序列类型有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a>。注意虽然 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 也支持 <code>__getitem__()</code> 和 <code>__len__()</code>，但它被认为属于映射而非序列，因为它查找时使用任意的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-immutable">immutable</a> 键而非整数。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a> 抽象基类定义了一个更丰富的接口，它在 <code>__getitem__()</code> 和 <code>__len__()</code> 之外又添加了 <code>count()</code>, <code>index()</code>, <code>__contains__()</code> 和 <code>__reversed__()</code>。 实现此扩展接口的类型可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code>register()</code></a> 来显式地注册。</p>
<hr>
<p><strong>set comprehension – 集合推导式</strong></p>
<p>处理一个可迭代对象中的所有或部分元素并返回结果集合的一种紧凑写法。 <code>results = &#123;c for c in &#39;abracadabra&#39; if c not in &#39;abc&#39;&#125;</code> 将生成字符串集合 <code>&#123;&#39;r&#39;, &#39;d&#39;&#125;</code>。 参见 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#comprehensions">列表、集合与字典的显示</a>。</p>
<hr>
<p><strong>single dispatch – 单分派</strong></p>
<p>一种 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generic-function">generic function</a> 分派形式，其实现是基于单个参数的类型来选择的。</p>
<hr>
<p><strong>slice – 切片</strong></p>
<p>通常只包含了特定 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-sequence">sequence</a> 的一部分的对象。切片是通过使用下标标记来创建的，在 <code>[]</code> 中给出几个以冒号分隔的数字，例如 <code>variable_name[1:3:5]</code>。方括号（下标）标记在内部使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#slice" title="slice"><code>slice</code></a> 对象。</p>
<hr>
<p><strong>special method – 特殊方法</strong></p>
<p>一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。特殊方法的文档参见 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#specialnames">特殊方法名称</a>。</p>
<hr>
<p><strong>statement – 语句</strong></p>
<p>语句是程序段（一个代码“块”）的组成单位。一条语句可以是一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-expression">expression</a> 或某个带有关键字的结构，例如 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#if"><code>if</code></a>、<a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#while"><code>while</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for"><code>for</code></a>。</p>
<hr>
<p><strong>strong reference – 强引用</strong></p>
<p>在 Python 的 C API 中，强引用是指为持有引用的代码所拥有的对象的引用。 在创建引用时可通过调用 <a href="https://docs.python.org/zh-cn/3.10/c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code>Py_INCREF()</code></a> 来获取强引用而在删除引用时可通过 <a href="https://docs.python.org/zh-cn/3.10/c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> 来释放它。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code>Py_NewRef()</code></a> 函数可被用于创建一个对象的强引用。 通常，必须在退出某个强引用的作用域时在该强引用上调用 <a href="https://docs.python.org/zh-cn/3.10/c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code>Py_DECREF()</code></a> 函数，以避免引用的泄漏。</p>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-borrowed-reference">borrowed reference</a>。</p>
<hr>
<p><strong>text encoding – 文本编码格式</strong></p>
<p>在Python中，一个字符串是一串 Unicode 代码点（范围为 <code>U+0000</code>–<code>U+10FFFF</code>）。 为了存储或传输一个字符串，它需要被序列化为一串字节。</p>
<p>将一个字符串序列化为一个字节序列被称为 “编码”，而从字节序列中重新创建字符串被称为 “解码”。</p>
<p>有各种不同的文本序列化 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#standard-encodings">编码器</a> ，它们被统称为 “文本编码格式”。</p>
<hr>
<p><strong>text file – 文本文件</strong></p>
<p>一种能够读写 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 对象的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">file object</a>。通常一个文本文件实际是访问一个面向字节的数据流并自动处理 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-text-encoding">text encoding</a>。文本文件的例子包括以文本模式（<code>&#39;r&#39;</code> 或 <code>&#39;w&#39;</code>）打开的文件、<a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.stdin" title="sys.stdin"><code>sys.stdin</code></a>、<a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.stdout" title="sys.stdout"><code>sys.stdout</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.StringIO" title="io.StringIO"><code>io.StringIO</code></a> 的实例。</p>
<p>另请参看 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-binary-file">binary file</a> 了解能够读写 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">字节类对象</a> 的文件对象。</p>
<hr>
<p><strong>triple-quoted string – 三引号字符串</strong></p>
<p>首尾各带三个连续双引号（”）或者单引号（’）的字符串。它们在功能上与首尾各用一个引号标注的字符串没有什么不同，但是有多种用处。它们允许你在字符串内包含未经转义的单引号和双引号，并且可以跨越多行而无需使用连接符，在编写文档字符串时特别好用。</p>
<hr>
<p><strong>type</strong></p>
<p>类型决定一个 Python 对象属于什么种类；每个对象都具有一种类型。要知道对象的类型，可以访问它的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#instance.__class__" title="instance.__class__"><code>__class__</code></a> 属性，或是通过 <code>type(obj)</code> 来获取。</p>
<hr>
<p><strong>type alias – 类型别名</strong></p>
<p>一个类型的同义词，创建方式是把类型赋值给特定的标识符。</p>
<p>类型别名的作用是简化 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-type-hint">类型注解</a>。例如:</p>
<p>def remove_gray_shades(<br>        colors: list[tuple[int, int, int]]) -&gt; list[tuple[int, int, int]]:<br>    pass</p>
<p>可以这样提高可读性:</p>
<p>Color &#x3D; tuple[int, int, int]</p>
<p>def remove_gray_shades(colors: list[Color]) -&gt; list[Color]:<br>    pass</p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code>typing</code></a> 和 <a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>，其中有对此功能的详细描述。</p>
<p>type hint – 类型注解</p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">annotation</a> 为变量、类属性、函数的形参或返回值指定预期的类型。</p>
<p>类型注解属于可选项，Python 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p>
<p>全局变量、类属性和函数的类型注解可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code>typing.get_type_hints()</code></a> 来访问，但局部变量则不可以。</p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code>typing</code></a> 和 <a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a>，其中有对此功能的详细描述。</p>
<p>universal newlines – 通用换行</p>
<p>一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 <code>&#39;\n&#39;</code>、Windows 的约定 <code>&#39;\r\n&#39;</code> 以及旧版 Macintosh 的约定 <code>&#39;\r&#39;</code>。参见 <a href="https://www.python.org/dev/peps/pep-0278"><strong>PEP 278</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-3116"><strong>PEP 3116</strong></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code>bytes.splitlines()</code></a> 了解更多用法说明。</p>
<hr>
<p><strong>variable annotation – 变量标注</strong></p>
<p>对变量或类属性的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">annotation</a>。</p>
<p>在标注变量或类属性时，还可选择为其赋值:</p>
<p>class C:<br>    field: ‘annotation’</p>
<p>变量标注通常被用作 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-type-hint">类型注解</a>：例如以下变量预期接受 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 类型的值:</p>
<p>count: int &#x3D; 0</p>
<p>变量标注语法的详细解释见 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#annassign">带标注的赋值语句</a> 一节。</p>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-function-annotation">function annotation</a>, <a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0526"><strong>PEP 526</strong></a>，其中描述了此功能。 另请参阅 <a href="https://docs.python.org/zh-cn/3.10/howto/annotations.html#annotations-howto">对象注解属性的最佳实践</a> 以了解使用标注的最佳实践。</p>
<p>virtual environment – 虚拟环境</p>
<p>一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。</p>
<p>另参见 <a href="https://docs.python.org/zh-cn/3.10/library/venv.html#module-venv" title="venv: Creation of virtual environments."><code>venv</code></a>。</p>
<p>virtual machine – 虚拟机</p>
<p>一台完全通过软件定义的计算机。Python 虚拟机可执行字节码编译器所生成的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytecode">bytecode</a>。</p>
<hr>
<p><strong>Zen of Python – Python 之禅</strong></p>
<p>列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 “<code>import this</code>“。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/08/Python/%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>以下部分描述了解释器中内置的标准类型。</p>
<p>主要内置类型有数字、序列、映射、类、实例和异常。</p>
<p>有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 <code>None</code>。</p>
<p>有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以及转换为字符串（使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 函数或略有差异的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 函数）。 后一个函数是在对象由 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#print" title="print"><code>print()</code></a> 函数输出时被隐式地调用的。</p>
<h2 id="逻辑值检测"><a href="#逻辑值检测" class="headerlink" title="逻辑值检测"></a>逻辑值检测</h2><p>任何对象都可以进行逻辑值的检测，以便在 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#if"><code>if</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#while"><code>while</code></a> 作为条件或是作为下文所述布尔运算的操作数来使用。</p>
<p>一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 <code>__bool__()</code> 方法且返回 <code>False</code> 或是定义了 <code>__len__()</code> 方法且返回零。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id12">1</a> 下面基本完整地列出了会被视为假值的内置对象:</p>
<ul>
<li><p>被定义为假值的常量: <code>None</code> 和 <code>False</code>。</p>
</li>
<li><p>任何数值类型的零: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></p>
</li>
<li><p>空的序列和多项集: <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>, <code>&#123;&#125;</code>, <code>set()</code>, <code>range(0)</code></p>
</li>
</ul>
<p>产生布尔值结果的运算和内置函数总是返回 <code>0</code> 或 <code>False</code> 作为假值，<code>1</code> 或 <code>True</code> 作为真值，除非另行说明。 （重要例外：布尔运算 <code>or</code> 和 <code>and</code> 总是返回其中一个操作数。）</p>
<h2 id="布尔运算-—-and-or-not"><a href="#布尔运算-—-and-or-not" class="headerlink" title="布尔运算 — and, or, not"></a>布尔运算 — <code>and</code>, <code>or</code>, <code>not</code></h2><p>这些属于布尔运算，按优先级升序排列:</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>x or y</code></td>
<td>如果 <em>x</em> 为真值，则 _x_，否则 <em>y</em></td>
<td>(1)</td>
</tr>
<tr>
<td><code>x and y</code></td>
<td>if <em>x</em> is false, then <em>x</em>, else <em>y</em></td>
<td>(2)</td>
</tr>
<tr>
<td><code>not x</code></td>
<td>if <em>x</em> is false, then <code>True</code>, else <code>False</code></td>
<td>(3)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。</p>
</li>
<li><p>这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。</p>
</li>
<li><p><code>not</code> 的优先级比非布尔运算符低，因此 <code>not a == b</code> 会被解读为 <code>not (a == b)</code> 而 <code>a == not b</code> 会引发语法错误。</p>
</li>
</ol>
<h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，<code>x &lt; y &lt;= z</code> 等价于 <code>x &lt; y and y &lt;= z</code>，前者的不同之处在于 <em>y</em> 只被求值一次（但在两种情况下当 <code>x &lt; y</code> 结果为假值时 <em>z</em> 都不会被求值）。</p>
<p>此表格汇总了比较运算:</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;</code></td>
<td>严格小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>严格大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于或等于</td>
</tr>
<tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>is</code></td>
<td>对象标识</td>
</tr>
<tr>
<td><code>is not</code></td>
<td>否定的对象标识</td>
</tr>
</tbody></table>
<p>除不同的数字类型外，不同类型的对象不能进行相等比较。<code>==</code> 运算符总有定义，但对于某些对象类型（例如，类对象），它等于 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#is"><code>is</code></a> 。其他 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 运算符仅在有意义的地方定义。例如，当参与比较的参数之一为复数时，它们会抛出 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a> 异常。</p>
<p>具有不同标识的类的实例比较结果通常为不相等，除非类定义了 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> 方法。</p>
<p>一个类的实例不能与相同类的其他实例或其他类型的对象进行排序，除非定义该类定义了足够多的方法，包括 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__lt__" title="object.__lt__"><code>__lt__()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__le__" title="object.__le__"><code>__le__()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__gt__" title="object.__gt__"><code>__gt__()</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__ge__" title="object.__ge__"><code>__ge__()</code></a> (而如果你想实现常规意义上的比较操作，通常只要有 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__lt__" title="object.__lt__"><code>__lt__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__eq__" title="object.__eq__"><code>__eq__()</code></a> 就可以了)。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#is"><code>is</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#is-not"><code>is not</code></a> 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。</p>
<p>还有两种具有相同语法优先级的运算 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#in"><code>in</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#not-in"><code>not in</code></a>，它们被 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a> 或实现了 <code>__contains__()</code> 方法的类型所支持。</p>
<h2 id="数字类型-—int-float-complex"><a href="#数字类型-—int-float-complex" class="headerlink" title="数字类型 —int,float,complex"></a>数字类型 —<code>int</code>,<code>float</code>,<code>complex</code></h2><p>存在三种不同的数字类型: <em>整数</em>, <em>浮点数</em> 和 _复数_。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 浮点数通常使用 C 中的 <code>double</code> 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.float_info" title="sys.float_info"><code>sys.float_info</code></a> 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 <em>z</em> 中提取这两个部分，可使用 <code>z.real</code> 和 <code>z.imag</code>。 （标准库包含附加的数字类型，如表示有理数的 <a href="https://docs.python.org/zh-cn/3.10/library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code>fractions.Fraction</code></a> 以及以用户定制精度表示浮点数的 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>decimal.Decimal</code></a>。）</p>
<p>数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 <code>&#39;j&#39;</code> 或 <code>&#39;J&#39;</code> 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。</p>
<p>Python 完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，”较窄”类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id13">2</a></p>
<p>构造函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int()</code></a>、 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex()</code></a> 可以用来构造特定类型的数字。</p>
<p>所有数字类型（复数除外）都支持下列运算（有关运算优先级，请参阅：<a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#operator-summary">运算符优先级</a>）:</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
<th>备注</th>
<th>完整文档</th>
</tr>
</thead>
<tbody><tr>
<td><code>x + y</code></td>
<td><em>x</em> 和 <em>y</em> 的和</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x - y</code></td>
<td><em>x</em> 和 <em>y</em> 的差</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x * y</code></td>
<td><em>x</em> 和 <em>y</em> 的乘积</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x / y</code></td>
<td><em>x</em> 和 <em>y</em> 的商</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x // y</code></td>
<td><em>x</em> 和 <em>y</em> 的商数</td>
<td>(1)</td>
<td></td>
</tr>
<tr>
<td><code>x % y</code></td>
<td><code>x / y</code> 的余数</td>
<td>(2)</td>
<td></td>
</tr>
<tr>
<td><code>-x</code></td>
<td><em>x</em> 取反</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>+x</code></td>
<td><em>x</em> 不变</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>abs(x)</code></td>
<td><em>x</em> 的绝对值或大小</td>
<td></td>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#abs" title="abs"><code>abs()</code></a></td>
</tr>
<tr>
<td><code>int(x)</code></td>
<td>将 <em>x</em> 转换为整数</td>
<td>(3)(6)</td>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int()</code></a></td>
</tr>
<tr>
<td><code>float(x)</code></td>
<td>将 <em>x</em> 转换为浮点数</td>
<td>(4)(6)</td>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float()</code></a></td>
</tr>
<tr>
<td><code>complex(re, im)</code></td>
<td>一个带有实部 <em>re</em> 和虚部 <em>im</em> 的复数。<em>im</em> 默认为0。</td>
<td>(6)</td>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex()</code></a></td>
</tr>
<tr>
<td><code>c.conjugate()</code></td>
<td>复数 <em>c</em> 的共轭</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>divmod(x, y)</code></td>
<td><code>(x // y, x % y)</code></td>
<td>(2)</td>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#divmod" title="divmod"><code>divmod()</code></a></td>
</tr>
<tr>
<td><code>pow(x, y)</code></td>
<td><em>x</em> 的 <em>y</em> 次幂</td>
<td>(5)</td>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#pow" title="pow"><code>pow()</code></a></td>
</tr>
<tr>
<td><code>x ** y</code></td>
<td><em>x</em> 的 <em>y</em> 次幂</td>
<td>(5)</td>
<td></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: <code>1//2</code> 为 <code>0</code>, <code>(-1)//2</code> 为 <code>-1</code>, <code>1//(-2)</code> 为 <code>-1</code> 而 <code>(-1)//(-2)</code> 为 <code>0</code>。</p>
</li>
<li><p>不可用于复数。 而应在适当条件下使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#abs" title="abs"><code>abs()</code></a> 转换为浮点数。</p>
</li>
<li><p>从 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 将会执行截断，丢弃掉小数部分。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/math.html#math.floor" title="math.floor"><code>math.floor()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/math.html#math.ceil" title="math.ceil"><code>math.ceil()</code></a> 函数了解替代的转换方式。</p>
</li>
<li><p>float 也接受字符串 “nan” 和附带可选前缀 “+” 或 “-“ 的 “inf” 分别表示非数字 (NaN) 以及正或负无穷。</p>
</li>
<li><p>Python 将 <code>pow(0, 0)</code> 和 <code>0 ** 0</code> 定义为 <code>1</code>，这是编程语言的普遍做法。</p>
</li>
<li><p>接受的数字字面值包括数码 <code>0</code> 到 <code>9</code> 或任何等效的 Unicode 字符（具有 <code>Nd</code> 特征属性的代码点）。</p>
<p> 请参阅 <a href="https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt">https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt</a> 查看具有 <code>Nd</code> 特征属性的代码点的完整列表。</p>
</li>
</ol>
<p>所有 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#numbers.Real" title="numbers.Real"><code>numbers.Real</code></a> 类型 (<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a>) 还包括下列运算:</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.python.org/zh-cn/3.10/library/math.html#math.trunc" title="math.trunc"><code>math.trunc(x)</code></a></td>
<td><em>x</em> 截断为 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#numbers.Integral" title="numbers.Integral"><code>Integral</code></a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#round" title="round"><code>round(x[, n])</code></a></td>
<td><em>x</em> 舍入到 <em>n</em> 位小数，半数值会舍入到偶数。 如果省略 _n_，则默认为 0。</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.10/library/math.html#math.floor" title="math.floor"><code>math.floor(x)</code></a></td>
<td>&lt;&#x3D; <em>x</em> 的最大 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#numbers.Integral" title="numbers.Integral"><code>Integral</code></a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.10/library/math.html#math.ceil" title="math.ceil"><code>math.ceil(x)</code></a></td>
<td>&gt;&#x3D; <em>x</em> 的最小 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#numbers.Integral" title="numbers.Integral"><code>Integral</code></a></td>
</tr>
</tbody></table>
<p>有关更多的数字运算请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code>math</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code>cmath</code></a> 模块。</p>
<h3 id="整数类型的按位运算"><a href="#整数类型的按位运算" class="headerlink" title="整数类型的按位运算"></a>整数类型的按位运算</h3><p>按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。</p>
<p>二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 <code>~</code> 具有与其他一元算术运算 (<code>+</code> and <code>-</code>) 相同的优先级。</p>
<p>此表格是以优先级升序排序的按位运算列表:</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>x | y</code></td>
<td><em>x</em> 和 <em>y</em> 按位 <em>或</em></td>
<td>(4)</td>
</tr>
<tr>
<td><code>x ^ y</code></td>
<td><em>x</em> 和 <em>y</em> 按位 <em>异或</em></td>
<td>(4)</td>
</tr>
<tr>
<td><code>x &amp; y</code></td>
<td><em>x</em> 和 <em>y</em> 按位 <em>与</em></td>
<td>(4)</td>
</tr>
<tr>
<td><code>x &lt;&lt; n</code></td>
<td><em>x</em> 左移 <em>n</em> 位</td>
<td>(1)(2)</td>
</tr>
<tr>
<td><code>x &gt;&gt; n</code></td>
<td><em>x</em> 右移 <em>n</em> 位</td>
<td>(1)(3)</td>
</tr>
<tr>
<td><code>~x</code></td>
<td><em>x</em> 逐位取反</td>
<td></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>负的移位数是非法的，会导致引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
</li>
<li><p>左移 <em>n</em> 位等价于乘以 <code>pow(2, n)</code> 。</p>
</li>
<li><p>右移 <em>n</em> 位等价于除以 <code>pow(2, n)</code> ，作向下取整除法。</p>
</li>
<li><p>使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 <code>1 + max(x.bit_length(), y.bit_length())</code> 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。</p>
</li>
</ol>
<h3 id="整数类型的附加方法"><a href="#整数类型的附加方法" class="headerlink" title="整数类型的附加方法"></a>整数类型的附加方法</h3><p>int 类型实现了 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#numbers.Integral" title="numbers.Integral"><code>numbers.Integral</code></a> <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-abstract-base-class">abstract base class</a>。 此外，它还提供了其他几个方法:</p>
<p><code>int.``bit_length</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.bit_length" title="永久链接至目标"></a></p>
<p>返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>n &#x3D; -37<br>bin(n)<br>‘-0b100101’<br>n.bit_length()<br>6</p>
</blockquote>
</blockquote>
</blockquote>
<p>更准确地说，如果 <code>x</code> 非零，则 <code>x.bit_length()</code> 是使得 <code>2**(k-1) &lt;= abs(x) &lt; 2**k</code> 的唯一正整数 <code>k</code>。 同样地，当 <code>abs(x)</code> 小到足以具有正确的舍入对数时，则 <code>k = 1 + int(log(abs(x), 2))</code>。 如果 <code>x</code> 为零，则 <code>x.bit_length()</code> 返回 <code>0</code>。</p>
<p>等价于:</p>
<p>def bit_length(self):<br>    s &#x3D; bin(self)       # binary representation:  bin(-37) –&gt; ‘-0b100101’<br>    s &#x3D; s.lstrip(‘-0b’) # remove leading zeros and minus sign<br>    return len(s)       # len(‘100101’) –&gt; 6</p>
<p>3.1 新版功能.</p>
<p><code>int.``bit_count</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.bit_count" title="永久链接至目标"></a></p>
<p>返回整数的绝对值的二进制表示中 1 的个数。也被称为 population count。示例:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>n &#x3D; 19<br>bin(n)<br>‘0b10011’<br>n.bit_count()<br>3<br>(-n).bit_count()<br>3</p>
</blockquote>
</blockquote>
</blockquote>
<p>等价于:</p>
<p>def bit_count(self):<br>    return bin(self).count(“1”)</p>
<p>3.10 新版功能.</p>
<p><code>int.``to_bytes</code>(<em>length</em>, <em>byteorder</em>, <em>*</em>, <em>signed&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.to_bytes" title="永久链接至目标"></a></p>
<p>返回表示一个整数的字节数组。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>(1024).to_bytes(2, byteorder&#x3D;’big’)<br>b’\x04\x00’<br>(1024).to_bytes(10, byteorder&#x3D;’big’)<br>b’\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00’<br>(-1024).to_bytes(10, byteorder&#x3D;’big’, signed&#x3D;True)<br>b’\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00’<br>x &#x3D; 1000<br>x.to_bytes((x.bit_length() + 7) &#x2F;&#x2F; 8, byteorder&#x3D;’little’)<br>b’\xe8\x03’</p>
</blockquote>
</blockquote>
</blockquote>
<p>整数会使用 <em>length</em> 个字节来表示。 如果整数不能用给定的字节数来表示则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code>&quot;big&quot;</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>&quot;little&quot;</code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.byteorder" title="sys.byteorder"><code>sys.byteorder</code></a> 作为字节顺序值。</p>
<p><em>signed</em> 参数确定是否使用二的补码来表示整数。 如果 <em>signed</em> 为 <code>False</code> 并且给出的是负整数，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>。 <em>signed</em> 的默认值为 <code>False</code>。</p>
<p>3.2 新版功能.</p>
<p><em>classmethod</em> <code>int.``from_bytes</code>(<em>bytes</em>, <em>byteorder</em>, <em>*</em>, <em>signed&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.from_bytes" title="永久链接至目标"></a></p>
<p>返回由给定字节数组所表示的整数。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>int.from_bytes(b’\x00\x10’, byteorder&#x3D;’big’)<br>16<br>int.from_bytes(b’\x00\x10’, byteorder&#x3D;’little’)<br>4096<br>int.from_bytes(b’\xfc\x00’, byteorder&#x3D;’big’, signed&#x3D;True)<br>-1024<br>int.from_bytes(b’\xfc\x00’, byteorder&#x3D;’big’, signed&#x3D;False)<br>64512<br>int.from_bytes([255, 0, 0], byteorder&#x3D;’big’)<br>16711680</p>
</blockquote>
</blockquote>
</blockquote>
<p><em>bytes</em> 参数必须为一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 或是生成字节的可迭代对象。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code>&quot;big&quot;</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>&quot;little&quot;</code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.byteorder" title="sys.byteorder"><code>sys.byteorder</code></a> 作为字节顺序值。</p>
<p><em>signed</em> 参数指明是否使用二的补码来表示整数。</p>
<p>3.2 新版功能.</p>
<p><code>int.``as_integer_ratio</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.as_integer_ratio" title="永久链接至目标"></a></p>
<p>返回一对整数，其比率正好等于原整数并且分母为正数。 整数的比率总是用这个整数本身作为分子，<code>1</code> 作为分母。</p>
<p>3.8 新版功能.</p>
<h3 id="浮点类型的附加方法"><a href="#浮点类型的附加方法" class="headerlink" title="浮点类型的附加方法"></a>浮点类型的附加方法</h3><p>float 类型实现了 <a href="https://docs.python.org/zh-cn/3.10/library/numbers.html#numbers.Real" title="numbers.Real"><code>numbers.Real</code></a> <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-abstract-base-class">abstract base class</a>。 float 还具有以下附加方法。</p>
<p><code>float.``as_integer_ratio</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.as_integer_ratio" title="永久链接至目标"></a></p>
<p>返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a> 而 NaN 则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p><code>float.``is_integer</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.is_integer" title="永久链接至目标"></a></p>
<p>如果 float 实例可用有限位整数表示则返回 <code>True</code>，否则返回 <code>False</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>(-2.0).is_integer()<br>True<br>(3.2).is_integer()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 <em>十进制数</em> 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。</p>
<p><code>float.``hex</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.hex" title="永久链接至目标"></a></p>
<p>以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 <code>0x</code> 和尾随的 <code>p</code> 加指数。</p>
<p><em>classmethod</em> <code>float.``fromhex</code>(<em>s</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.fromhex" title="永久链接至目标"></a></p>
<p>返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法。 字符串 <em>s</em> 可以带有前导和尾随的空格。</p>
<p>请注意 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.hex" title="float.hex"><code>float.hex()</code></a> 是实例方法，而 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.fromhex" title="float.fromhex"><code>float.fromhex()</code></a> 是类方法。</p>
<p>十六进制字符串采用的形式为:</p>
<p>[sign] [‘0x’] integer [‘.’ fraction] [‘p’ exponent]</p>
<p>可选的 <code>sign</code> 可以是 <code>+</code> 或 <code>-</code>，<code>integer</code> 和 <code>fraction</code> 是十六进制数码组成的字符串，<code>exponent</code> 是带有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction 中必须至少有一个十六进制数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。 特别地，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.hex" title="float.hex"><code>float.hex()</code></a> 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 <code>%a</code> 格式字符或 Java 的 <code>Double.toHexString</code> 所生成的十六进制数字符串由为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#float.fromhex" title="float.fromhex"><code>float.fromhex()</code></a> 所接受。</p>
<p>请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制数字符串 <code>0x3.a7p10</code> 表示浮点数 <code>(3 + 10./16 + 7./16**2) * 2.0**10</code> 即 <code>3740.0</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>float.fromhex(‘0x3.a7p10’)<br>3740.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>对 <code>3740.0</code> 应用反向转换会得到另一个代表相同数值的十六进制数字符串:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>float.hex(3740.0)<br>‘0x1.d380000000000p+11’</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="数字类型的哈希运算"><a href="#数字类型的哈希运算" class="headerlink" title="数字类型的哈希运算"></a>数字类型的哈希运算</h3><p>对于可能为不同类型的数字 <code>x</code> 和 <code>y</code>，要求 <code>x == y</code> 时必定 <code>hash(x) == hash(y)</code> (详情参见 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__hash__" title="object.__hash__"><code>__hash__()</code></a> 方法的文档)。 为了便于在各种数字类型 (包括 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>decimal.Decimal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code>fractions.Fraction</code></a>) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code>fractions.Fraction</code></a> 的全部实例，以及 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>decimal.Decimal</code></a> 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 <code>P</code> 进行 <code>P</code> 降模给出的。 <code>P</code> 的值在 Python 中可以 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.hash_info" title="sys.hash_info"><code>sys.hash_info</code></a> 的 <code>modulus</code> 属性的形式被访问。</p>
<p><strong>CPython 实现细节：</strong> 目前所用的质数设定，在 C long 为 32 位的机器上 <code>P = 2**31 - 1</code> 而在 C long 为 64 位的机器上 <code>P = 2**61 - 1</code>。</p>
<p>详细规则如下所述:</p>
<ul>
<li><p>如果 <code>x = m / n</code> 是一个非负的有理数且 <code>n</code> 不可被 <code>P</code> 整除，则定义 <code>hash(x)</code> 为 <code>m * invmod(n, P) % P</code>，其中 <code>invmod(n, P)</code> 是对 <code>n</code> 模 <code>P</code> 取反。</p>
</li>
<li><p>如果 <code>x = m / n</code> 是一个非负的有理数且 <code>n</code> 可被 <code>P</code> 整除（但 <code>m</code> 不能）则 <code>n</code> 不能对 <code>P</code> 降模，以上规则不适用；在此情况下则定义 <code>hash(x)</code> 为常数值 <code>sys.hash_info.inf</code>。</p>
</li>
<li><p>如果 <code>x = m / n</code> 是一个负的有理数则定义 <code>hash(x)</code> 为 <code>-hash(-x)</code>。 如果结果哈希值为 <code>-1</code> 则将其替换为 <code>-2</code>。</p>
</li>
<li><p>特殊值 <code>sys.hash_info.inf</code> 和 <code>-sys.hash_info.inf</code> 分别用于正无穷或负无穷的哈希值。</p>
</li>
<li><p>对于一个 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex</code></a> 值 <code>z</code>，会通过计算 <code>hash(z.real) + sys.hash_info.imag * hash(z.imag)</code> 将实部和虚部的哈希值结合起来，并进行降模 <code>2**sys.hash_info.width</code> 以使其处于 <code>range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))</code> 范围之内。 同样地，如果结果为 <code>-1</code> 则将其替换为 <code>-2</code>。</p>
</li>
</ul>
<p>为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex</code></a> 的哈希值:</p>
<p>import sys, math</p>
<p>def hash_fraction(m, n):<br>    “””Compute the hash of a rational number m &#x2F; n.</p>
<pre><code>Assumes m and n are integers, with n positive.
Equivalent to hash(fractions.Fraction(m, n)).

&quot;&quot;&quot;
P = sys.hash_info.modulus
# Remove common factors of P.  (Unnecessary if m and n already coprime.)
while m % P == n % P == 0:
    m, n = m // P, n // P

if n % P == 0:
    hash_value = sys.hash_info.inf
else:
    # Fermat&#39;s Little Theorem: pow(n, P-1, P) is 1, so
    # pow(n, P-2, P) gives the inverse of n modulo P.
    hash_value = (abs(m) % P) * pow(n, P - 2, P) % P
if m &lt; 0:
    hash_value = -hash_value
if hash_value == -1:
    hash_value = -2
return hash_value
</code></pre>
<p>def hash_float(x):<br>    “””Compute the hash of a float x.”””</p>
<pre><code>if math.isnan(x):
    return object.__hash__(x)
elif math.isinf(x):
    return sys.hash_info.inf if x &gt; 0 else -sys.hash_info.inf
else:
    return hash_fraction(*x.as_integer_ratio())
</code></pre>
<p>def hash_complex(z):<br>    “””Compute the hash of a complex number z.”””</p>
<pre><code>hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
# do a signed reduction modulo 2**sys.hash_info.width
M = 2**(sys.hash_info.width - 1)
hash_value = (hash_value &amp; (M - 1)) - (hash_value &amp; M)
if hash_value == -1:
    hash_value = -2
return hash_value
</code></pre>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p>
<p>容器对象要提供 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a> 支持，必须定义一个方法:</p>
<p><code>container.``__iter__</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#container.__iter__" title="永久链接至目标"></a></p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结果。） 此方法对应于 Python&#x2F;C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.10/c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code>tp_iter</code></a> 槽位。</p>
<p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em>迭代器协议</em>:</p>
<p><code>iterator.``__iter__</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__iter__" title="永久链接至目标"></a></p>
<p>返回 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 对象本身。 这是同时允许容器和迭代器配合 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for"><code>for</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#in"><code>in</code></a> 语句使用所必须的。 此方法对应于 Python&#x2F;C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.10/c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code>tp_iter</code></a> 槽位。</p>
<p><code>iterator.``__next__</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterator">iterator</a> 中返回下一项。 如果已经没有可返回的项，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 异常。 此方法对应于 Python&#x2F;C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.10/c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code>tp_iternext</code></a> 槽位。</p>
<p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p>
<p>一旦迭代器的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> 方法引发了 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p>
<h3 id="生成器类型"><a href="#生成器类型" class="headerlink" title="生成器类型"></a>生成器类型</h3><p>Python 的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator">generator</a> 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <code>__iter__()</code> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <code>__iter__()</code> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#generator.__next__" title="generator.__next__"><code>__next__()</code></a> 方法。 有关生成器的更多信息可以参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#yieldexpr">yield 表达式的文档</a>。</p>
<h2 id="序列类型-—-list-tuple-range"><a href="#序列类型-—-list-tuple-range" class="headerlink" title="序列类型 — list``tuple``range"></a>序列类型 — <code>list``tuple``range</code></h2><p>有三种基本序列类型：list, tuple 和 range 对象。 为处理 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#binaryseq">二进制数据</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#textseq">文本字符串</a> 而特别定制的附加序列类型会在专门的小节中描述。</p>
<h3 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h3><p>大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a> ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。</p>
<p>此表按优先级升序列出了序列操作。 在表格中，<em>s</em> 和 <em>t</em> 是具有相同类型的序列，<em>n</em>, <em>i</em>, <em>j</em> 和 <em>k</em> 是整数而 <em>x</em> 是任何满足 <em>s</em> 所规定的类型和值限制的任意对象。</p>
<p><code>in</code> 和 <code>not in</code> 操作具有与比较操作相同的优先级。 <code>+</code> (拼接) 和 <code>*</code> (重复) 操作具有与对应数值运算相同的优先级。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id14">3</a></p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>x in s</code></td>
<td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td>
<td>(1)</td>
</tr>
<tr>
<td><code>x not in s</code></td>
<td>如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td>
<td>(1)</td>
</tr>
<tr>
<td><code>s + t</code></td>
<td><em>s</em> 与 <em>t</em> 相拼接</td>
<td>(6)(7)</td>
</tr>
<tr>
<td><code>s * n</code> 或 <code>n * s</code></td>
<td>相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td>
<td>(2)(7)</td>
</tr>
<tr>
<td><code>s[i]</code></td>
<td><em>s</em> 的第 <em>i</em> 项，起始为 0</td>
<td>(3)</td>
</tr>
<tr>
<td><code>s[i:j]</code></td>
<td><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td>
<td>(3)(4)</td>
</tr>
<tr>
<td><code>s[i:j:k]</code></td>
<td><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td>
<td>(3)(5)</td>
</tr>
<tr>
<td><code>len(s)</code></td>
<td><em>s</em> 的长度</td>
<td></td>
</tr>
<tr>
<td><code>min(s)</code></td>
<td><em>s</em> 的最小项</td>
<td></td>
</tr>
<tr>
<td><code>max(s)</code></td>
<td><em>s</em> 的最大项</td>
<td></td>
</tr>
<tr>
<td><code>s.index(x[, i[, j]])</code></td>
<td><em>x</em> 在 <em>s</em> 中首次出现项的索引号（索引号在 <em>i</em> 或其后且在 <em>j</em> 之前）</td>
<td>(8)</td>
</tr>
<tr>
<td><code>s.count(x)</code></td>
<td><em>x</em> 在 <em>s</em> 中出现的总次数</td>
<td></td>
</tr>
</tbody></table>
<p>相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 （完整细节请参阅语言参考的 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#comparisons">比较运算</a> 部分。）</p>
<p>可变序列的正向和逆向迭代器使用一个索引来访问值。 即使底层序列被改变该索引也将持续向前（或向后）步进。 迭代器只有在遇到 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#IndexError" title="IndexError"><code>IndexError</code></a> 或 a <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#StopIteration" title="StopIteration"><code>StopIteration</code></a> 时才会终结（或是当索引降至零以下）。</p>
<p>注释：</p>
<ol>
<li><p>虽然 <code>in</code> 和 <code>not in</code> 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>) 也使用它们进行子序列检测:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“gg” in “eggs”<br> True
 </p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>小于 <code>0</code> 的 <em>n</em> 值会被当作 <code>0</code> 来处理 (生成一个与 <em>s</em> 同类型的空序列)。 请注意序列 <em>s</em> 中的项并不会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>lists &#x3D; [[]] * 3<br>lists<br> [[], [], []]<br>lists[0].append(3)<br>lists<br> [[3], [3], [3]]</p>
</blockquote>
</blockquote>
</blockquote>
<p> 具体的原因在于 <code>[[]]</code> 是一个包含了一个空列表的单元素列表，所以 <code>[[]] * 3</code> 结果中的三个元素都是对这一个空列表的引用。 修改 <code>lists</code> 中的任何一个元素实际上都是对这一个空列表的修改。 你可以用以下方式创建以不同列表为元素的列表:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>lists &#x3D; [[] for i in range(3)]<br>lists[0].append(3)<br>lists[1].append(5)<br>lists[2].append(7)<br>lists<br> [[3], [5], [7]]</p>
</blockquote>
</blockquote>
</blockquote>
<p> 进一步的解释可以在 FAQ 条目 <a href="https://docs.python.org/zh-cn/3.10/faq/programming.html#faq-multidimensional-list">如何创建多维列表？</a> 中查看。</p>
</li>
<li><p>如果 <em>i</em> 或 <em>j</em> 为负值，则索引顺序是相对于序列 <em>s</em> 的末尾: 索引号会被替换为 <code>len(s) + i</code> 或 <code>len(s) + j</code>。 但要注意 <code>-0</code> 仍然为 <code>0</code>。</p>
</li>
<li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片被定义为所有满足 <code>i &lt;= k &lt; j</code> 的索引号 <em>k</em> 的项组成的序列。 如果 <em>i</em> 或 <em>j</em> 大于 <code>len(s)</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 被省略或为 <code>None</code>，则使用 <code>0</code>。 如果 <em>j</em> 被省略或为 <code>None</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 大于等于 _j_，则切片为空。</p>
</li>
<li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片被定义为所有满足 <code>0 &lt;= n &lt; (j-i)/k</code> 的索引号 <code>x = i + n*k</code> 的项组成的序列。 换句话说，索引号为 <code>i</code>, <code>i+k</code>, <code>i+2*k</code>, <code>i+3*k</code>，以此类推，当达到 <em>j</em> 时停止 (但一定不包括 <em>j</em>)。 当 <em>k</em> 为正值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s)</code>。 当 <em>k</em> 为负值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s) - 1</code>。 如果 <em>i</em> 或 <em>j</em> 被省略或为 <code>None</code>，它们会成为“终止”值 (是哪一端的终止值则取决于 <em>k</em> 的符号)。 请注意，<em>k</em> 不可为零。 如果 <em>k</em> 为 <code>None</code>，则当作 <code>1</code> 处理。</p>
</li>
<li><p>拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一：</p>
<ul>
<li><p>如果拼接 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 对象，你可以构建一个列表并在最后使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.join" title="str.join"><code>str.join()</code></a> 或是写入一个 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.StringIO" title="io.StringIO"><code>io.StringIO</code></a> 实例并在结束时获取它的值</p>
</li>
<li><p>如果拼接 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，你可以类似地使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.join" title="bytes.join"><code>bytes.join()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a>，或者你也可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 对象进行原地拼接。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 对象是可变的，并且具有高效的重分配机制</p>
</li>
<li><p>如果拼接 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 对象，请改为扩展 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 类</p>
</li>
<li><p>对于其它类型，请查看相应的文档</p>
</li>
</ul>
</li>
<li><p>某些序列类型 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="range"><code>range</code></a>) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。</p>
</li>
<li><p>当 <em>x</em> 在 <em>s</em> 中找不到时 <code>index</code> 会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。 不是所有实现都支持传入额外参数 <em>i</em> 和 _j_。 这两个参数允许高效地搜索序列的子序列。 传入这两个额外参数大致相当于使用 <code>s[i:j].index(x)</code>，但是不会复制任何数据，并且返回的索引是相对于序列的开头而非切片的开头。</p>
</li>
</ol>
<h3 id="不可变序列类型"><a href="#不可变序列类型" class="headerlink" title="不可变序列类型"></a>不可变序列类型</h3><p>不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hash" title="hash"><code>hash()</code></a> 内置函数的支持。</p>
<p>这种支持允许不可变类型，例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 实例被用作 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 键，以及存储在 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 实例中。</p>
<p>尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。</p>
<h3 id="可变序列类型"><a href="#可变序列类型" class="headerlink" title="可变序列类型"></a>可变序列类型</h3><p>以下表格中的操作是在可变序列类型上定义的。 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code>collections.abc.MutableSequence</code></a> ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。</p>
<p>表格中的 <em>s</em> 是可变序列类型的实例，<em>t</em> 是任意可迭代对象，而 <em>x</em> 是符合对 <em>s</em> 所规定类型与值限制的任何对象 (例如，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 仅接受满足 <code>0 &lt;= x &lt;= 255</code> 值限制的整数)。</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果：</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>s[i] = x</code></td>
<td>将 <em>s</em> 的第 <em>i</em> 项替换为 <em>x</em></td>
<td></td>
</tr>
<tr>
<td><code>s[i:j] = t</code></td>
<td>将 <em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片替换为可迭代对象 <em>t</em> 的内容</td>
<td></td>
</tr>
<tr>
<td><code>del s[i:j]</code></td>
<td>等同于 <code>s[i:j] = []</code></td>
<td></td>
</tr>
<tr>
<td><code>s[i:j:k] = t</code></td>
<td>将 <code>s[i:j:k]</code> 的元素替换为 <em>t</em> 的元素</td>
<td>(1)</td>
</tr>
<tr>
<td><code>del s[i:j:k]</code></td>
<td>从列表中移除 <code>s[i:j:k]</code> 的元素</td>
<td></td>
</tr>
<tr>
<td><code>s.append(x)</code></td>
<td>将 <em>x</em> 添加到序列的末尾 (等同于 <code>s[len(s):len(s)] = [x]</code>)</td>
<td></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>从 <em>s</em> 中移除所有项 (等同于 <code>del s[:]</code>)</td>
<td>(5)</td>
</tr>
<tr>
<td><code>s.copy()</code></td>
<td>创建 <em>s</em> 的浅拷贝 (等同于 <code>s[:]</code>)</td>
<td>(5)</td>
</tr>
<tr>
<td><code>s.extend(t)</code> 或 <code>s += t</code></td>
<td>用 <em>t</em> 的内容扩展 <em>s</em> (基本上等同于 <code>s[len(s):len(s)] = t</code>)</td>
<td></td>
</tr>
<tr>
<td><code>s *= n</code></td>
<td>使用 <em>s</em> 的内容重复 <em>n</em> 次来对其进行更新</td>
<td>(6)</td>
</tr>
<tr>
<td><code>s.insert(i, x)</code></td>
<td>在由 <em>i</em> 给出的索引位置将 <em>x</em> 插入 <em>s</em> (等同于 <code>s[i:i] = [x]</code>)</td>
<td></td>
</tr>
<tr>
<td><code>s.pop()</code> 或 <code>s.pop(i)</code></td>
<td>提取在 <em>i</em> 位置上的项，并将其从 <em>s</em> 中移除</td>
<td>(2)</td>
</tr>
<tr>
<td><code>s.remove(x)</code></td>
<td>删除 <em>s</em> 中第一个 <code>s[i]</code> 等于 <em>x</em> 的项目。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>s.reverse()</code></td>
<td>就地将列表中的元素逆序。</td>
<td>(4)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p><em>t</em> 必须与它所替换的切片具有相同的长度。</p>
</li>
<li><p>可选参数 <em>i</em> 默认为 <code>-1</code>，因此在默认情况下会移除并返回最后一项。</p>
</li>
<li><p>当在 <em>s</em> 中找不到 <em>x</em> 时 <code>remove()</code> 操作会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
</li>
<li><p>当反转大尺寸序列时 <code>reverse()</code> 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。</p>
</li>
<li><p>包括 <code>clear()</code> 和 <code>copy()</code> 是为了与不支持切片操作的可变容器 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a>) 的接口保持一致。 <code>copy()</code> 不是 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code>collections.abc.MutableSequence</code></a> ABC 的一部分，但大多数具体的可变序列类都提供了它。</p>
<p> 3.3 新版功能: <code>clear()</code> 和 <code>copy()</code> 方法。</p>
</li>
<li><p><em>n</em> 值为一个整数，或是一个实现了 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> 的对象。 <em>n</em> 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用，正如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-common">通用序列操作</a> 中有关 <code>s * n</code> 的说明。</p>
</li>
</ol>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。</p>
<p><em>class</em> <code>list</code>([<em>iterable</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="永久链接至目标"></a></p>
<p>可以用多种方式构建列表：</p>
<ul>
<li><p>使用一对方括号来表示空列表: <code>[]</code></p>
</li>
<li><p>使用方括号，其中的项以逗号分隔: <code>[a]</code>, <code>[a, b, c]</code></p>
</li>
<li><p>使用列表推导式: <code>[x for x in iterable]</code></p>
</li>
<li><p>使用类型的构造器: <code>list()</code> 或 <code>list(iterable)</code></p>
</li>
</ul>
<p>构造器将构造一个列表，其中的项与 <em>iterable</em> 中的项具有相同的的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其它可迭代对象。 如果 <em>iterable</em> 已经是一个列表，将创建并返回其副本，类似于 <code>iterable[:]</code>。 例如，<code>list(&#39;abc&#39;)</code> 返回 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> 而 <code>list( (1, 2, 3) )</code> 返回 <code>[1, 2, 3]</code>。 如果没有给出参数，构造器将创建一个空列表 <code>[]</code>。</p>
<p>其它许多操作也会产生列表，包括 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted" title="sorted"><code>sorted()</code></a> 内置函数。</p>
<p>列表实现了所有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-common">一般</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-mutable">可变</a> 序列的操作。 列表还额外提供了以下方法：</p>
<p><code>sort</code>(<em>*</em>, <em>key&#x3D;None</em>, <em>reverse&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="永久链接至目标"></a></p>
<p>此方法会对列表进行原地排序，只使用 <code>&lt;</code> 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="list.sort"><code>sort()</code></a> 接受两个仅限以关键字形式传入的参数 (<a href="https://docs.python.org/zh-cn/3.10/glossary.html#keyword-only-parameter">仅限关键字参数</a>):</p>
<p><em>key</em> 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 <code>key=str.lower</code>)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 <code>None</code> 表示直接对列表项排序而不计算一个单独的键值。</p>
<p>可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code>functools.cmp_to_key()</code></a> 将 2.x 风格的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#sorted" title="sorted"><code>sorted()</code></a> 显示地请求一个新的已排序列表实例）。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="list.sort"><code>sort()</code></a> 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再接薪级排序）。</p>
<p>有关排序示例和简要排序教程，请参阅 <a href="https://docs.python.org/zh-cn/3.10/howto/sorting.html#sortinghowto">排序指南</a> 。</p>
<p><strong>CPython 实现细节：</strong> 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是不可变序列，通常用于储存异构数据的多项集（例如由 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#enumerate" title="enumerate"><code>enumerate()</code></a> 内置函数所产生的二元组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 的实例）。</p>
<p><em>class</em> <code>tuple</code>([<em>iterable</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="永久链接至目标"></a></p>
<p>可以用多种方式构建元组：</p>
<ul>
<li><p>使用一对圆括号来表示空元组: <code>()</code></p>
</li>
<li><p>使用一个后缀的逗号来表示单元组: <code>a,</code> 或 <code>(a,)</code></p>
</li>
<li><p>使用以逗号分隔的多个项: <code>a, b, c</code> or <code>(a, b, c)</code></p>
</li>
<li><p>使用内置的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple()</code></a>: <code>tuple()</code> 或 <code>tuple(iterable)</code></p>
</li>
</ul>
<p>构造器将构造一个元组，其中的项与 <em>iterable</em> 中的项具有相同的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其他可迭代对象。 如果 <em>iterable</em> 已经是一个元组，会不加改变地将其返回。 例如，<code>tuple(&#39;abc&#39;)</code> 返回 <code>(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code> 而 <code>tuple( [1, 2, 3] )</code> 返回 <code>(1, 2, 3)</code>。 如果没有给出参数，构造器将创建一个空元组 <code>()</code>。</p>
<p>请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，<code>f(a, b, c)</code> 是在调用函数时附带三个参数，而 <code>f((a, b, c))</code> 则是在调用函数时附带一个三元组。</p>
<p>元组实现了所有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-common">一般</a> 序列的操作。</p>
<p>对于通过名称访问相比通过索引访问更清晰的异构数据多项集，<a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.namedtuple" title="collections.namedtuple"><code>collections.namedtuple()</code></a> 可能是比简单元组对象更为合适的选择。</p>
<h3 id="range-对象"><a href="#range-对象" class="headerlink" title="range 对象"></a>range 对象</h3><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="range"><code>range</code></a> 类型表示不可变的数字序列，通常用于在 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#for"><code>for</code></a> 循环中循环指定的次数。</p>
<p><em>class</em> <code>range</code>(<em>stop</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="永久链接至目标"></a></p>
<p><em>class</em> <code>range</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>range 构造器的参数必须为整数（可以是内置的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 或任何实现了 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__index__" title="object.__index__"><code>__index__()</code></a> 特殊方法的对象）。 如果省略 <em>step</em> 参数，则默认为 <code>1</code>。 如果省略 <em>start</em> 参数，则默认为 <code>0</code>。 如果 <em>step</em> 为零，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p>如果 <em>step</em> 为正值，确定 range <code>r</code> 内容的公式为 <code>r[i] = start + step*i</code> 其中 <code>i &gt;= 0</code> 且 <code>r[i] &lt; stop</code>。</p>
<p>如果 <em>step</em> 为负值，确定 range 内容的公式仍然为 <code>r[i] = start + step*i</code>，但限制条件改为 <code>i &gt;= 0</code> 且 <code>r[i] &gt; stop</code>.</p>
<p>如果 <code>r[0]</code> 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。</p>
<p>元素绝对值大于 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.maxsize" title="sys.maxsize"><code>sys.maxsize</code></a> 的 range 对象是被允许的，但某些特性 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#len" title="len"><code>len()</code></a>) 可能引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#OverflowError" title="OverflowError"><code>OverflowError</code></a>。</p>
<p>一些 range 对象的例子:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>list(range(10))<br>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>list(range(1, 11))<br>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>list(range(0, 30, 5))<br>[0, 5, 10, 15, 20, 25]<br>list(range(0, 10, 3))<br>[0, 3, 6, 9]<br>list(range(0, -10, -1))<br>[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br>list(range(0))<br>[]<br>list(range(1, 0))<br>[]</p>
</blockquote>
</blockquote>
</blockquote>
<p>range 对象实现了 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-common">一般</a> 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。</p>
<p><code>start</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.start" title="永久链接至目标"></a></p>
<p><em>start</em> 形参的值 (如果该形参未提供则为 <code>0</code>)</p>
<p><code>stop</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.stop" title="永久链接至目标"></a></p>
<p><em>stop</em> 形参的值</p>
<p><code>step</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.step" title="永久链接至目标"></a></p>
<p><em>step</em> 形参的值 (如果该形参未提供则为 <code>1</code>)</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="range"><code>range</code></a> 类型相比常规 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 的优势在于一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range" title="range"><code>range</code></a> 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 <code>start</code>, <code>stop</code> 和 <code>step</code> 值，并会根据需要计算具体单项或子范围的值）。</p>
<p>range 对象实现了 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a> ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq">序列类型 — list, tuple, range</a>):</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>r &#x3D; range(0, 20, 2)<br>r<br>range(0, 20, 2)<br>11 in r<br>False<br>10 in r<br>True<br>r.index(10)<br>5<br>r[5]<br>10<br>r[:5]<br>range(0, 10, 2)<br>r[-1]<br>18</p>
</blockquote>
</blockquote>
</blockquote>
<p>使用 <code>==</code> 和 <code>!=</code> 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.start" title="range.start"><code>start</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.stop" title="range.stop"><code>stop</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.step" title="range.step"><code>step</code></a> 属性，例如 <code>range(0) == range(2, 1, 3)</code> 而 <code>range(0, 3, 2) == range(0, 4, 2)</code>。）</p>
<p>在 3.2 版更改: 实现 Sequence ABC。 支持切片和负数索引。 使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 对象在固定时间内进行成员检测，而不是逐一迭代所有项。</p>
<p>在 3.3 版更改: 定义 ‘&#x3D;&#x3D;’ 和 ‘!&#x3D;’ 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。</p>
<p>3.3 新版功能: <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.start" title="range.start"><code>start</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.stop" title="range.stop"><code>stop</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#range.step" title="range.step"><code>step</code></a> 属性。</p>
<p>参见</p>
<ul>
<li><a href="https://code.activestate.com/recipes/579000/">linspace recipe</a> 演示了如何实现一个延迟求值版本的适合浮点数应用的 range 对象。</li>
</ul>
<h2 id="文本序列类型-—str"><a href="#文本序列类型-—str" class="headerlink" title="文本序列类型 —str"></a>文本序列类型 —<code>str</code></h2><p>在 Python 中处理文本数据是使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 对象，也称为 _字符串_。 字符串是由 Unicode 码位构成的不可变 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq">序列</a>。 字符串字面值有多种不同的写法：</p>
<ul>
<li><p>单引号: <code>&#39;允许包含有 &quot;双&quot; 引号&#39;</code></p>
</li>
<li><p>双引号: <code>&quot;允许嵌入 &#39;单&#39; 引号&quot;</code></p>
</li>
<li><p>三重引号: <code>&#39;&#39;&#39;三重单引号&#39;&#39;&#39;</code>, <code>&quot;&quot;&quot;三重双引号&quot;&quot;&quot;</code></p>
</li>
</ul>
<p>使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。</p>
<p>作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，<code>(&quot;spam &quot; &quot;eggs&quot;) == &quot;spam eggs&quot;</code>。</p>
<p>请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#strings">字符串与字节串字面值</a> 了解有关不同字符串字面值的更多信息，包括所支持的转义序列，以及使用 <code>r</code> (“raw”) 前缀来禁用大多数转义序列的处理。</p>
<p>字符串也可以通过使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 构造器从其他对象创建。</p>
<p>由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 <em>s</em>, <code>s[0] == s[0:1]</code>。</p>
<p>不存在可变的字符串类型，但是 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.join" title="str.join"><code>str.join()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/io.html#io.StringIO" title="io.StringIO"><code>io.StringIO</code></a> 可以被被用来根据多个片段高效率地构建字符串。</p>
<p>在 3.3 版更改: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 <code>u</code> 前缀。 它对字符串字面值的含义没有影响，并且不能与 <code>r</code> 前缀同时出现。</p>
<p><em>class</em> <code>str</code>(<em>object&#x3D;’’</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="永久链接至目标"></a></p>
<p><em>class</em> <code>str</code>(<em>object&#x3D;b’’</em>, <em>encoding&#x3D;’utf-8’</em>, <em>errors&#x3D;’strict’</em>)</p>
<p>返回 <em>object</em> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#textseq">字符串</a> 版本。 如果未提供 <em>object</em> 则返回空字符串。 在其他情况下 <code>str()</code> 的行为取决于 <em>encoding</em> 或 <em>errors</em> 是否有给出，具体见下。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 均未给出，则 <code>str(object)</code> 返回 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__str__" title="object.__str__"><code>type(object).__str__(object)</code></a>，这是 <em>object</em> 的 “非正式” 或格式良好的字符串表示形式。 对于字符串对象，这是该字符串本身。 如果 <em>object</em> 没有 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a> 方法，则 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 将回退为返回 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr(object)</code></a>。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 至少给出其中之一，则 <em>object</em> 应该是一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> (例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>)。 在此情况下，如果 <em>object</em> 是一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> (或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>) 对象，则 <code>str(bytes, encoding, errors)</code> 等价于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.decode" title="bytes.decode"><code>bytes.decode(encoding, errors)</code></a>。 否则的话，会在调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.decode" title="bytes.decode"><code>bytes.decode()</code></a> 之前获取缓冲区对象下层的 bytes 对象。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#binaryseq">二进制序列类型 — bytes, bytearray, memoryview</a> 与 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲协议</a> 了解有关缓冲区对象的信息。</p>
<p>将一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象传入 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 而不给出 <em>encoding</em> 或 <em>errors</em> 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-b"><code>-b</code></a> 命令行选项）。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>str(b’Zoot!’)<br>“b’Zoot!’”</p>
</blockquote>
</blockquote>
</blockquote>
<p>有关 <code>str</code> 类及其方法的更多信息，请参阅下面的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#textseq">文本序列类型 — str</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#string-methods">字符串的方法</a> 小节。 要输出格式化字符串，请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#f-strings">格式字符串字面值</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatstrings">格式字符串语法</a> 小节。 此外还可以参阅 <a href="https://docs.python.org/zh-cn/3.10/library/text.html#stringservices">文本处理服务</a> 小节。</p>
<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><p>字符串实现了所有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-common">一般</a> 序列的操作，还额外提供了以下列出的一些附加方法。</p>
<p>字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatstrings">格式字符串语法</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#string-formatting">自定义字符串格式化</a>) 而另一种是基于 C <code>printf</code> 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 (<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#old-string-formatting">printf 风格的字符串格式化</a>)。</p>
<p>标准库的 <a href="https://docs.python.org/zh-cn/3.10/library/text.html#textservices">文本处理服务</a> 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#module-re" title="re: Regular expression operations."><code>re</code></a> 模块中的正则表达式支持）。</p>
<p><code>str.``capitalize</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.capitalize" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，其首个字符大写，其余为小写。</p>
<p>在 3.8 版更改: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。</p>
<p><code>str.``casefold</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.casefold" title="永久链接至目标"></a></p>
<p>返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。</p>
<p>消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 <code>&#39;ß&#39;</code> 相当于 <code>&quot;ss&quot;</code>。 由于它已经是小写了，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.lower" title="str.lower"><code>lower()</code></a> 不会对 <code>&#39;ß&#39;</code> 做任何改变；而 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.casefold" title="str.casefold"><code>casefold()</code></a> 则会将其转换为 <code>&quot;ss&quot;</code>。</p>
<p>消除大小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p>3.3 新版功能.</p>
<p><code>str.``center</code>(<em>width</em>[, <em>fillchar</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.center" title="永久链接至目标"></a></p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其正中。 使用指定的 <em>fillchar</em> 填充两边的空位（默认使用 ASCII 空格符）。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.``count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.count" title="永久链接至目标"></a></p>
<p>返回子字符串 <em>sub</em> 在 [<em>start</em>, <em>end</em>] 范围内非重叠出现的次数。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p>如果 <em>sub</em> 为空，则返回字符之间的空字符串数，即字符串的长度加一。</p>
<p><code>str.``encode</code>(<em>encoding&#x3D;’utf-8’</em>, <em>errors&#x3D;’strict’</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.encode" title="永久链接至目标"></a></p>
<p>返回编码为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 的字符串。</p>
<p><em>encoding</em> 默认为 <code>&#39;utf-8&#39;</code> ；请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#standard-encodings">标准编码</a> 了解其他可能的值。</p>
<p><em>errors</em> 控制如何处理编码错误。 如为 <code>&#39;strict&#39;</code> (默认值)，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a>。 其他可能的值有 <code>&#39;ignore&#39;</code>, <code>&#39;replace&#39;</code>, <code>&#39;xmlcharrefreplace&#39;</code>, <code>&#39;backslashreplace&#39;</code> 以及通过 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#codecs.register_error" title="codecs.register_error"><code>codecs.register_error()</code></a> 注册的任何其他名称。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#error-handlers">错误处理方案</a> 了解详情。</p>
<p>出于性能原因，除非真正发生了编码错误，启用了 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 或使用了 <a href="https://docs.python.org/zh-cn/3.10/using/configure.html#debug-build">调试编译版</a> 否则不会检查 <em>errors</em> 值的有效性。</p>
<p>在 3.1 版更改: 加入了对关键字参数的支持。</p>
<p>在 3.9 版更改: 现在会在 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 和 <a href="https://docs.python.org/zh-cn/3.10/using/configure.html#debug-build">调试模式</a> 下检查 <em>errors</em> 参数的值。</p>
<p><code>str.``endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.endswith" title="永久链接至目标"></a></p>
<p>如果字符串以指定的 <em>suffix</em> 结束返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 _start_，将从所指定位置开始检查。 如果有可选项 _end_，将在所指定位置停止比较。</p>
<p><code>str.``expandtabs</code>(<em>tabsize&#x3D;8</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.expandtabs" title="永久链接至目标"></a></p>
<p>返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (<code>\t</code>)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (<code>\n</code>) 或回车符 (<code>\r</code>)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘01\t012\t0123\t01234’.expandtabs()<br>‘01      012     0123    01234’<br>‘01\t012\t0123\t01234’.expandtabs(4)<br>‘01  012 0123    01234’</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.find" title="永久链接至目标"></a></p>
<p>返回子字符串 <em>sub</em> 在 <code>s[start:end]</code> 切片内被找到的最小索引。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。</p>
<p>注解</p>
<p> </p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.find" title="str.find"><code>find()</code></a> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子字符串，请使用 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#in"><code>in</code></a> 操作符:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘Py’ in ‘Python’<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``format</code>(<em>*args</em>, <em>**kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="永久链接至目标"></a></p>
<p>执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 <code>&#123;&#125;</code> 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“The sum of 1 + 2 is {0}”.format(1+2)<br>‘The sum of 1 + 2 is 3’</p>
</blockquote>
</blockquote>
</blockquote>
<p>请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatstrings">格式字符串语法</a> 了解有关可以在格式字符串中指定的各种格式选项的说明。</p>
<p>注解</p>
<p> </p>
<p>当使用 <code>n</code> 类型 (例如: <code>&#39;&#123;:n&#125;&#39;.format(1234)</code>) 来格式化数字 (<a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#complex" title="complex"><code>complex</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>decimal.Decimal</code></a> 及其子类) 的时候，该函数会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域以解码 <code>localeconv()</code> 的 <code>decimal_point</code> 和 <code>thousands_sep</code> 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 <code>LC_NUMERIC</code> 区域会与 <code>LC_CTYPE</code> 区域不一致。 这个临时更改会影响其他线程。</p>
<p>在 3.7 版更改: 当使用 <code>n</code> 类型格式化数字时，该函数在某些情况下会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域。</p>
<p><code>str.``format_map</code>(<em>mapping</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format_map" title="永久链接至目标"></a></p>
<p>类似于 <code>str.format(**mapping)</code>，不同之处在于 <code>mapping</code> 会被直接使用而不是复制到一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a>。 适宜使用此方法的一个例子是当 <code>mapping</code> 为 dict 的子类的情况：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class Default(dict):<br>…     def <strong>missing</strong>(self, key):<br>…         return key<br>…<br>‘{name} was born in {country}’.format_map(Default(name&#x3D;’Guido’))<br>‘Guido was born in country’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.2 新版功能.</p>
<p><code>str.``index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.index" title="永久链接至目标"></a></p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.find" title="str.find"><code>find()</code></a>，但在找不到子字符串时会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p><code>str.``isalnum</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isalnum" title="永久链接至目标"></a></p>
<p>如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 <code>True</code> ， 否则返回 <code>False</code> 。 如果 <code>c.isalpha()</code> ， <code>c.isdecimal()</code> ， <code>c.isdigit()</code> ，或 <code>c.isnumeric()</code> 之中有一个返回 <code>True</code> ，则字符 <code>c</code> 是字母或数字。</p>
<p><code>str.``isalpha</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isalpha" title="永久链接至目标"></a></p>
<p>如果字符串中的所有字符都是字母，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code> 。字母字符是指那些在 Unicode 字符数据库中定义为 “Letter” 的字符，即那些具有 “Lm”、”Lt”、”Lu”、”Ll” 或 “Lo” 之一的通用类别属性的字符。 注意，这与 Unicode 标准中定义的”字母”属性不同。</p>
<p><code>str.``isascii</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isascii" title="永久链接至目标"></a></p>
<p>如果字符串为空或字符串中的所有字符都是 ASCII ，返回 <code>True</code> ，否则返回 <code>False</code> 。ASCII 字符的码点范围是 U+0000-U+007F 。</p>
<p>3.7 新版功能.</p>
<p><code>str.``isdecimal</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isdecimal" title="永久链接至目标"></a></p>
<p>如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 <code>True</code> ， 否则返回 <code>False</code> 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 “Nd” 中的一个字符。</p>
<p><code>str.``isdigit</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isdigit" title="永久链接至目标"></a></p>
<p>如果字符串中的所有字符都是数字，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code> 。 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type&#x3D;Digit 或 Numeric_Type&#x3D;Decimal 的字符。</p>
<p><code>str.``isidentifier</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isidentifier" title="永久链接至目标"></a></p>
<p>如果字符串是有效的标识符，返回 <code>True</code> ，依据语言定义， <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#identifiers">标识符和关键字</a> 节。</p>
<p>调用 <a href="https://docs.python.org/zh-cn/3.10/library/keyword.html#keyword.iskeyword" title="keyword.iskeyword"><code>keyword.iskeyword()</code></a> 来检测字符串 <code>s</code> 是否为保留标识符，例如 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#def"><code>def</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#class"><code>class</code></a>。</p>
<p>示例：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from keyword import iskeyword</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘hello’.isidentifier(), iskeyword(‘hello’)<br>(True, False)<br>‘def’.isidentifier(), iskeyword(‘def’)<br>(True, True)</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``islower</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.islower" title="永久链接至目标"></a></p>
<p>如果字符串中至少有一个区分大小写的字符 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id15">4</a> 且此类字符均为小写则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><code>str.``isnumeric</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isnumeric" title="永久链接至目标"></a></p>
<p>如果字符串中至少有一个字符且所有字符均为数值字符则返回 <code>True</code> ，否则返回 <code>False</code> 。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type&#x3D;Digit, Numeric_Type&#x3D;Decimal 或 Numeric_Type&#x3D;Numeric 的字符。</p>
<p><code>str.``isprintable</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isprintable" title="永久链接至目标"></a></p>
<p>如果字符串中所有字符均为可打印字符或字符串为空则返回 <code>True</code> ，否则返回 <code>False</code> 。 不可打印字符是在 Unicode 字符数据库中被定义为 “Other” 或 “Separator” 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 时不必被转义的字符。 它们与字符串写入 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.stdout" title="sys.stdout"><code>sys.stdout</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.stderr" title="sys.stderr"><code>sys.stderr</code></a> 时所需的处理无关。）</p>
<p><code>str.``isspace</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isspace" title="永久链接至目标"></a></p>
<p>如果字符串中只有空白字符且至少有一个字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><em>空白</em> 字符是指在 Unicode 字符数据库 (参见 <a href="https://docs.python.org/zh-cn/3.10/library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code>unicodedata</code></a>) 中主要类别为 <code>Zs</code> (“Separator, space”) 或所属双向类为 <code>WS</code>, <code>B</code> 或 <code>S</code> 的字符。</p>
<p><code>str.``istitle</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.istitle" title="永久链接至目标"></a></p>
<p>如果字符串中至少有一个字符且为标题字符串则返回 <code>True</code> ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 <code>False</code> 。</p>
<p><code>str.``isupper</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.isupper" title="永久链接至目标"></a></p>
<p>如果字符串中至少有一个区分大小写的字符 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id15">4</a> 且此类字符均为大写则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘BANANA’.isupper()<br>True<br>‘banana’.isupper()<br>False<br>‘baNana’.isupper()<br>False<br>‘ ‘.isupper()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``join</code>(<em>iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.join" title="永久链接至目标"></a></p>
<p>返回一个由 <em>iterable</em> 中的字符串拼接而成的字符串。 如果 <em>iterable</em> 中存在任何非字符串值包括 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。 调用该方法的字符串将作为元素之间的分隔。</p>
<p><code>str.``ljust</code>(<em>width</em>[, <em>fillchar</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.ljust" title="永久链接至目标"></a></p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠左对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.``lower</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.lower" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，其所有区分大小写的字符 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id15">4</a> 均转换为小写。</p>
<p>所用转换小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p><code>str.``lstrip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.lstrip" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，移除其中的前导字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘   spacious   ‘.lstrip()<br>‘spacious   ‘<br>‘<a href="http://www.example.com'.lstrip('cmowz.')/">www.example.com&#39;.lstrip(&#39;cmowz.&#39;)</a><br>‘example.com’</p>
</blockquote>
</blockquote>
</blockquote>
<p>参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.removeprefix" title="str.removeprefix"><code>str.removeprefix()</code></a> ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘Arthur: three!’.lstrip(‘Arthur: ‘)<br>‘ee!’<br>‘Arthur: three!’.removeprefix(‘Arthur: ‘)<br>‘three!’</p>
</blockquote>
</blockquote>
</blockquote>
<p><em>static</em> <code>str.``maketrans</code>(<em>x</em>[, <em>y</em>[, <em>z</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.maketrans" title="永久链接至目标"></a></p>
<p>此静态方法返回一个可供 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.translate" title="str.translate"><code>str.translate()</code></a> 使用的转换对照表。</p>
<p>如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 <code>None</code> 的字典。 字符键将会被转换为码位序号。</p>
<p>如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 <code>None</code>。</p>
<p><code>str.``partition</code>(<em>sep</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.partition" title="永久链接至目标"></a></p>
<p>在 <em>sep</em> 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。</p>
<p><code>str.``removeprefix</code>(<em>prefix</em>, <em>&#x2F;</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.removeprefix" title="永久链接至目标"></a></p>
<p>如果字符串以 <em>prefix</em> 字符串开头，返回 <code>string[len(prefix):]</code>。 否则，返回原始字符串的副本：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘TestHook’.removeprefix(‘Test’)<br>‘Hook’<br>‘BaseTestCase’.removeprefix(‘Test’)<br>‘BaseTestCase’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.9 新版功能.</p>
<p><code>str.``removesuffix</code>(<em>suffix</em>, <em>&#x2F;</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.removesuffix" title="永久链接至目标"></a></p>
<p>如果字符串以 <em>suffix</em> 字符串结尾，并且 <em>suffix</em> 非空，返回 <code>string[:-len(suffix)]</code>。 否则，返回原始字符串的副本:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘MiscTests’.removesuffix(‘Tests’)<br>‘Misc’<br>‘TmpDirMixin’.removesuffix(‘Tests’)<br>‘TmpDirMixin’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.9 新版功能.</p>
<p><code>str.``replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.replace" title="永久链接至目标"></a></p>
<p>返回字符串的副本，其中出现的所有子字符串 <em>old</em> 都将被替换为 _new_。 如果给出了可选参数 _count_，则只替换前 <em>count</em> 次出现。</p>
<p><code>str.``rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rfind" title="永久链接至目标"></a></p>
<p>返回子字符串 <em>sub</em> 在字符串内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code>s[start:end]</code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p><code>str.``rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rindex" title="永久链接至目标"></a></p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rfind" title="str.rfind"><code>rfind()</code></a>，但在子字符串 <em>sub</em> 未找到时会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p><code>str.``rjust</code>(<em>width</em>[, <em>fillchar</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rjust" title="永久链接至目标"></a></p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠右对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.``rpartition</code>(<em>sep</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rpartition" title="永久链接至目标"></a></p>
<p>在 <em>sep</em> 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。</p>
<p><code>str.``rsplit</code>(<em>sep&#x3D;None</em>, <em>maxsplit&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rsplit" title="永久链接至目标"></a></p>
<p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 _maxsplit_，则最多进行 <em>maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rsplit" title="str.rsplit"><code>rsplit()</code></a> 的其他行为都类似于下文所述的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.split" title="str.split"><code>split()</code></a>。</p>
<p><code>str.``rstrip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.rstrip" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，移除其中的末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘   spacious   ‘.rstrip()<br>‘   spacious’<br>‘mississippi’.rstrip(‘ipz’)<br>‘mississ’</p>
</blockquote>
</blockquote>
</blockquote>
<p>要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.removesuffix" title="str.removesuffix"><code>str.removesuffix()</code></a> 方法。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘Monty Python’.rstrip(‘ Python’)<br>‘M’<br>‘Monty Python’.removesuffix(‘ Python’)<br>‘Monty’</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``split</code>(<em>sep&#x3D;None</em>, <em>maxsplit&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.split" title="永久链接至目标"></a></p>
<p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 _maxsplit_，则最多进行 <em>maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 _sep_，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 <code>&#39;1,,2&#39;.split(&#39;,&#39;)</code> 将返回 <code>[&#39;1&#39;, &#39;&#39;, &#39;2&#39;]</code>)。 <em>sep</em> 参数可能由多个字符组成 (例如 <code>&#39;1&lt;&gt;2&lt;&gt;3&#39;.split(&#39;&lt;&gt;&#39;)</code> 将返回 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>)。 使用指定的分隔符拆分空字符串将返回 <code>[&#39;&#39;]</code>。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘1,2,3’.split(‘,’)<br>[‘1’, ‘2’, ‘3’]<br>‘1,2,3’.split(‘,’, maxsplit&#x3D;1)<br>[‘1’, ‘2,3’]<br>‘1,2,,3,’.split(‘,’)<br>[‘1’, ‘2’, ‘’, ‘3’, ‘’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果 <em>sep</em> 未指定或为 <code>None</code>，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 <code>None</code> 拆分空字符串或仅包含空格的字符串将返回 <code>[]</code>。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘1 2 3’.split()<br>[‘1’, ‘2’, ‘3’]<br>‘1 2 3’.split(maxsplit&#x3D;1)<br>[‘1’, ‘2 3’]<br>‘   1   2   3   ‘.split()<br>[‘1’, ‘2’, ‘3’]</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``splitlines</code>(<em>keepends&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.splitlines" title="永久链接至目标"></a></p>
<p>返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 <em>keepends</em> 且为真值。</p>
<p>此方法会以下列行边界进行拆分。 特别地，行边界是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-universal-newlines">universal newlines</a> 的一个超集。</p>
<table>
<thead>
<tr>
<th>表示符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
<tr>
<td><code>\r\n</code></td>
<td>回车 + 换行</td>
</tr>
<tr>
<td><code>\v</code> 或 <code>\x0b</code></td>
<td>行制表符</td>
</tr>
<tr>
<td><code>\f</code> 或 <code>\x0c</code></td>
<td>换表单</td>
</tr>
<tr>
<td><code>\x1c</code></td>
<td>文件分隔符</td>
</tr>
<tr>
<td><code>\x1d</code></td>
<td>组分隔符</td>
</tr>
<tr>
<td><code>\x1e</code></td>
<td>记录分隔符</td>
</tr>
<tr>
<td><code>\x85</code></td>
<td>下一行 (C1 控制码)</td>
</tr>
<tr>
<td><code>\u2028</code></td>
<td>行分隔符</td>
</tr>
<tr>
<td><code>\u2029</code></td>
<td>段分隔符</td>
</tr>
</tbody></table>
<p>在 3.2 版更改: <code>\v</code> 和 <code>\f</code> 被添加到行边界列表</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘ab c\n\nde fg\rkl\r\n’.splitlines()<br>[‘ab c’, ‘’, ‘de fg’, ‘kl’]<br>‘ab c\n\nde fg\rkl\r\n’.splitlines(keepends&#x3D;True)<br>[‘ab c\n’, ‘\n’, ‘de fg\r’, ‘kl\r\n’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>不同于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.split" title="str.split"><code>split()</code></a>，当给出了分隔字符串 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“”.splitlines()<br>[]<br>“One line\n”.splitlines()<br>[‘One line’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>作为比较，<code>split(&#39;\n&#39;)</code> 的结果为:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘’.split(‘\n’)<br>[‘’]<br>‘Two lines\n’.split(‘\n’)<br>[‘Two lines’, ‘’]</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.startswith" title="永久链接至目标"></a></p>
<p>如果字符串以指定的 <em>prefix</em> 开始则返回 <code>True</code>，否则返回 <code>False</code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 _start_，将从所指定位置开始检查。 如果有可选项 _end_，将在所指定位置停止比较。</p>
<p><code>str.``strip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.strip" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，移除其中的前导和末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘   spacious   ‘.strip()<br>‘spacious’<br>‘<a href="http://www.example.com'.strip('cmowz.')/">www.example.com&#39;.strip(&#39;cmowz.&#39;)</a><br>‘example’</p>
</blockquote>
</blockquote>
</blockquote>
<p>最外侧的前导和末尾 <em>chars</em> 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包含于 <em>chars</em> 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>comment_string &#x3D; ‘#……. Section 3.2.1 Issue #32 …….’<br>comment_string.strip(‘.#! ‘)<br>‘Section 3.2.1 Issue #32’</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``swapcase</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.swapcase" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 <code>s.swapcase().swapcase() == s</code> 并不一定为真值。</p>
<p><code>str.``title</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.title" title="永久链接至目标"></a></p>
<p>返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>‘Hello world’.title()<br>‘Hello World’</p>
</blockquote>
</blockquote>
</blockquote>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“they’re bill’s friends from the UK”.title()<br>“They’Re Bill’S Friends From The Uk”</p>
</blockquote>
</blockquote>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.10/library/string.html#string.capwords" title="string.capwords"><code>string.capwords()</code></a> 函数没有此问题，因为它只用空格来拆分单词。</p>
<p>作为替代，可以使用正则表达式来构造针对撇号的变通处理:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>def titlecase(s):<br>…     return re.sub(r”[A-Za-z]+(‘[A-Za-z]+)?”,<br>…                   lambda mo: mo.group(0).capitalize(),<br>…                   s)<br>…<br>titlecase(“they’re bill’s friends.”)<br>“They’re Bill’s Friends.”</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>str.``translate</code>(<em>table</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.translate" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 <code>__getitem__()</code> 来实现索引操作的对象，通常为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-mapping">mapping</a> 或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-sequence">sequence</a>。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 <code>None</code>，将字符从结果字符串中删除；或引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#LookupError" title="LookupError"><code>LookupError</code></a> 异常，将字符映射为其自身。</p>
<p>你可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.maketrans" title="str.maketrans"><code>str.maketrans()</code></a> 基于不同格式的字符到字符映射来创建一个转换映射表。</p>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code>codecs</code></a> 模块以了解定制字符映射的更灵活方式。</p>
<p><code>str.``upper</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.upper" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，其中所有区分大小写的字符 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id15">4</a> 均转换为大写。 请注意如果 <code>s</code> 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 “Lu” (Letter, uppercase) 而是 “Lt” (Letter, titlecase) 则 <code>s.upper().isupper()</code> 有可能为 <code>False</code>。</p>
<p>所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p><code>str.``zfill</code>(<em>width</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.zfill" title="永久链接至目标"></a></p>
<p>返回原字符串的副本，在左边填充 ASCII <code>&#39;0&#39;</code> 数码使其长度变为 _width_。 正负值前缀 (<code>&#39;+&#39;</code>&#x2F;<code>&#39;-&#39;</code>) 的处理方式是在正负符号 <em>之后</em> 填充而非在之前。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“42”.zfill(5)<br>‘00042’<br>“-42”.zfill(5)<br>‘-0042’</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="风格的字符串格式化printf"><a href="#风格的字符串格式化printf" class="headerlink" title="风格的字符串格式化printf"></a>风格的字符串格式化<code>printf</code></h3><p>注解</p>
<p> </p>
<p>此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#f-strings">格式化字符串字面值</a>，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.format" title="str.format"><code>str.format()</code></a> 接口或 <a href="https://docs.python.org/zh-cn/3.10/library/string.html#template-strings">模板字符串</a> 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。</p>
<p>字符串具有一种特殊的内置操作：使用 <code>%</code> (取模) 运算符。 这也被称为字符串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code>format % values</code> (其中 <em>format</em> 为一个字符串)，在 <em>format</em> 中的 <code>%</code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于在 C 语言中使用 <code>sprintf()</code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id16">5</a> 否则的话，<em>values</em> 必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。</p>
<p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol>
<li><p><code>&#39;%&#39;</code> 字符，用于标记转换符的起始。</p>
</li>
<li><p>映射键（可选），由加圆括号的字符序列组成 (例如 <code>(somename)</code>)。</p>
</li>
<li><p>转换旗标（可选），用于影响某些转换类型的结果。</p>
</li>
<li><p>最小字段宽度（可选）。 如果指定为 <code>&#39;*&#39;</code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</p>
</li>
<li><p>精度（可选），以在 <code>&#39;.&#39;</code> (点号) 之后加精度值的形式给出。 如果指定为 <code>&#39;*&#39;</code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</p>
</li>
<li><p>长度修饰符（可选）。</p>
</li>
<li><p>转换类型。</p>
</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 <em>必须</em> 包含加圆括号的映射键，对应 <code>&#39;%&#39;</code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print(‘%(language)s has %(number)03d quote types.’ %<br>…       {‘language’: “Python”, “number”: 2})<br>Python has 002 quote types.</p>
</blockquote>
</blockquote>
</blockquote>
<p>在此情况下格式中不能出现 <code>*</code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;#&#39;</code></td>
<td>值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr>
<td><code>&#39;0&#39;</code></td>
<td>转换将为数字值填充零字符。</td>
</tr>
<tr>
<td><code>&#39;-&#39;</code></td>
<td>转换值将靠左对齐（如果同时给出 <code>&#39;0&#39;</code> 转换，则会覆盖后者）。</td>
</tr>
<tr>
<td><code>&#39; &#39;</code></td>
<td>(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>符号字符 (<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td>
</tr>
</tbody></table>
<p>可以给出长度修饰符 (<code>h</code>, <code>l</code> 或 <code>L</code>)，但会被忽略，因为对 Python 来说没有必要 – 所以 <code>%ld</code> 等价于 <code>%d</code>。</p>
<p>转换类型为：</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>含意</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;d&#39;</code></td>
<td>有符号十进制整数。</td>
<td></td>
</tr>
<tr>
<td><code>&#39;i&#39;</code></td>
<td>有符号十进制整数。</td>
<td></td>
</tr>
<tr>
<td><code>&#39;o&#39;</code></td>
<td>有符号八进制数。</td>
<td>(1)</td>
</tr>
<tr>
<td><code>&#39;u&#39;</code></td>
<td>过时类型 – 等价于 <code>&#39;d&#39;</code>。</td>
<td>(6)</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>有符号十六进制数（小写）。</td>
<td>(2)</td>
</tr>
<tr>
<td><code>&#39;X&#39;</code></td>
<td>有符号十六进制数（大写）。</td>
<td>(2)</td>
</tr>
<tr>
<td><code>&#39;e&#39;</code></td>
<td>浮点指数格式（小写）。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;E&#39;</code></td>
<td>浮点指数格式（大写）。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;f&#39;</code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;F&#39;</code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;g&#39;</code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr>
<td><code>&#39;G&#39;</code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr>
<td><code>&#39;c&#39;</code></td>
<td>单个字符（接受整数或单个字符的字符串）。</td>
<td></td>
</tr>
<tr>
<td><code>&#39;r&#39;</code></td>
<td>字符串（使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 转换任何 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr>
<td><code>&#39;s&#39;</code></td>
<td>字符串（使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 转换任何 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>字符串（使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#ascii" title="ascii"><code>ascii()</code></a> 转换任何 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr>
<td><code>&#39;%&#39;</code></td>
<td>不转换参数，在结果中输出一个 <code>&#39;%&#39;</code> 字符。</td>
<td></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code>&#39;0o&#39;</code>)。</p>
</li>
<li><p>此替代形式会在第一个数码之前插入 <code>&#39;0x&#39;</code> 或 <code>&#39;0X&#39;</code> 前缀（取决于是使用 <code>&#39;x&#39;</code> 还是 <code>&#39;X&#39;</code> 格式）。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p> 小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p> 小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p>如果精度为 <code>N</code>，输出将截短为 <code>N</code> 个字符。</p>
</li>
<li><p>参见 <a href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>由于 Python 字符串显式指明长度，<code>%s</code> 转换不会将 <code>&#39;\0&#39;</code> 视为字符串的结束。</p>
<p>在 3.1 版更改: 绝对值超过 1e50 的 <code>%f</code> 转换不会再被替换为 <code>%g</code> 转换。</p>
<h2 id="二进制序列类型-—bytes-bytearray-memoryview"><a href="#二进制序列类型-—bytes-bytearray-memoryview" class="headerlink" title="二进制序列类型 —bytes``bytearray``memoryview"></a>二进制序列类型 —<code>bytes``bytearray``memoryview</code></h2><p>操作二进制数据的核心内置类型是 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a>。 它们由 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 提供支持，该对象使用 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲区协议</a> 来访问其他二进制对象所在内存，不需要创建对象的副本。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code>array</code></a> 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。</p>
<h3 id="bytes-对象"><a href="#bytes-对象" class="headerlink" title="bytes 对象"></a>bytes 对象</h3><p>bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。</p>
<p><em>class</em> <code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="永久链接至目标"></a></p>
<p>首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 <code>b</code> 前缀：</p>
<ul>
<li><p>单引号: <code>b&#39;同样允许嵌入 &quot;双&quot; 引号&#39;</code>。</p>
</li>
<li><p>双引号: <code>b&quot;仍然允许嵌入 &#39;单&#39; 引号&quot;</code></p>
</li>
<li><p>三重引号: <code>b&#39;&#39;&#39;三重单引号&#39;&#39;&#39;</code>, <code>b&quot;&quot;&quot;三重双引号&quot;&quot;&quot;</code></p>
</li>
</ul>
<p>bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。</p>
<p>像字符串字面值一样，bytes 字面值也可以使用 <code>r</code> 前缀来禁用转义序列处理。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/lexical_analysis.html#strings">字符串与字节串字面值</a> 了解有关各种 bytes 字面值形式的详情，包括所支持的转义序列。</p>
<p>虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 <code>0 &lt;= x &lt; 256</code> (如果违反此限制将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>)。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII 的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损坏）。</p>
<p>除了字面值形式，bytes 对象还可以通过其他几种方式来创建：</p>
<ul>
<li><p>指定长度的以零值填充的 bytes 对象: <code>bytes(10)</code></p>
</li>
<li><p>通过由整数组成的可迭代对象: <code>bytes(range(20))</code></p>
</li>
<li><p>通过缓冲区协议复制现有的二进制数据: <code>bytes(obj)</code></p>
</li>
</ul>
<p>另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-bytes">bytes</a> 内置类型。</p>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法：</p>
<p><em>classmethod</em> <code>fromhex</code>(<em>string</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.fromhex" title="永久链接至目标"></a></p>
<p>此 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bytes.fromhex(‘2Ef0 F1f2  ‘)<br>b’.\xf0\xf1\xf2’</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.7 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.fromhex" title="bytes.fromhex"><code>bytes.fromhex()</code></a> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
<p>存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。</p>
<p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.hex" title="永久链接至目标"></a></p>
<p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’\xf0\xf1\xf2’.hex()<br>‘f0f1f2’</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 <em>sep</em> 形参包含于输出中。 默认情况下，该分隔符会放在每个字节之间。 第二个可选的 <em>bytes_per_sep</em> 形参控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>value &#x3D; b’\xf0\xf1\xf2’<br>value.hex(‘-‘)<br>‘f0-f1-f2’<br>value.hex(‘_’, 2)<br>‘f0_f1f2’<br>b’UUDDLRLRAB’.hex(‘ ‘, -4)<br>‘55554444 4c524c52 4142’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.hex" title="bytes.hex"><code>bytes.hex()</code></a> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 形参以在十六进制输出的字节之间插入分隔符。</p>
<p>由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 _b_，<code>b[0]</code> 将为一个整数，而 <code>b[0:1]</code> 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytes 对象的表示使用字面值格式 (<code>b&#39;...&#39;</code>)，因为它通常都要比像 <code>bytes([46, 46, 46])</code> 这样的格式更好用。 你总是可以使用 <code>list(b)</code> 将 bytes 对象转换为一个由整数构成的列表。</p>
<h3 id="bytearray-对象"><a href="#bytearray-对象" class="headerlink" title="bytearray 对象"></a>bytearray 对象</h3><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 对象是 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象的可变对应物。</p>
<p><em>class</em> <code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="永久链接至目标"></a></p>
<p>bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：</p>
<ul>
<li><p>创建一个空实例: <code>bytearray()</code></p>
</li>
<li><p>创建一个指定长度的以零值填充的实例: <code>bytearray(10)</code></p>
</li>
<li><p>通过由整数组成的可迭代对象: <code>bytearray(range(20))</code></p>
</li>
<li><p>通过缓冲区协议复制现有的二进制数据: <code>bytearray(b&#39;Hi!&#39;)</code></p>
</li>
</ul>
<p>由于 bytearray 对象是可变的，该对象除了 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes-methods">bytes 和 bytearray 操作</a> 中所描述的 bytes 和 bytearray 共有操作之外，还支持 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-mutable">可变</a> 序列操作。</p>
<p>另请参见 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#func-bytearray">bytearray</a> 内置类型。</p>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法：</p>
<p><em>classmethod</em> <code>fromhex</code>(<em>string</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.fromhex" title="永久链接至目标"></a></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bytearray.fromhex(‘2Ef0 F1f2  ‘)<br>bytearray(b’.\xf0\xf1\xf2’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.7 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.fromhex" title="bytearray.fromhex"><code>bytearray.fromhex()</code></a> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
<p>存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。</p>
<p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.hex" title="永久链接至目标"></a></p>
<p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bytearray(b’\xf0\xf1\xf2’).hex()<br>‘f0f1f2’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.hex" title="bytes.hex"><code>bytes.hex()</code></a> 相似， <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.hex" title="bytearray.hex"><code>bytearray.hex()</code></a> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 参数以在十六进制输出的字节之间插入分隔符。</p>
<p>由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 _b_，<code>b[0]</code> 将为一个整数，而 <code>b[0:1]</code> 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytearray 对象的表示使用 bytes 对象字面值格式 (<code>bytearray(b&#39;...&#39;)</code>)，因为它通常都要比 <code>bytearray([46, 46, 46])</code> 这样的格式更好用。 你总是可以使用 <code>list(b)</code> 将 bytearray 对象转换为一个由整数构成的列表。</p>
<h3 id="bytes-和-bytearray-操作"><a href="#bytes-和-bytearray-操作" class="headerlink" title="bytes 和 bytearray 操作"></a>bytes 和 bytearray 操作</h3><p>bytes 和 bytearray 对象都支持 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#typesseq-common">通用</a> 序列操作。 它们不仅能与相同类型的操作数，也能与任何 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。</p>
<p>注解</p>
<p> </p>
<p>bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes 对象作为其参数一样。 例如，你必须使用以下写法:</p>
<p>a &#x3D; “abc”<br>b &#x3D; a.replace(“a”, “f”)</p>
<p>和:</p>
<p>a &#x3D; b”abc”<br>b &#x3D; a.replace(b”a”, b”f”)</p>
<p>某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当避免使用。 这些限制会在下文中说明。</p>
<p>注解</p>
<p> </p>
<p>使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数据损坏。</p>
<p>bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。</p>
<p><code>bytes.``count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.count" title="永久链接至目标"></a></p>
<p><code>bytearray.``count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.count" title="永久链接至目标"></a></p>
<p>返回子序列 <em>sub</em> 在 [<em>start</em>, <em>end</em>] 范围内非重叠出现的次数。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p>要搜索的子序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 或是 0 至 255 范围内的整数。</p>
<p>如果 <em>sub</em> 为空，则返回字符之间的空切片的数量即字节串对象的长度加一。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.``removeprefix</code>(<em>prefix</em>, <em>&#x2F;</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.removeprefix" title="永久链接至目标"></a></p>
<p><code>bytearray.``removeprefix</code>(<em>prefix</em>, <em>&#x2F;</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.removeprefix" title="永久链接至目标"></a></p>
<p>如果二进制数据以 <em>prefix</em> 字符串开头，返回 <code>bytes[len(prefix):]</code>。 否则，返回原始二进制数据的副本：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’TestHook’.removeprefix(b’Test’)<br>b’Hook’<br>b’BaseTestCase’.removeprefix(b’Test’)<br>b’BaseTestCase’</p>
</blockquote>
</blockquote>
</blockquote>
<p><em>prefix</em> 可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>3.9 新版功能.</p>
<p><code>bytes.``removesuffix</code>(<em>suffix</em>, <em>&#x2F;</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.removesuffix" title="永久链接至目标"></a></p>
<p><code>bytearray.``removesuffix</code>(<em>suffix</em>, <em>&#x2F;</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.removesuffix" title="永久链接至目标"></a></p>
<p>如果二进制数据以 <em>suffix</em> 字符串结尾，并且 <em>suffix</em> 非空，返回 <code>bytes[:-len(suffix)]</code>。 否则，返回原始二进制数据的副本:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’MiscTests’.removesuffix(b’Tests’)<br>b’Misc’<br>b’TmpDirMixin’.removesuffix(b’Tests’)<br>b’TmpDirMixin’</p>
</blockquote>
</blockquote>
</blockquote>
<p><em>suffix</em> 可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>3.9 新版功能.</p>
<p><code>bytes.``decode</code>(<em>encoding&#x3D;’utf-8’</em>, <em>errors&#x3D;’strict’</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.decode" title="永久链接至目标"></a></p>
<p><code>bytearray.``decode</code>(<em>encoding&#x3D;’utf-8’</em>, <em>errors&#x3D;’strict’</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.decode" title="永久链接至目标"></a></p>
<p>返回解码为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 的字节串。</p>
<p><em>encoding</em> 默认为 <code>&#39;utf-8&#39;</code> ；请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#standard-encodings">标准编码</a> 了解其他可能的值。</p>
<p><em>errors</em> 控制如何处理编码错误。 如为 <code>&#39;strict&#39;</code> (默认值)，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a>。 其他可能的值有 <code>&#39;ignore&#39;</code>, <code>&#39;replace&#39;</code> 以及通过 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#codecs.register_error" title="codecs.register_error"><code>codecs.register_error()</code></a> 注册的任何其他名称。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/codecs.html#error-handlers">错误处理方案</a> 了解详情。</p>
<p>出于性能原因，除非真正发生了编码错误，启用了 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 或使用了 <a href="https://docs.python.org/zh-cn/3.10/using/configure.html#debug-build">调试编译版</a> 否则不会检查 <em>errors</em> 值的有效性。</p>
<p>注解</p>
<p> </p>
<p>将 <em>encoding</em> 参数传给 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 允许直接解码任何 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>，无须创建临时的 <code>bytes</code> 或 <code>bytearray</code> 对象。</p>
<p>在 3.1 版更改: 加入了对关键字参数的支持。</p>
<p>在 3.9 版更改: 现在会在 <a href="https://docs.python.org/zh-cn/3.10/library/devmode.html#devmode">Python 开发模式</a> 和 <a href="https://docs.python.org/zh-cn/3.10/using/configure.html#debug-build">调试模式</a> 下检查 <em>errors</em> 参数的值。</p>
<p><code>bytes.``endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.endswith" title="永久链接至目标"></a></p>
<p><code>bytearray.``endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.endswith" title="永久链接至目标"></a></p>
<p>如果二进制数据以指定的 <em>suffix</em> 结束则返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 _start_，将从所指定位置开始检查。 如果有可选项 _end_，将在所指定位置停止比较。</p>
<p>要搜索的后缀可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p><code>bytes.``find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.find" title="永久链接至目标"></a></p>
<p><code>bytearray.``find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.find" title="永久链接至目标"></a></p>
<p>返回子序列 <em>sub</em> 在数据中被找到的最小索引，<em>sub</em> 包含于切片 <code>s[start:end]</code> 之内。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。</p>
<p>要搜索的子序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 或是 0 至 255 范围内的整数。</p>
<p>注解</p>
<p> </p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.find" title="bytes.find"><code>find()</code></a> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子串，请使用 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#in"><code>in</code></a> 操作符:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Py’ in b’Python’<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.``index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.index" title="永久链接至目标"></a></p>
<p><code>bytearray.``index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.index" title="永久链接至目标"></a></p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.find" title="bytes.find"><code>find()</code></a>，但在找不到子序列时会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p>要搜索的子序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.``join</code>(<em>iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.join" title="永久链接至目标"></a></p>
<p><code>bytearray.``join</code>(<em>iterable</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.join" title="永久链接至目标"></a></p>
<p>返回一个由 <em>iterable</em> 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 <em>iterable</em> 中存在任何非 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">字节类对象</a> 包括存在 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 对象值则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。 提供该方法的 bytes 或 bytearray 对象的内容将作为元素之间的分隔。</p>
<p><em>static</em> <code>bytes.``maketrans</code>(<em>from</em>, <em>to</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.maketrans" title="永久链接至目标"></a></p>
<p><em>static</em> <code>bytearray.``maketrans</code>(<em>from</em>, <em>to</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.maketrans" title="永久链接至目标"></a></p>
<p>此静态方法返回一个可用于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.translate" title="bytes.translate"><code>bytes.translate()</code></a> 的转换对照表，它将把 <em>from</em> 中的每个字符映射为 <em>to</em> 中相同位置上的字符；<em>from</em> 与 <em>to</em> 必须都是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">字节类对象</a> 并且具有相同的长度。</p>
<p>3.1 新版功能.</p>
<p><code>bytes.``partition</code>(<em>sep</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.partition" title="永久链接至目标"></a></p>
<p><code>bytearray.``partition</code>(<em>sep</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.partition" title="永久链接至目标"></a></p>
<p>在 <em>sep</em> 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原序列以及两个空的 bytes 或 bytearray 对象。</p>
<p>要搜索的分隔符可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p><code>bytes.``replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.replace" title="永久链接至目标"></a></p>
<p><code>bytearray.``replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.replace" title="永久链接至目标"></a></p>
<p>返回序列的副本，其中出现的所有子序列 <em>old</em> 都将被替换为 _new_。 如果给出了可选参数 _count_，则只替换前 <em>count</em> 次出现。</p>
<p>要搜索的子序列及其替换序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rfind" title="永久链接至目标"></a></p>
<p><code>bytearray.``rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rfind" title="永久链接至目标"></a></p>
<p>返回子序列 <em>sub</em> 在序列内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code>s[start:end]</code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p>要搜索的子序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.``rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rindex" title="永久链接至目标"></a></p>
<p><code>bytearray.``rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rindex" title="永久链接至目标"></a></p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rfind" title="bytes.rfind"><code>rfind()</code></a>，但在子序列 <em>sub</em> 未找到时会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>。</p>
<p>要搜索的子序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.``rpartition</code>(<em>sep</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rpartition" title="永久链接至目标"></a></p>
<p><code>bytearray.``rpartition</code>(<em>sep</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rpartition" title="永久链接至目标"></a></p>
<p>在 <em>sep</em> 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空的 bytes 或 bytearray 对象以及原序列的副本。</p>
<p>要搜索的分隔符可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p><code>bytes.``startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.startswith" title="永久链接至目标"></a></p>
<p><code>bytearray.``startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.startswith" title="永久链接至目标"></a></p>
<p>如果二进制数据以指定的 <em>prefix</em> 开头则返回 <code>True</code>，否则返回 <code>False</code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 _start_，将从所指定位置开始检查。 如果有可选项 _end_，将在所指定位置停止比较。</p>
<p>要搜索的前缀可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p><code>bytes.``translate</code>(<em>table</em>, <em>&#x2F;</em>, <em>delete&#x3D;b’’</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.translate" title="永久链接至目标"></a></p>
<p><code>bytearray.``translate</code>(<em>table</em>, <em>&#x2F;</em>, <em>delete&#x3D;b’’</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.translate" title="永久链接至目标"></a></p>
<p>返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 <em>delete</em> 中出现的 bytes，其余 bytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。</p>
<p>你可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.maketrans" title="bytes.maketrans"><code>bytes.maketrans()</code></a> 方法来创建转换表。</p>
<p>对于仅需移除字符的转换，请将 <em>table</em> 参数设为 <code>None</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’read this short text’.translate(None, b’aeiou’)<br>b’rd ths shrt txt’</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.6 版更改: 现在支持将 <em>delete</em> 作为关键字参数。</p>
<p>以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适当的参数仍然可用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 <em>不是</em> 原地执行操作，而是会产生新的对象。</p>
<p><code>bytes.``center</code>(<em>width</em>[, <em>fillbyte</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.center" title="永久链接至目标"></a></p>
<p><code>bytearray.``center</code>(<em>width</em>[, <em>fillbyte</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.center" title="永久链接至目标"></a></p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列内居中，使用指定的 <em>fillbyte</em> 填充两边的空位（默认使用 ASCII 空格符）。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``ljust</code>(<em>width</em>[, <em>fillbyte</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.ljust" title="永久链接至目标"></a></p>
<p><code>bytearray.``ljust</code>(<em>width</em>[, <em>fillbyte</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.ljust" title="永久链接至目标"></a></p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列中靠左对齐。 使用指定的 <em>fillbyte</em> 填充空位（默认使用 ASCII 空格符）。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``lstrip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.lstrip" title="永久链接至目标"></a></p>
<p><code>bytearray.``lstrip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.lstrip" title="永久链接至目标"></a></p>
<p>返回原序列的副本，移除指定的前导字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’   spacious   ‘.lstrip()<br>b’spacious   ‘<br>b’<a href="http://www.example.com'.lstrip(b'cmowz.')/">www.example.com&#39;.lstrip(b&#39;cmowz.&#39;)</a><br>b’example.com’</p>
</blockquote>
</blockquote>
</blockquote>
<p>要移除的二进制序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 。 要删除单个前缀字符串，而不是全部给定集合中的字符，请参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.removeprefix" title="str.removeprefix"><code>str.removeprefix()</code></a> 方法。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Arthur: three!’.lstrip(b’Arthur: ‘)<br>b’ee!’<br>b’Arthur: three!’.removeprefix(b’Arthur: ‘)<br>b’three!’</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``rjust</code>(<em>width</em>[, <em>fillbyte</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rjust" title="永久链接至目标"></a></p>
<p><code>bytearray.``rjust</code>(<em>width</em>[, <em>fillbyte</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rjust" title="永久链接至目标"></a></p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列中靠右对齐。 使用指定的 <em>fillbyte</em> 填充空位（默认使用 ASCII 空格符）。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``rsplit</code>(<em>sep&#x3D;None</em>, <em>maxsplit&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rsplit" title="永久链接至目标"></a></p>
<p><code>bytearray.``rsplit</code>(<em>sep&#x3D;None</em>, <em>maxsplit&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rsplit" title="永久链接至目标"></a></p>
<p>将二进制序列拆分为相同类型的子序列，使用 <em>sep</em> 作为分隔符。 如果给出了 _maxsplit_，则最多进行 <em>maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何只包含 ASCII 空白符的子序列都会被作为分隔符。 除了从右边开始拆分，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rsplit" title="bytearray.rsplit"><code>rsplit()</code></a> 的其他行为都类似于下文所述的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.split" title="bytearray.split"><code>split()</code></a>。</p>
<p><code>bytes.``rstrip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.rstrip" title="永久链接至目标"></a></p>
<p><code>bytearray.``rstrip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.rstrip" title="永久链接至目标"></a></p>
<p>返回原序列的副本，移除指定的末尾字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’   spacious   ‘.rstrip()<br>b’   spacious’<br>b’mississippi’.rstrip(b’ipz’)<br>b’mississ’</p>
</blockquote>
</blockquote>
</blockquote>
<p>要移除的二进制序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a> 。 要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.removesuffix" title="str.removesuffix"><code>str.removesuffix()</code></a> 方法。 例如:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Monty Python’.rstrip(b’ Python’)<br>b’M’<br>b’Monty Python’.removesuffix(b’ Python’)<br>b’Monty’</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``split</code>(<em>sep&#x3D;None</em>, <em>maxsplit&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.split" title="永久链接至目标"></a></p>
<p><code>bytearray.``split</code>(<em>sep&#x3D;None</em>, <em>maxsplit&#x3D;- 1</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.split" title="永久链接至目标"></a></p>
<p>将二进制序列拆分为相同类型的子序列，使用 <em>sep</em> 作为分隔符。 如果给出了 <em>maxsplit</em> 且非负值，则最多进行 <em>maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 _sep_，则连续的分隔符不会被组合在一起而是被视为分隔空子序列 (例如 <code>b&#39;1,,2&#39;.split(b&#39;,&#39;)</code> 将返回 <code>[b&#39;1&#39;, b&#39;&#39;, b&#39;2&#39;]</code>)。 <em>sep</em> 参数可能为一个多字节序列 (例如 <code>b&#39;1&lt;&gt;2&lt;&gt;3&#39;.split(b&#39;&lt;&gt;&#39;)</code> 将返回 <code>[b&#39;1&#39;, b&#39;2&#39;, b&#39;3&#39;]</code>)。 使用指定的分隔符拆分空序列将返回 <code>[b&#39;&#39;]</code> 或 <code>[bytearray(b&#39;&#39;)]</code>，具体取决于被拆分对象的类型。 <em>sep</em> 参数可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’1,2,3’.split(b’,’)<br>[b’1’, b’2’, b’3’]<br>b’1,2,3’.split(b’,’, maxsplit&#x3D;1)<br>[b’1’, b’2,3’]<br>b’1,2,,3,’.split(b’,’)<br>[b’1’, b’2’, b’’, b’3’, b’’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果 <em>sep</em> 未指定或为 <code>None</code>，则会应用另一种拆分算法：连续的 ASCII 空白符会被视为单个分隔符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅包含 ASCII 空白符的序列进行拆分将返回 <code>[]</code>。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’1 2 3’.split()<br>[b’1’, b’2’, b’3’]<br>b’1 2 3’.split(maxsplit&#x3D;1)<br>[b’1’, b’2 3’]<br>b’   1   2   3   ‘.split()<br>[b’1’, b’2’, b’3’]</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>bytes.``strip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.strip" title="永久链接至目标"></a></p>
<p><code>bytearray.``strip</code>([<em>chars</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.strip" title="永久链接至目标"></a></p>
<p>返回原序列的副本，移除指定的开头和末尾字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’   spacious   ‘.strip()<br>b’spacious’<br>b’<a href="http://www.example.com'.strip(b'cmowz.')/">www.example.com&#39;.strip(b&#39;cmowz.&#39;)</a><br>b’example’</p>
</blockquote>
</blockquote>
</blockquote>
<p>要移除的字节值二进制序列可以是任意 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-bytes-like-object">bytes-like object</a>。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 <em>不是</em> 原地执行操作，而是会产生新的对象。</p>
<p><code>bytes.``capitalize</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.capitalize" title="永久链接至目标"></a></p>
<p><code>bytearray.``capitalize</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.capitalize" title="永久链接至目标"></a></p>
<p>返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大写而其余的小写。 非 ASCII 字节值将保持原样不变。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``expandtabs</code>(<em>tabsize&#x3D;8</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.expandtabs" title="永久链接至目标"></a></p>
<p><code>bytearray.``expandtabs</code>(<em>tabsize&#x3D;8</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.expandtabs" title="永久链接至目标"></a></p>
<p>返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字节设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。 如果字节为 ASCII 制表符 (<code>b&#39;\t&#39;</code>)，则并在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果当前字节为 ASCII 换行符 (<code>b&#39;\n&#39;</code>) 或回车符 (<code>b&#39;\r&#39;</code>)，它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加一，不论该字节值在被打印时会如何显示:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’01\t012\t0123\t01234’.expandtabs()<br>b’01      012     0123    01234’<br>b’01\t012\t0123\t01234’.expandtabs(4)<br>b’01  012 0123    01234’</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``isalnum</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.isalnum" title="永久链接至目标"></a></p>
<p><code>bytearray.``isalnum</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.isalnum" title="永久链接至目标"></a></p>
<p>如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 字母类 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。 ASCII 十进制数码就是字节值包含在序列 <code>b&#39;0123456789&#39;</code> 中的字符。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’ABCabc1’.isalnum()<br>True<br>b’ABC abc1’.isalnum()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>bytes.``isalpha</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.isalpha" title="永久链接至目标"></a></p>
<p><code>bytearray.``isalpha</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.isalpha" title="永久链接至目标"></a></p>
<p>如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 字母类 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’ABCabc’.isalpha()<br>True<br>b’ABCabc1’.isalpha()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>bytes.``isascii</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.isascii" title="永久链接至目标"></a></p>
<p><code>bytearray.``isascii</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.isascii" title="永久链接至目标"></a></p>
<p>如果序列为空或序列中所有字节都是 ASCII 字节则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 字节的取值范围是 0-0x7F。</p>
<p>3.7 新版功能.</p>
<p><code>bytes.``isdigit</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.isdigit" title="永久链接至目标"></a></p>
<p><code>bytearray.``isdigit</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.isdigit" title="永久链接至目标"></a></p>
<p>如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 十进制数码就是字节值包含在序列 <code>b&#39;0123456789&#39;</code> 中的字符。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’1234’.isdigit()<br>True<br>b’1.23’.isdigit()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>bytes.``islower</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.islower" title="永久链接至目标"></a></p>
<p><code>bytearray.``islower</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.islower" title="永久链接至目标"></a></p>
<p>如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’hello world’.islower()<br>True<br>b’Hello world’.islower()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyz&#39;</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。</p>
<p><code>bytes.``isspace</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.isspace" title="永久链接至目标"></a></p>
<p><code>bytearray.``isspace</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.isspace" title="永久链接至目标"></a></p>
<p>如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 空白符就是字节值包含在序列 <code>b&#39; \t\n\r\x0b\f&#39;</code> (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的字符。</p>
<p><code>bytes.``istitle</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.istitle" title="永久链接至目标"></a></p>
<p><code>bytearray.``istitle</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.istitle" title="永久链接至目标"></a></p>
<p>如果序列为 ASCII 标题大小写形式并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.title" title="bytes.title"><code>bytes.title()</code></a> 了解有关“标题大小写”的详细定义。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Hello World’.istitle()<br>True<br>b’Hello world’.istitle()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>bytes.``isupper</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.isupper" title="永久链接至目标"></a></p>
<p><code>bytearray.``isupper</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.isupper" title="永久链接至目标"></a></p>
<p>如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’HELLO WORLD’.isupper()<br>True<br>b’Hello world’.isupper()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyz&#39;</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。</p>
<p><code>bytes.``lower</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.lower" title="永久链接至目标"></a></p>
<p><code>bytearray.``lower</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.lower" title="永久链接至目标"></a></p>
<p>返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Hello World’.lower()<br>b’hello world’</p>
</blockquote>
</blockquote>
</blockquote>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyz&#39;</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``splitlines</code>(<em>keepends&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.splitlines" title="永久链接至目标"></a></p>
<p><code>bytearray.``splitlines</code>(<em>keepends&#x3D;False</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.splitlines" title="永久链接至目标"></a></p>
<p>返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-universal-newlines">universal newlines</a> 方式来分行。 结果列表中不包含换行符，除非给出了 <em>keepends</em> 且为真值。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’ab c\n\nde fg\rkl\r\n’.splitlines()<br>[b’ab c’, b’’, b’de fg’, b’kl’]<br>b’ab c\n\nde fg\rkl\r\n’.splitlines(keepends&#x3D;True)<br>[b’ab c\n’, b’\n’, b’de fg\r’, b’kl\r\n’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>不同于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.split" title="bytes.split"><code>split()</code></a>，当给出了分隔符 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b””.split(b’\n’), b”Two lines\n”.split(b’\n’)<br>([b’’], [b’Two lines’, b’’])<br>b””.splitlines(), b”One line\n”.splitlines()<br>([], [b’One line’])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>bytes.``swapcase</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.swapcase" title="永久链接至目标"></a></p>
<p><code>bytearray.``swapcase</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.swapcase" title="永久链接至目标"></a></p>
<p>返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Hello World’.swapcase()<br>b’hELLO wORLD’</p>
</blockquote>
</blockquote>
</blockquote>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyz&#39;</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。</p>
<p>不同于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str.swapcase" title="str.swapcase"><code>str.swapcase()</code></a>，在些二进制版本下 <code>bin.swapcase().swapcase() == bin</code> 总是成立。 大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``title</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.title" title="永久链接至目标"></a></p>
<p><code>bytearray.``title</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.title" title="永久链接至目标"></a></p>
<p>返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小写。 不区别大小写的字节值将保持原样不变。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Hello world’.title()<br>b’Hello World’</p>
</blockquote>
</blockquote>
</blockquote>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyz&#39;</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。 所有其他字节值都不区分大小写。</p>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b”they’re bill’s friends from the UK”.title()<br>b”They’Re Bill’S Friends From The Uk”</p>
</blockquote>
</blockquote>
</blockquote>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import re<br>def titlecase(s):<br>…     return re.sub(rb”[A-Za-z]+(‘[A-Za-z]+)?”,<br>…                   lambda mo: mo.group(0)[0:1].upper() +<br>…                              mo.group(0)[1:].lower(),<br>…                   s)<br>…<br>titlecase(b”they’re bill’s friends.”)<br>b”They’re Bill’s Friends.”</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``upper</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.upper" title="永久链接至目标"></a></p>
<p><code>bytearray.``upper</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.upper" title="永久链接至目标"></a></p>
<p>返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b’Hello World’.upper()<br>b’HELLO WORLD’</p>
</blockquote>
</blockquote>
</blockquote>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b&#39;abcdefghijklmnopqrstuvwxyz&#39;</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code> 中的字符。</p>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.``zfill</code>(<em>width</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.zfill" title="永久链接至目标"></a></p>
<p><code>bytearray.``zfill</code>(<em>width</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray.zfill" title="永久链接至目标"></a></p>
<p>返回原序列的副本，在左边填充 <code>b&#39;0&#39;</code> 数码使序列长度为 _width_。 正负值前缀 (<code>b&#39;+&#39;</code>&#x2F; <code>b&#39;-&#39;</code>) 的处理方式是在正负符号 <em>之后</em> 填充而非在之前。 对于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 对象，如果 <em>width</em> 小于等于 <code>len(seq)</code> 则返回原序列。</p>
<p>例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b”42”.zfill(5)<br>b’00042’<br>b”-42”.zfill(5)<br>b’-0042’</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<h3 id="风格的字节串格式化printf"><a href="#风格的字节串格式化printf" class="headerlink" title="风格的字节串格式化printf"></a>风格的字节串格式化<code>printf</code></h3><p>注解</p>
<p> </p>
<p>此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。</p>
<p>字节串对象 (<code>bytes</code>&#x2F;<code>bytearray</code>) 具有一种特殊的内置操作：使用 <code>%</code> (取模) 运算符。 这也被称为字节串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code>format % values</code> (其中 <em>format</em> 为一个字节串对象)，在 <em>format</em> 中的 <code>%</code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于在 C 语言中使用 <code>sprintf()</code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id16">5</a> 否则的话，<em>values</em> 必须或是是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象（例如元组）。</p>
<p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol>
<li><p><code>&#39;%&#39;</code> 字符，用于标记转换符的起始。</p>
</li>
<li><p>映射键（可选），由加圆括号的字符序列组成 (例如 <code>(somename)</code>)。</p>
</li>
<li><p>转换旗标（可选），用于影响某些转换类型的结果。</p>
</li>
<li><p>最小字段宽度（可选）。 如果指定为 <code>&#39;*&#39;</code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</p>
</li>
<li><p>精度（可选），以在 <code>&#39;.&#39;</code> (点号) 之后加精度值的形式给出。 如果指定为 <code>&#39;*&#39;</code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</p>
</li>
<li><p>长度修饰符（可选）。</p>
</li>
<li><p>转换类型。</p>
</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 <em>必须</em> 包含加圆括号的映射键，对应 <code>&#39;%&#39;</code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print(b’%(language)s has %(number)03d quote types.’ %<br>…       {b’language’: b”Python”, b”number”: 2})<br>b’Python has 002 quote types.’</p>
</blockquote>
</blockquote>
</blockquote>
<p>在此情况下格式中不能出现 <code>*</code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>含意</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;#&#39;</code></td>
<td>值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr>
<td><code>&#39;0&#39;</code></td>
<td>转换将为数字值填充零字符。</td>
</tr>
<tr>
<td><code>&#39;-&#39;</code></td>
<td>转换值将靠左对齐（如果同时给出 <code>&#39;0&#39;</code> 转换，则会覆盖后者）。</td>
</tr>
<tr>
<td><code>&#39; &#39;</code></td>
<td>(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>符号字符 (<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td>
</tr>
</tbody></table>
<p>可以给出长度修饰符 (<code>h</code>, <code>l</code> 或 <code>L</code>)，但会被忽略，因为对 Python 来说没有必要 – 所以 <code>%ld</code> 等价于 <code>%d</code>。</p>
<p>转换类型为：</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>含意</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;d&#39;</code></td>
<td>有符号十进制整数。</td>
<td></td>
</tr>
<tr>
<td><code>&#39;i&#39;</code></td>
<td>有符号十进制整数。</td>
<td></td>
</tr>
<tr>
<td><code>&#39;o&#39;</code></td>
<td>有符号八进制数。</td>
<td>(1)</td>
</tr>
<tr>
<td><code>&#39;u&#39;</code></td>
<td>过时类型 – 等价于 <code>&#39;d&#39;</code>。</td>
<td>(8)</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>有符号十六进制数（小写）。</td>
<td>(2)</td>
</tr>
<tr>
<td><code>&#39;X&#39;</code></td>
<td>有符号十六进制数（大写）。</td>
<td>(2)</td>
</tr>
<tr>
<td><code>&#39;e&#39;</code></td>
<td>浮点指数格式（小写）。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;E&#39;</code></td>
<td>浮点指数格式（大写）。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;f&#39;</code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;F&#39;</code></td>
<td>浮点十进制格式。</td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;g&#39;</code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr>
<td><code>&#39;G&#39;</code></td>
<td>浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td>(4)</td>
</tr>
<tr>
<td><code>&#39;c&#39;</code></td>
<td>单个字节（接受整数或单个字节对象）。</td>
<td></td>
</tr>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>字节串（任何遵循 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲区协议</a> 或是具有 <code>__bytes__()</code> 的对象）。</td>
<td>(5)</td>
</tr>
<tr>
<td><code>&#39;s&#39;</code></td>
<td><code>&#39;s&#39;</code> 是 <code>&#39;b&#39;</code> 的一个别名，只应当在基于 Python2&#x2F;3 的代码中使用。</td>
<td>(6)</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>字节串（使用 <code>repr(obj).encode(&#39;ascii&#39;, &#39;backslashreplace&#39;)</code> 来转换任意 Python 对象）。</td>
<td>(5)</td>
</tr>
<tr>
<td><code>&#39;r&#39;</code></td>
<td><code>&#39;r&#39;</code> 是 <code>&#39;a&#39;</code> 的一个别名，只应当在基于 Python2&#x2F;3 的代码中使用。</td>
<td>(7)</td>
</tr>
<tr>
<td><code>&#39;%&#39;</code></td>
<td>不转换参数，在结果中输出一个 <code>&#39;%&#39;</code> 字符。</td>
<td></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code>&#39;0o&#39;</code>)。</p>
</li>
<li><p>此替代形式会在第一个数码之前插入 <code>&#39;0x&#39;</code> 或 <code>&#39;0X&#39;</code> 前缀（取决于是使用 <code>&#39;x&#39;</code> 还是 <code>&#39;X&#39;</code> 格式）。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p> 小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p> 小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p>如果精度为 <code>N</code>，输出将截短为 <code>N</code> 个字符。</p>
</li>
<li><p><code>b&#39;%s&#39;</code> 已弃用，但在 3.x 系列中将不会被移除。</p>
</li>
<li><p><code>b&#39;%r&#39;</code> 已弃用，但在 3.x 系列中将不会被移除。</p>
</li>
<li><p>参见 <a href="https://www.python.org/dev/peps/pep-0237"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>注解</p>
<p> </p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>参见</p>
<p> </p>
<p><a href="https://www.python.org/dev/peps/pep-0461"><strong>PEP 461</strong></a> - 为 bytes 和 bytearray 添加 % 格式化</p>
<p>3.5 新版功能.</p>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 <a href="https://docs.python.org/zh-cn/3.10/c-api/buffer.html#bufferobjects">缓冲区协议</a> 而无需进行拷贝。</p>
<p><em>class</em> <code>memoryview</code>(<em>object</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="永久链接至目标"></a></p>
<p>创建一个引用 <em>object</em> 的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 。 <em>object</em> 必须支持缓冲区协议。支持缓冲区协议的内置对象有 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 有 <strong>元素</strong> 的概念， <strong>元素</strong> 指由原始 <em>object</em> 处理的原子内存单元。对于许多简单的类型，如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> ，一个元素是一个字节，但其他类型，如 <a href="https://docs.python.org/zh-cn/3.10/library/array.html#array.array" title="array.array"><code>array.array</code></a> 可能有更大的元素。</p>
<p><code>len(view)</code> 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tolist" title="memoryview.tolist"><code>tolist</code></a> 的长度相等。 如果 <code>view.ndim = 0</code>，则其长度为 1。 如果 <code>view.ndim = 1</code>，则其长度等于 view 中元素的数量。 对于更高的维度，其长度等于表示 view 的嵌套列表的长度。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.itemsize" title="memoryview.itemsize"><code>itemsize</code></a> 属性可向你给出单个元素所占的字节数。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>v &#x3D; memoryview(b’abcefg’)<br>v[1]<br>98<br>v[-1]<br>103<br>v[1:4]<br>&lt;memory at 0x7f3ddc9f4350&gt;<br>bytes(v[1:4])<br>b’bce’</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.format" title="memoryview.format"><code>format</code></a> 是一个来自于 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 <em>元素_。 一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 <em>ndim</em> 个整数构成的元素进行索引，_ndim</em> 即其维度。 零维内存视图可以使用空元组进行索引。</p>
<p>这里是一个使用非字节格式的例子:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import array<br>a &#x3D; array.array(‘l’, [-11111111, 22222222, -33333333, 44444444])<br>m &#x3D; memoryview(a)<br>m[0]<br>-11111111<br>m[-1]<br>44444444<br>m[::2].tolist()<br>[-11111111, -33333333]</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>data &#x3D; bytearray(b’abcefg’)<br>v &#x3D; memoryview(data)<br>v.readonly<br>False<br>v[0] &#x3D; ord(b’z’)<br>data<br>bytearray(b’zbcefg’)<br>v[1:4] &#x3D; b’123’<br>data<br>bytearray(b’z123fg’)<br>v[2:3] &#x3D; b’spam’<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>ValueError: memoryview assignment: lvalue and rvalue have different structures<br>v[2:6] &#x3D; b’spam’<br>data<br>bytearray(b’z1spam’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>格式符为 ‘B’, ‘b’ 或 ‘c’ 的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a> (只读) 类型的一维内存视图也是可哈希对象。 哈希被定义为 <code>hash(m) == hash(m.tobytes())</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>v &#x3D; memoryview(b’abcefg’)<br>hash(v) &#x3D;&#x3D; hash(b’abcefg’)<br>True<br>hash(v[2:4]) &#x3D;&#x3D; hash(b’ce’)<br>True<br>hash(v[::-2]) &#x3D;&#x3D; hash(b’abcefg’[::-2])<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.3 版更改: 一维内存视图现在可以被切片。 格式符为 ‘B’, ‘b’ 或 ‘c’ 的一维内存视图现在是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a>。</p>
<p>在 3.4 版更改: 内存视图现在会自动注册为 <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a></p>
<p>在 3.5 版更改: 内存视图现在可使用整数元组进行索引。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview" title="memoryview"><code>memoryview</code></a> 具有以下一些方法：</p>
<p><code>__eq__</code>(<em>exporter</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.__eq__" title="永久链接至目标"></a></p>
<p>memoryview 与 <a href="https://www.python.org/dev/peps/pep-3118"><strong>PEP 3118</strong></a> 中的导出器这两者如果形状相同，并且如果当使用 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。</p>
<p>对于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tolist" title="memoryview.tolist"><code>tolist()</code></a> 当前所支持的 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 格式字符串子集，如果 <code>v.tolist() == w.tolist()</code> 则 <code>v</code> 和 <code>w</code> 相等:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import array<br>a &#x3D; array.array(‘I’, [1, 2, 3, 4, 5])<br>b &#x3D; array.array(‘d’, [1.0, 2.0, 3.0, 4.0, 5.0])<br>c &#x3D; array.array(‘b’, [5, 3, 1])<br>x &#x3D; memoryview(a)<br>y &#x3D; memoryview(b)<br>x &#x3D;&#x3D; a &#x3D;&#x3D; y &#x3D;&#x3D; b<br>True<br>x.tolist() &#x3D;&#x3D; a.tolist() &#x3D;&#x3D; y.tolist() &#x3D;&#x3D; b.tolist()<br>True<br>z &#x3D; y[::-2]<br>z &#x3D;&#x3D; c<br>True<br>z.tolist() &#x3D;&#x3D; c.tolist()<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果两边的格式字符串都不被 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 模块所支持，则两对象比较结果总是不相等（即使格式字符串和缓冲区内容相同）:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from ctypes import BigEndianStructure, c_long<br>class BEPoint(BigEndianStructure):<br>…     <em>fields</em> &#x3D; [(“x”, c_long), (“y”, c_long)]<br>…<br>point &#x3D; BEPoint(100, 200)<br>a &#x3D; memoryview(point)<br>b &#x3D; memoryview(point)<br>a &#x3D;&#x3D; point<br>False<br>a &#x3D;&#x3D; b<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>请注意，与浮点数的情况一样，对于内存视图对象来说，<code>v is w</code> 也 <em>并不</em> 意味着 <code>v == w</code>。</p>
<p>在 3.3 版更改: 之前的版本比较原始内存时会忽略条目的格式与逻辑数组结构。</p>
<p><code>tobytes</code>(<em>order&#x3D;None</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tobytes" title="永久链接至目标"></a></p>
<p>将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 构造器。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; memoryview(b”abc”)<br>m.tobytes()<br>b’abc’<br>bytes(m)<br>b’abc’</p>
</blockquote>
</blockquote>
</blockquote>
<p>对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tobytes" title="memoryview.tobytes"><code>tobytes()</code></a> 支持所有格式字符串，不符合 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 模块语法的那些也包括在内。</p>
<p>3.8 新版功能: <em>order</em> 可以为 {‘C’, ‘F’, ‘A’}。 当 <em>order</em> 为 ‘C’ 或 ‘F’ 时，原始数组的数据会被转换至 C 或 Fortran 顺序。 对于连续视图，’A’ 会返回物理内存的精确副本。 特别地，内存中的 Fortran 顺序会被保留。对于非连续视图，数据会先被转换为 C 形式。 <em>order&#x3D;None</em> 与 <em>order&#x3D;’C’</em> 是相同的。</p>
<p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.hex" title="永久链接至目标"></a></p>
<p>返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; memoryview(b”abc”)<br>m.hex()<br>‘616263’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes.hex" title="bytes.hex"><code>bytes.hex()</code></a> 相似， <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.hex" title="memoryview.hex"><code>memoryview.hex()</code></a> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 参数以在十六进制输出的字节之间插入分隔符。</p>
<p><code>tolist</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tolist" title="永久链接至目标"></a></p>
<p>将缓冲区内的数据以一个元素列表的形式返回。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>memoryview(b’abc’).tolist()<br>[97, 98, 99]<br>import array<br>a &#x3D; array.array(‘d’, [1.1, 2.2, 3.3])<br>m &#x3D; memoryview(a)<br>m.tolist()<br>[1.1, 2.2, 3.3]</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.3 版更改: <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tolist" title="memoryview.tolist"><code>tolist()</code></a> 现在支持 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 模块语法中的所有单字符原生格式以及多维表示形式。</p>
<p><code>toreadonly</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.toreadonly" title="永久链接至目标"></a></p>
<p>返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; memoryview(bytearray(b’abc’))<br>mm &#x3D; m.toreadonly()<br>mm.tolist()<br>[89, 98, 99]<br>mm[0] &#x3D; 42<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: cannot modify read-only memory<br>m[0] &#x3D; 43<br>mm.tolist()<br>[43, 98, 99]</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.8 新版功能.</p>
<p><code>release</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.release" title="永久链接至目标"></a></p>
<p>释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动作（例如，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytearray" title="bytearray"><code>bytearray</code></a> 将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽早去除这些限制（并释放任何多余的资源）。</p>
<p>在此方法被调用后，任何对视图的进一步操作将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a> (<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.release" title="memoryview.release"><code>release()</code></a> 本身除外，它可以被多次调用):</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m &#x3D; memoryview(b’abc’)<br>m.release()<br>m[0]<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>ValueError: operation forbidden on released memoryview object</p>
</blockquote>
</blockquote>
</blockquote>
<p>使用 <code>with</code> 语句，可以通过上下文管理协议达到类似的效果:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>with memoryview(b’abc’) as m:<br>…     m[0]<br>…<br>97<br>m[0]<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>ValueError: operation forbidden on released memoryview object</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.2 新版功能.</p>
<p><code>cast</code>(<em>format</em>[, <em>shape</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.cast" title="永久链接至目标"></a></p>
<p>将内存视图转化为新的格式或形状。 <em>shape</em> 默认为 <code>[byte_length//new_itemsize]</code>，这意味着结果视图将是一维的。 返回值是一个新的内存视图，但缓冲区本身不会被复制。 支持的转化有 1D -&gt; C-<a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-contiguous">contiguous</a> 和 C-contiguous -&gt; 1D。</p>
<p>目标格式仅限于 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 语法中的单一元素原生格式。 其中一种格式必须为字节格式 (‘B’, ‘b’ 或 ‘c’)。 结果的字节长度必须与原始长度相同。</p>
<p>将 1D&#x2F;long 转换为 1D&#x2F;unsigned bytes:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import array<br>a &#x3D; array.array(‘l’, [1,2,3])<br>x &#x3D; memoryview(a)<br>x.format<br>‘l’<br>x.itemsize<br>8<br>len(x)<br>3<br>x.nbytes<br>24<br>y &#x3D; x.cast(‘B’)<br>y.format<br>‘B’<br>y.itemsize<br>1<br>len(y)<br>24<br>y.nbytes<br>24</p>
</blockquote>
</blockquote>
</blockquote>
<p>将 1D&#x2F;unsigned bytes 转换为 1D&#x2F;char:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b &#x3D; bytearray(b’zyz’)<br>x &#x3D; memoryview(b)<br>x[0] &#x3D; b’a’<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>ValueError: memoryview: invalid value for format “B”<br>y &#x3D; x.cast(‘c’)<br>y[0] &#x3D; b’a’<br>b<br>bytearray(b’ayz’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>将 1D&#x2F;bytes 转换为 3D&#x2F;ints 再转换为 1D&#x2F;signed char:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import struct<br>buf &#x3D; struct.pack(“i”*12, *list(range(12)))<br>x &#x3D; memoryview(buf)<br>y &#x3D; x.cast(‘i’, shape&#x3D;[2,2,3])<br>y.tolist()<br>[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]<br>y.format<br>‘i’<br>y.itemsize<br>4<br>len(y)<br>2<br>y.nbytes<br>48<br>z &#x3D; y.cast(‘b’)<br>z.format<br>‘b’<br>z.itemsize<br>1<br>len(z)<br>48<br>z.nbytes<br>48</p>
</blockquote>
</blockquote>
</blockquote>
<p>将 1D&#x2F;unsigned long 转换为 2D&#x2F;unsigned long:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>buf &#x3D; struct.pack(“L”*6, *list(range(6)))<br>x &#x3D; memoryview(buf)<br>y &#x3D; x.cast(‘L’, shape&#x3D;[2,3])<br>len(y)<br>2<br>y.nbytes<br>48<br>y.tolist()<br>[[0, 1, 2], [3, 4, 5]]</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 当转换为字节视图时，源格式将不再受限。</p>
<p>还存在一些可用的只读属性：</p>
<p><code>obj</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.obj" title="永久链接至目标"></a></p>
<p>内存视图的下层对象:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b  &#x3D; bytearray(b’xyz’)<br>m &#x3D; memoryview(b)<br>m.obj is b<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.3 新版功能.</p>
<p><code>nbytes</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.nbytes" title="永久链接至目标"></a></p>
<p><code>nbytes == product(shape) * itemsize == len(m.tobytes())</code>。 这是数组在连续表示时将会占用的空间总字节数。 它不一定等于 <code>len(m)</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import array<br>a &#x3D; array.array(‘i’, [1,2,3,4,5])<br>m &#x3D; memoryview(a)<br>len(m)<br>5<br>m.nbytes<br>20<br>y &#x3D; m[::2]<br>len(y)<br>3<br>y.nbytes<br>12<br>len(y.tobytes())<br>12</p>
</blockquote>
</blockquote>
</blockquote>
<p>多维数组:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import struct<br>buf &#x3D; struct.pack(“d”*12, <em>[1.5</em>x for x in range(12)])<br>x &#x3D; memoryview(buf)<br>y &#x3D; x.cast(‘d’, shape&#x3D;[3,4])<br>y.tolist()<br>[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]<br>len(y)<br>3<br>y.nbytes<br>96</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.3 新版功能.</p>
<p><code>readonly</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.readonly" title="永久链接至目标"></a></p>
<p>一个表明内存是否只读的布尔值。</p>
<p><code>format</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.format" title="永久链接至目标"></a></p>
<p>一个字符串，包含视图中每个元素的格式（表示为 <a href="https://docs.python.org/zh-cn/3.10/library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code>struct</code></a> 模块样式）。 内存视图可以从具有任意格式字符串的导出器创建，但某些方法 (例如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.tolist" title="memoryview.tolist"><code>tolist()</code></a>) 仅限于原生的单元素格式。</p>
<p>在 3.3 版更改: 格式 <code>&#39;B&#39;</code> 现在会按照 struct 模块语法来处理。 这意味着 <code>memoryview(b&#39;abc&#39;)[0] == b&#39;abc&#39;[0] == 97</code>。</p>
<p><code>itemsize</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.itemsize" title="永久链接至目标"></a></p>
<p>memoryview 中每个元素以字节表示的大小:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import array, struct<br>m &#x3D; memoryview(array.array(‘H’, [32000, 32001, 32002]))<br>m.itemsize<br>2<br>m[0]<br>32000<br>struct.calcsize(‘H’) &#x3D;&#x3D; m.itemsize<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>ndim</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.ndim" title="永久链接至目标"></a></p>
<p>一个整数，表示内存所代表的多维数组具有多少个维度。</p>
<p><code>shape</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.shape" title="永久链接至目标"></a></p>
<p>一个整数元组，通过 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.ndim" title="memoryview.ndim"><code>ndim</code></a> 的长度值给出内存所代表的 N 维数组的形状。</p>
<p>在 3.3 版更改: 当 ndim &#x3D; 0 时值为空元组而不再为 <code>None</code>。</p>
<p><code>strides</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.strides" title="永久链接至目标"></a></p>
<p>一个整数元组，通过 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.ndim" title="memoryview.ndim"><code>ndim</code></a> 的长度给出以字节表示的大小，以便访问数组中每个维度上的每个元素。</p>
<p>在 3.3 版更改: 当 ndim &#x3D; 0 时值为空元组而不再为 <code>None</code>。</p>
<p><code>suboffsets</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.suboffsets" title="永久链接至目标"></a></p>
<p>供 PIL 风格的数组内部使用。 该值仅作为参考信息。</p>
<p><code>c_contiguous</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.c_contiguous" title="永久链接至目标"></a></p>
<p>一个表明内存是否为 C-<a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-contiguous">contiguous</a> 的布尔值。</p>
<p>3.3 新版功能.</p>
<p><code>f_contiguous</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.f_contiguous" title="永久链接至目标"></a></p>
<p>一个表明内存是否为 Fortran <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-contiguous">contiguous</a> 的布尔值。</p>
<p>3.3 新版功能.</p>
<p><code>contiguous</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#memoryview.contiguous" title="永久链接至目标"></a></p>
<p>一个表明内存是否为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-contiguous">contiguous</a> 的布尔值。</p>
<p>3.3 新版功能.</p>
<h2 id="集合类型-—-set-frozenset"><a href="#集合类型-—-set-frozenset" class="headerlink" title="集合类型 — set``frozenset"></a>集合类型 — <code>set``frozenset</code></h2><p><em>set</em> 对象是由具有唯一性的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a> 对象所组成的无序多项集。 常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 （关于其他容器对象请参看 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 等内置类，以及 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> 模块。）</p>
<p>与其他多项集一样，集合也支持 <code>x in set</code>, <code>len(set)</code> 和 <code>for x in set</code>。 作为一种无序的多项集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。</p>
<p>目前有两种内置集合类型，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a>。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 类型是可变的 — 其内容可以使用 <code>add()</code> 和 <code>remove()</code> 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集合的元素。 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 类型是不可变并且为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a> — 其内容在被创建后不能再改变；因此它可以被用作字典的键或其他集合的元素。</p>
<p>除了可以使用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: <code>&#123;&#39;jack&#39;, &#39;sjoerd&#39;&#125;</code>。</p>
<p>两个类的构造器具有相同的作用方式：</p>
<p><em>class</em> <code>set</code>([<em>iterable</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="永久链接至目标"></a></p>
<p><em>class</em> <code>frozenset</code>([<em>iterable</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="永久链接至目标"></a></p>
<p>返回一个新的 set 或 frozenset 对象，其元素来自于 _iterable_。 集合的元素必须为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a>。 要表示由集合对象构成的集合，所有的内层集合必须为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 对象。 如果未指定 _iterable_，则将返回一个新的空集合。</p>
<p>集合可用多种方式来创建:</p>
<ul>
<li><p>使用花括号内以逗号分隔元素的方式: <code>&#123;&#39;jack&#39;, &#39;sjoerd&#39;&#125;</code></p>
</li>
<li><p>使用集合推导式: <code>&#123;c for c in &#39;abracadabra&#39; if c not in &#39;abc&#39;&#125;</code></p>
</li>
<li><p>使用类型构造器: <code>set()</code>, <code>set(&#39;foobar&#39;)</code>, <code>set([&#39;a&#39;, &#39;b&#39;, &#39;foo&#39;])</code></p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 的实例提供以下操作：</p>
<p><code>len(s)</code></p>
<p>返回集合 <em>s</em> 中的元素数量（即 <em>s</em> 的基数）。</p>
<p><code>x in s</code></p>
<p>检测 <em>x</em> 是否为 <em>s</em> 中的成员。</p>
<p><code>x not in s</code></p>
<p>检测 <em>x</em> 是否非 <em>s</em> 中的成员。</p>
<p><code>isdisjoint</code>(<em>other</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.isdisjoint" title="永久链接至目标"></a></p>
<p>如果集合中没有与 <em>other</em> 共有的元素则返回 <code>True</code>。 当且仅当两个集合的交集为空集合时，两者为不相交集合。</p>
<p><code>issubset</code>(<em>other</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.issubset" title="永久链接至目标"></a></p>
<p><code>set &lt;= other</code></p>
<p>检测是否集合中的每个元素都在 <em>other</em> 之中。</p>
<p><code>set &lt; other</code></p>
<p>检测集合是否为 <em>other</em> 的真子集，即 <code>set &lt;= other and set != other</code>。</p>
<p><code>issuperset</code>(<em>other</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.issuperset" title="永久链接至目标"></a></p>
<p><code>set &gt;= other</code></p>
<p>检测是否 <em>other</em> 中的每个元素都在集合之中。</p>
<p><code>set &gt; other</code></p>
<p>检测集合是否为 <em>other</em> 的真超集，即 <code>set &gt;= other and set != other</code>。</p>
<p><code>union</code>(<em>*others</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.union" title="永久链接至目标"></a></p>
<p><code>set | other | ...</code></p>
<p>返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。</p>
<p><code>intersection</code>(<em>*others</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.intersection" title="永久链接至目标"></a></p>
<p><code>set &amp; other &amp; ...</code></p>
<p>返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。</p>
<p><code>difference</code>(<em>*others</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.difference" title="永久链接至目标"></a></p>
<p><code>set - other - ...</code></p>
<p>返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。</p>
<p><code>symmetric_difference</code>(<em>other</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.symmetric_difference" title="永久链接至目标"></a></p>
<p><code>set ^ other</code></p>
<p>返回一个新集合，其中的元素或属于原集合或属于 <em>other</em> 指定的其他集合，但不能同时属于两者。</p>
<p><code>copy</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.copy" title="永久链接至目标"></a></p>
<p>返回原集合的浅拷贝。</p>
<p>注意， <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.union" title="frozenset.union"><code>union()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.intersection" title="frozenset.intersection"><code>intersection()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.difference" title="frozenset.difference"><code>difference()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.symmetric_difference" title="frozenset.symmetric_difference"><code>symmetric_difference()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.issubset" title="frozenset.issubset"><code>issubset()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.issuperset" title="frozenset.issuperset"><code>issuperset()</code></a> 方法的非运算符版本可以接受任何可迭代对象作为一个参数。相比之下，基于运算符的对应方法则要求参数为集合对象。这就避开了像 <code>set(&#39;abc&#39;) &amp; &#39;cbs&#39;</code> 这样容易出错的结构，而换成了可读性更好的 <code>set(&#39;abc&#39;).intersection(&#39;cbs&#39;)</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 的实例与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 的实例之间基于它们的成员进行比较。 例如 <code>set(&#39;abc&#39;) == frozenset(&#39;abc&#39;)</code> 返回 <code>True</code>，<code>set(&#39;abc&#39;) in set([frozenset(&#39;abc&#39;)])</code> 也一样。</p>
<p>子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互不为对方的子集，因此以下 <em>所有</em> 比较均返回 <code>False</code>: <code>a&lt;b</code>, <code>a==b</code>, or <code>a&gt;b</code>。</p>
<p>由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list.sort" title="list.sort"><code>list.sort()</code></a> 方法的输出并无定义。</p>
<p>集合的元素，与字典的键类似，必须为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a>。</p>
<p>混合了 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 实例与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 的二进制位运算将返回与第一个操作数相同的类型。例如: <code>frozenset(&#39;ab&#39;) | set(&#39;bc&#39;)</code> 将返回 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 的实例。</p>
<p>下表列出了可用于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 而不能用于不可变的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a> 实例的操作：</p>
<p><code>update</code>(<em>*others</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.update" title="永久链接至目标"></a></p>
<p><code>set |= other | ...</code></p>
<p>更新集合，添加来自 others 中的所有元素。</p>
<p><code>intersection_update</code>(<em>*others</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.intersection_update" title="永久链接至目标"></a></p>
<p><code>set &amp;= other &amp; ...</code></p>
<p>更新集合，只保留其中在所有 others 中也存在的元素。</p>
<p><code>difference_update</code>(<em>*others</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.difference_update" title="永久链接至目标"></a></p>
<p><code>set -= other | ...</code></p>
<p>更新集合，移除其中也存在于 others 中的元素。</p>
<p><code>symmetric_difference_update</code>(<em>other</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.symmetric_difference_update" title="永久链接至目标"></a></p>
<p><code>set ^= other</code></p>
<p>更新集合，只保留存在于集合的一方而非共同存在的元素。</p>
<p><code>add</code>(<em>elem</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.add" title="永久链接至目标"></a></p>
<p>将元素 <em>elem</em> 添加到集合中。</p>
<p><code>remove</code>(<em>elem</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.remove" title="永久链接至目标"></a></p>
<p>从集合中移除元素 _elem_。 如果 <em>elem</em> 不存在于集合中则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p><code>discard</code>(<em>elem</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.discard" title="永久链接至目标"></a></p>
<p>如果元素 <em>elem</em> 存在于集合中则将其移除。</p>
<p><code>pop</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.pop" title="永久链接至目标"></a></p>
<p>从集合中移除并返回任意一个元素。 如果集合为空则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p><code>clear</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.clear" title="永久链接至目标"></a></p>
<p>从集合中移除所有元素。</p>
<p>请注意，非运算符版本的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.update" title="frozenset.update"><code>update()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.intersection_update" title="frozenset.intersection_update"><code>intersection_update()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.difference_update" title="frozenset.difference_update"><code>difference_update()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code>symmetric_difference_update()</code></a> 方法将接受任意可迭代对象作为参数。</p>
<p>请注意，<code>__contains__()</code>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.remove" title="frozenset.remove"><code>remove()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset.discard" title="frozenset.discard"><code>discard()</code></a> 方法的 <em>elem</em> 参数可能是一个 set。 为支持对一个等价的 frozenset 进行搜索，会根据 <em>elem</em> 临时创建一个该类型对象。</p>
<h2 id="映射类型-—dict"><a href="#映射类型-—dict" class="headerlink" title="映射类型 —dict"></a>映射类型 —<code>dict</code></h2><p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-mapping">mapping</a> 对象会将 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a> 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 _字典_。 （关于其他容器对象请参看 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 与 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> 等内置类，以及 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#module-collections" title="collections: Container datatypes"><code>collections</code></a> 模块。）</p>
<p>字典的键 <em>几乎</em> 可以为任何值。 不是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a> 的值，即包含列表、字典或其他可变类型（按值比较而非按对象标识比较）的值不可被用作键。 比较结果相等的值（如 <code>1</code>, <code>1.0</code> 和 <code>True</code> 等）可被互换使用以索引同一个字典条目。</p>
<p><em>class</em> <code>dict</code>(<em>**kwargs</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="永久链接至目标"></a></p>
<p><em>class</em> <code>dict</code>(<em>mapping</em>, <em>**kwargs</em>)</p>
<p><em>class</em> <code>dict</code>(<em>iterable</em>, <em>**kwargs</em>)</p>
<p>返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。</p>
<p>字典可用多种方式来创建:</p>
<ul>
<li><p>使用花括号内以逗号分隔 <code>键: 值</code> 对的方式: <code>&#123;&#39;jack&#39;: 4098, &#39;sjoerd&#39;: 4127&#125;</code> or <code>&#123;4098: &#39;jack&#39;, 4127: &#39;sjoerd&#39;&#125;</code></p>
</li>
<li><p>使用字典推导式: <code>&#123;&#125;</code>, <code>&#123;x: x ** 2 for x in range(10)&#125;</code></p>
</li>
<li><p>使用类型构造器: <code>dict()</code>, <code>dict([(&#39;foo&#39;, 100), (&#39;bar&#39;, 200)])</code>, <code>dict(foo=100, bar=200)</code></p>
</li>
</ul>
<p>如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其属于映射对象，将创建一个具有与映射对象相同键值对的字典。 否则的话，位置参数必须为一个 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a> 对象。 该可迭代对象中的每一项本身必须为一个刚好包含两个元素的可迭代对象。 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值。</p>
<p>如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。</p>
<p>作为演示，以下示例返回的字典均等于 <code>&#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125;</code>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>a &#x3D; dict(one&#x3D;1, two&#x3D;2, three&#x3D;3)<br>b &#x3D; {‘one’: 1, ‘two’: 2, ‘three’: 3}<br>c &#x3D; dict(zip([‘one’, ‘two’, ‘three’], [1, 2, 3]))<br>d &#x3D; dict([(‘two’, 2), (‘one’, 1), (‘three’, 3)])<br>e &#x3D; dict({‘three’: 3, ‘one’: 1, ‘two’: 2})<br>f &#x3D; dict({‘one’: 1, ‘three’: 3}, two&#x3D;2)<br>a &#x3D;&#x3D; b &#x3D;&#x3D; c &#x3D;&#x3D; d &#x3D;&#x3D; e &#x3D;&#x3D; f<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则可使用任何有效的键。</p>
<p>这些是字典所支持的操作（因而自定义的映射类型也应当支持）：</p>
<p><code>list(d)</code></p>
<p>返回字典 <em>d</em> 中使用的所有键的列表。</p>
<p><code>len(d)</code></p>
<p>返回字典 <em>d</em> 中的项数。</p>
<p><code>d[key]</code></p>
<p>返回 <em>d</em> 中以 <em>key</em> 为键的项。 如果映射中不存在 <em>key</em> 则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p>如果字典的子类定义了方法 <code>__missing__()</code> 并且 <em>key</em> 不存在，则 <code>d[key]</code> 操作将调用该方法并附带键 <em>key</em> 作为参数。 <code>d[key]</code> 随后将返回或引发 <code>__missing__(key)</code> 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 <code>__missing__()</code>。 如果未定义 <code>__missing__()</code>，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。 <code>__missing__()</code> 必须是一个方法；它不能是一个实例变量:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class Counter(dict):<br>…     def <strong>missing</strong>(self, key):<br>…         return 0<br>c &#x3D; Counter()<br>c[‘red’]<br>0<br>c[‘red’] +&#x3D; 1<br>c[‘red’]<br>1</p>
</blockquote>
</blockquote>
</blockquote>
<p>上面的例子显示了 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.Counter" title="collections.Counter"><code>collections.Counter</code></a> 实现的部分代码。 还有另一个不同的 <code>__missing__</code> 方法是由 <a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.defaultdict" title="collections.defaultdict"><code>collections.defaultdict</code></a> 所使用的。</p>
<p><code>d[key] = value</code></p>
<p>将 <code>d[key]</code> 设为 _value_。</p>
<p><code>del d[key]</code></p>
<p>将 <code>d[key]</code> 从 <em>d</em> 中移除。 如果映射中不存在 <em>key</em> 则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p><code>key in d</code></p>
<p>如果 <em>d</em> 中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>key not in d</code></p>
<p>等价于 <code>not key in d</code>。</p>
<p><code>iter(d)</code></p>
<p>返回以字典的键为元素的迭代器。 这是 <code>iter(d.keys())</code> 的快捷方式。</p>
<p><code>clear</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.clear" title="永久链接至目标"></a></p>
<p>移除字典中的所有元素。</p>
<p><code>copy</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.copy" title="永久链接至目标"></a></p>
<p>返回原字典的浅拷贝。</p>
<p><em>classmethod</em> <code>fromkeys</code>(<em>iterable</em>[, <em>value</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.fromkeys" title="永久链接至目标"></a></p>
<p>使用来自 <em>iterable</em> 的键创建一个新字典，并将键值设为 _value_。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.fromkeys" title="dict.fromkeys"><code>fromkeys()</code></a> 是一个返回新字典的类方法。 <em>value</em> 默认为 <code>None</code>。 所有值都只引用一个单独的实例，因此让 <em>value</em> 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#dict">字典推导式</a>。</p>
<p><code>get</code>(<em>key</em>[, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.get" title="永久链接至目标"></a></p>
<p>如果 <em>key</em> 存在于字典中则返回 <em>key</em> 的值，否则返回 _default_。 如果 <em>default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p><code>items</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.items" title="永久链接至目标"></a></p>
<p>返回由字典项 (<code>(键, 值)</code> 对) 组成的一个新视图。 参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict-views">视图对象文档</a>。</p>
<p><code>keys</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.keys" title="永久链接至目标"></a></p>
<p>返回由字典键组成的一个新视图。 参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict-views">视图对象文档</a>。</p>
<p><code>pop</code>(<em>key</em>[, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.pop" title="永久链接至目标"></a></p>
<p>如果 <em>key</em> 存在于字典中则将其移除并返回其值，否则返回 _default_。 如果 <em>default</em> 未给出且 <em>key</em> 不存在于字典中，则会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p><code>popitem</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.popitem" title="永久链接至目标"></a></p>
<p>从字典中移除并返回一个 <code>(键, 值)</code> 对。 键值对会按 LIFO 的顺序被返回。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.popitem" title="dict.popitem"><code>popitem()</code></a> 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.popitem" title="dict.popitem"><code>popitem()</code></a> 将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#KeyError" title="KeyError"><code>KeyError</code></a>。</p>
<p>在 3.7 版更改: 现在会确保采用 LIFO 顺序。 在之前的版本中，<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.popitem" title="dict.popitem"><code>popitem()</code></a> 会返回一个任意的键&#x2F;值对。</p>
<p><code>reversed(d)</code></p>
<p>返回一个逆序获取字典键的迭代器。 这是 <code>reversed(d.keys())</code> 的快捷方式。</p>
<p>3.8 新版功能.</p>
<p><code>setdefault</code>(<em>key</em>[, <em>default</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.setdefault" title="永久链接至目标"></a></p>
<p>如果字典存在键 <em>key</em> ，返回它的值。如果不存在，插入值为 <em>default</em> 的键 <em>key</em> ，并返回 <em>default</em> 。 <em>default</em> 默认为 <code>None</code>。</p>
<p><code>update</code>([<em>other</em>])<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.update" title="永久链接至目标"></a></p>
<p>使用来自 <em>other</em> 的键&#x2F;值对更新字典，覆盖原有的键。 返回 <code>None</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.update" title="dict.update"><code>update()</code></a> 接受另一个字典对象，或者一个包含键&#x2F;值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 如果给出了关键字参数，则会以其所指定的键&#x2F;值对更新字典: <code>d.update(red=1, blue=2)</code>。</p>
<p><code>values</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.values" title="永久链接至目标"></a></p>
<p>返回由字典值组成的一个新视图。 参见 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict-views">视图对象文档</a>。</p>
<p>两个 <code>dict.values()</code> 视图之间的相等性比较将总是返回 <code>False</code>。 这在 <code>dict.values()</code> 与其自身比较时也同样适用:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>d &#x3D; {‘a’: 1}<br>d.values() &#x3D;&#x3D; d.values()<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>d | other</code></p>
<p>合并 <em>d</em> 和 <em>other</em> 中的键和值来创建一个新的字典，两者必须都是字典。当 <em>d</em> 和 <em>other</em> 有相同键时， <em>other</em> 的值优先。</p>
<p>3.9 新版功能.</p>
<p><code>d |= other</code></p>
<p>用 <em>other</em> 的键和值更新字典 <em>d</em> ，<em>other</em> 可以是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-mapping">mapping</a> 或 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-iterable">iterable</a> 的键值对。当 <em>d</em> 和 <em>other</em> 有相同键时， <em>other</em> 的值优先。</p>
<p>3.9 新版功能.</p>
<p>两个字典的比较当且仅当它们具有相同的 <code>(键, 值)</code> 对时才会相等（不考虑顺序）。 排序比较 (‘&lt;’, ‘&lt;&#x3D;’, ‘&gt;&#x3D;’, ‘&gt;’) 会引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#TypeError" title="TypeError"><code>TypeError</code></a>。</p>
<p>字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>d &#x3D; {“one”: 1, “two”: 2, “three”: 3, “four”: 4}<br>d<br>{‘one’: 1, ‘two’: 2, ‘three’: 3, ‘four’: 4}<br>list(d)<br>[‘one’, ‘two’, ‘three’, ‘four’]<br>list(d.values())<br>[1, 2, 3, 4]<br>d[“one”] &#x3D; 42<br>d<br>{‘one’: 42, ‘two’: 2, ‘three’: 3, ‘four’: 4}<br>del d[“two”]<br>d[“two”] &#x3D; None<br>d<br>{‘one’: 42, ‘three’: 3, ‘four’: 4, ‘two’: None}</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.7 版更改: 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实现细节。</p>
<p>字典和字典视图都是可逆的。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>d &#x3D; {“one”: 1, “two”: 2, “three”: 3, “four”: 4}<br>d<br>{‘one’: 1, ‘two’: 2, ‘three’: 3, ‘four’: 4}<br>list(reversed(d))<br>[‘four’, ‘three’, ‘two’, ‘one’]<br>list(reversed(d.values()))<br>[4, 3, 2, 1]<br>list(reversed(d.items()))<br>[(‘four’, 4), (‘three’, 3), (‘two’, 2), (‘one’, 1)]</p>
</blockquote>
</blockquote>
</blockquote>
<p>在 3.8 版更改: 字典现在是可逆的。</p>
<p>参见</p>
<p> </p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code>types.MappingProxyType</code></a> 可被用来创建一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a> 的只读视图。</p>
<h3 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h3><p>由 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.keys" title="dict.keys"><code>dict.keys()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.values" title="dict.values"><code>dict.values()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict.items" title="dict.items"><code>dict.items()</code></a> 所返回的对象是 _视图对象_。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。</p>
<p>字典视图可以被迭代以产生与其对应的数据，并支持成员检测：</p>
<p><code>len(dictview)</code></p>
<p>返回字典中的条目数。</p>
<p><code>iter(dictview)</code></p>
<p>返回字典中的键、值或项（以 <code>(键, 值)</code> 为元素的元组表示）的迭代器。</p>
<p>键和值是按插入时的顺序进行迭代的。 这样就允许使用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#zip" title="zip"><code>zip()</code></a> 来创建 <code>(值, 键)</code> 对: <code>pairs = zip(d.values(), d.keys())</code>。 另一个创建相同列表的方式是 <code>pairs = [(v, k) for (k, v) in d.items()]</code>.</p>
<p>在添加或删除字典中的条目期间对视图进行迭代可能引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> 或者无法完全迭代所有条目。</p>
<p>在 3.7 版更改: 字典顺序会确保为插入顺序。</p>
<p><code>x in dictview</code></p>
<p>如果 <em>x</em> 是对应字典中存在的键、值或项（在最后一种情况下 <em>x</em> 应为一个 <code>(键, 值)</code> 元组） 则返回 <code>True</code>。</p>
<p><code>reversed(dictview)</code></p>
<p>返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。</p>
<p>在 3.8 版更改: 字典视图现在是可逆的。</p>
<p><code>dictview.mapping</code></p>
<p>返回 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code>types.MappingProxyType</code></a> 对象，封装了字典视图指向的原始字典。</p>
<p>3.10 新版功能.</p>
<p>Keys views are set-like since their entries are unique and <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-hashable">hashable</a>. If all values are hashable, so that <code>(key, value)</code> pairs are unique and hashable, then the items view is also set-like. (Values views are not treated as set-like since the entries are generally not unique.) For set-like views, all of the operations defined for the abstract base class <a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code>collections.abc.Set</code></a> are available (for example, <code>==</code>, <code>&lt;</code>, or <code>^</code>).</p>
<p>一个使用字典视图的示例:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>dishes &#x3D; {‘eggs’: 2, ‘sausage’: 1, ‘bacon’: 1, ‘spam’: 500}<br>keys &#x3D; dishes.keys()<br>values &#x3D; dishes.values()</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="iteration"><a href="#iteration" class="headerlink" title="iteration"></a>iteration</h1><p>n &#x3D; 0<br>for val in values:<br>…     n +&#x3D; val<br>print(n)<br>504</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="keys-and-values-are-iterated-over-in-the-same-order-insertion-order"><a href="#keys-and-values-are-iterated-over-in-the-same-order-insertion-order" class="headerlink" title="keys and values are iterated over in the same order (insertion order)"></a>keys and values are iterated over in the same order (insertion order)</h1><p>list(keys)<br>[‘eggs’, ‘sausage’, ‘bacon’, ‘spam’]<br>list(values)<br>[2, 1, 1, 500]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="view-objects-are-dynamic-and-reflect-dict-changes"><a href="#view-objects-are-dynamic-and-reflect-dict-changes" class="headerlink" title="view objects are dynamic and reflect dict changes"></a>view objects are dynamic and reflect dict changes</h1><p>del dishes[‘eggs’]<br>del dishes[‘sausage’]<br>list(keys)<br>[‘bacon’, ‘spam’]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="set-operations"><a href="#set-operations" class="headerlink" title="set operations"></a>set operations</h1><p>keys &amp; {‘eggs’, ‘bacon’, ‘salad’}<br>{‘bacon’}<br>keys ^ {‘sausage’, ‘juice’}<br>{‘juice’, ‘sausage’, ‘bacon’, ‘spam’}</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="get-back-a-read-only-proxy-for-the-original-dictionary"><a href="#get-back-a-read-only-proxy-for-the-original-dictionary" class="headerlink" title="get back a read-only proxy for the original dictionary"></a>get back a read-only proxy for the original dictionary</h1><p>values.mapping<br>mappingproxy({‘bacon’: 1, ‘spam’: 500})<br>values.mapping[‘spam’]<br>500</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="上下文管理器类型"><a href="#上下文管理器类型" class="headerlink" title="上下文管理器类型"></a>上下文管理器类型</h2><p>Python 的 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句支持通过上下文管理器所定义的运行时上下文这一概念。 此对象的实现使用了一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语句执行完毕时退出该上下文：</p>
<p><code>contextmanager.``__enter__</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#contextmanager.__enter__" title="永久链接至目标"></a></p>
<p>进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句的 <code>as</code> 子句中的标识符。</p>
<p>一个返回其自身的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-file-object">file object</a>。 文件对象会从 <strong>enter</strong>() 返回其自身，以允许 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#open" title="open"><code>open()</code></a> 被用作 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句中的上下文表达式。</p>
<p>一个返回关联对象的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.localcontext" title="decimal.localcontext"><code>decimal.localcontext()</code></a> 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 <code>with</code> 语句以外的代码。</p>
<p><code>contextmanager.``__exit__</code>(<em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em>)<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#contextmanager.__exit__" title="永久链接至目标"></a></p>
<p>退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 <code>None</code>。</p>
<p>自此方法返回一个真值将导致 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#with"><code>with</code></a> 语句屏蔽异常并继续执行紧随在 <code>with</code> 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 <code>with</code> 语句的语句体中发生的任何异常。</p>
<p>传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code>__exit__()</code></a> 方法是否确实已失败。</p>
<p>Python 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便地操作活动的十进制算术上下文。 除了实现上下文管理协议以外，不同类型不会被特殊处理。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code>contextlib</code></a> 模块查看相关的示例。</p>
<p>Python 的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generator">generator</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code>contextlib.contextmanager</code></a> 装饰器提供了实现这些协议的便捷方式。 如果使用 <a href="https://docs.python.org/zh-cn/3.10/library/contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code>contextlib.contextmanager</code></a> 装饰器来装饰一个生成器函数，它将返回一个实现了必要的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#contextmanager.__enter__" title="contextmanager.__enter__"><code>__enter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#contextmanager.__exit__" title="contextmanager.__exit__"><code>__exit__()</code></a> 方法的上下文管理器，而不再是由未经装饰的生成器所产生的迭代器。</p>
<p>请注意，Python&#x2F;C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这些方法的扩展类型必须将它们作为普通的 Python 可访问方法来提供。 与设置运行时上下文的开销相比，单个类字典查找的开销可以忽略不计。</p>
<h2 id="类型注解的类型-—Generic-Alias"><a href="#类型注解的类型-—Generic-Alias" class="headerlink" title="类型注解的类型 —Generic Alias"></a>类型注解的类型 —Generic Alias</h2><p><a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">type annotations</a> 的内置类型为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-genericalias">Generic Alias</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-union">Union</a>。</p>
<h3 id="GenericAlias-类型"><a href="#GenericAlias-类型" class="headerlink" title="GenericAlias 类型"></a>GenericAlias 类型</h3><p><code>GenericAlias</code> 对象通常是通过 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#subscriptions">抽取</a> 一个类来创建的。 它们最常被用于 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#sequence-types">容器类</a>，如 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a>。 举例来说，<code>list[int]</code> 这个 <code>GenericAlias</code> 对象是通过附带 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 参数抽取 <code>list</code> 类来创建的。 <code>GenericAlias</code> 对象的主要目的是用于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">类型标注</a>。</p>
<p>注解</p>
<p> </p>
<p>通常一个类只有在实现了特殊方法 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code>__class_getitem__()</code></a> 时才支持抽取操作。</p>
<p><code>GenericAlias</code> 对象可作为 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-generic-type">generic type</a> 的代理，实现了 _形参化泛型_。</p>
<p>对于一个容器类，提供给类的 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#subscriptions">抽取</a> 操作的参数可以指明对象所包含的元素类型。 例如，<code>set[bytes]</code> 可在类型标注中用来表示一个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a> 中的所有元素均为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类型。</p>
<p>对于一个定义了 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code>__class_getitem__()</code></a> 但不属于容器的类，提供给类的抽取操作的参数往往会指明在对象上定义的一个或多个方法的返回值类型。 例如，<a href="https://docs.python.org/zh-cn/3.10/library/re.html#module-re" title="re: Regular expression operations."><code>正则表达式</code></a> 可以被用在 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 数据类型和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 数据类型上:</p>
<ul>
<li><p>如果 <code>x = re.search(&#39;foo&#39;, &#39;foo&#39;)</code>，则 <code>x</code> 将为一个 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">re.Match</a> 对象而 <code>x.group(0)</code> 和 <code>x[0]</code> 的返回值将均为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 类型。 我们可以在类型标注中使用 <code>GenericAlias</code> <code>re.Match[str]</code> 来代表这种对象。</p>
</li>
<li><p>如果 <code>y = re.search(b&#39;bar&#39;, b&#39;bar&#39;)</code>，(注意 <code>b</code> 表示 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a>)，则 <code>y</code> 也将为一个 <code>re.Match</code> 的实例，但 <code>y.group(0)</code> 和 <code>y[0]</code> 的返回值将均为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 类型。 在类型标注中，我们将使用 <code>re.Match[bytes]</code> 来代表这种形式的 <a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">re.Match</a> 对象。</p>
</li>
</ul>
<p><code>GenericAlias</code> 对象是 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.GenericAlias" title="types.GenericAlias"><code>types.GenericAlias</code></a> 类的实例，该类也可被用来直接创建 <code>GenericAlias</code> 对象。</p>
<p><code>T[X, Y, ...]</code></p>
<p>创建一个代表由类型 <em>X</em>, <em>Y</em> 来参数化的类型 <code>T</code> 的 <code>GenericAlias</code>，此类型会更依赖于所使用的 <code>T</code>。 例如，一个接受包含 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> 元素的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a> 的函数:</p>
<p>def average(values: list[float]) -&gt; float:<br>    return sum(values) &#x2F; len(values)</p>
<p>另一个例子是关于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-mapping">mapping</a> 对象的，用到了 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a>，泛型的两个类型参数分别代表了键类型和值类型。本例中的函数需要一个 <code>dict</code>，其键的类型为 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a>，值的类型为 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a>:。</p>
<p>def send_post_request(url: str, body: dict[str, int]) -&gt; None:<br>    …</p>
<p>内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> 不接受第二个参数为 <code>GenericAlias</code> 类型：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance([1, 2], list[str])<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: isinstance() argument 2 cannot be a parameterized generic</p>
</blockquote>
</blockquote>
</blockquote>
<p>Python 运行时不会强制执行 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">类型标注</a>。 这种行为扩展到了泛型及其类型形参。 当由 <code>GenericAlias</code> 创建容器对象时，并不会检查容器中为元素指定的类型。 例如，以下代码虽然不被鼓励，但运行时并不会报错:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>t &#x3D; list[str]<br>t([1, 2, 3])<br>[1, 2, 3]</p>
</blockquote>
</blockquote>
</blockquote>
<p>不仅如此，在创建对象的过程中，应用了参数后的泛型还会抹除类型参数：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>t &#x3D; list[str]<br>type(t)<br>&lt;class ‘types.GenericAlias’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>l &#x3D; t()<br>type(l)<br>&lt;class ‘list’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>在泛型上调用 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#repr" title="repr"><code>repr()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str()</code></a> 会显示应用参数之后的类型：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>repr(list[int])<br>‘list[int]’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>str(list[int])<br>‘list[int]’</p>
</blockquote>
</blockquote>
</blockquote>
<p>调用泛型容器的 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code>__getitem__()</code></a> 方法将引发异常以防出现 <code>dict[str][str]</code> 之类的错误:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>dict[str][str]<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: There are no type variables left in dict[str]</p>
</blockquote>
</blockquote>
</blockquote>
<p>不过，当使用了 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#generics">类型变量</a> 时这种表达式是无效的。 索引必须有与 <code>GenericAlias</code> 对象的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#genericalias.__args__" title="genericalias.__args__"><code>__args__</code></a> 中的类型变量条目数量相当的元素。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from typing import TypeVar<br>Y &#x3D; TypeVar(‘Y’)<br>dict[str, Y][int]<br>dict[str, int]</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="标准泛型类"><a href="#标准泛型类" class="headerlink" title="标准泛型类"></a>标准泛型类</h4><p>下列标准库类支持形参化的泛型。 此列表并不是详尽无遗的。</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#list" title="list"><code>list</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#dict" title="dict"><code>dict</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#set" title="set"><code>set</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#frozenset" title="frozenset"><code>frozenset</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="type"><code>type</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.deque" title="collections.deque"><code>collections.deque</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.defaultdict" title="collections.defaultdict"><code>collections.defaultdict</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.Counter" title="collections.Counter"><code>collections.Counter</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.html#collections.ChainMap" title="collections.ChainMap"><code>collections.ChainMap</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>collections.abc.Awaitable</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>collections.abc.Coroutine</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>collections.abc.AsyncIterable</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>collections.abc.AsyncIterable</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code>collections.abc.AsyncGenerator</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code>collections.abc.Iterable</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code>collections.abc.Iterator</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code>collections.abc.Generator</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code>collections.abc.Reversible</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code>collections.abc.Container</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code>collections.abc.Collection</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code>collections.abc.Callable</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code>collections.abc.Set</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>collections.abc.MutableSet</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code>collections.abc.Mapping</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>collections.abc.MutableMapping</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code>collections.abc.Sequence</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code>collections.abc.MutableSequence</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code>collections.abc.ByteString</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code>collections.abc.MappingView</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code>collections.abc.KeysView</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code>collections.abc.ItemsView</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code>collections.abc.ValuesView</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code>contextlib.AbstractContextManager</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code>contextlib.AbstractAsyncContextManager</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/dataclasses.html#dataclasses.Field" title="dataclasses.Field"><code>dataclasses.Field</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.cached_property" title="functools.cached_property"><code>functools.cached_property</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/functools.html#functools.partialmethod" title="functools.partialmethod"><code>functools.partialmethod</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/os.html#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/queue.html#queue.LifoQueue" title="queue.LifoQueue"><code>queue.LifoQueue</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/queue.html#queue.Queue" title="queue.Queue"><code>queue.Queue</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/queue.html#queue.PriorityQueue" title="queue.PriorityQueue"><code>queue.PriorityQueue</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/queue.html#queue.SimpleQueue" title="queue.SimpleQueue"><code>queue.SimpleQueue</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#re-objects">re.Pattern</a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/re.html#match-objects">re.Match</a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/shelve.html#shelve.BsdDbShelf" title="shelve.BsdDbShelf"><code>shelve.BsdDbShelf</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/shelve.html#shelve.DbfilenameShelf" title="shelve.DbfilenameShelf"><code>shelve.DbfilenameShelf</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/shelve.html#shelve.Shelf" title="shelve.Shelf"><code>shelve.Shelf</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code>types.MappingProxyType</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/weakref.html#weakref.WeakKeyDictionary" title="weakref.WeakKeyDictionary"><code>weakref.WeakKeyDictionary</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/weakref.html#weakref.WeakMethod" title="weakref.WeakMethod"><code>weakref.WeakMethod</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/weakref.html#weakref.WeakSet" title="weakref.WeakSet"><code>weakref.WeakSet</code></a></p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/weakref.html#weakref.WeakValueDictionary" title="weakref.WeakValueDictionary"><code>weakref.WeakValueDictionary</code></a></p>
</li>
</ul>
<h4 id="GenericAlias-对象的特殊属性"><a href="#GenericAlias-对象的特殊属性" class="headerlink" title="GenericAlias 对象的特殊属性"></a><code>GenericAlias</code> 对象的特殊属性</h4><p>应用参数后的泛型都实现了一些特殊的只读属性：</p>
<p><code>genericalias.``__origin__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#genericalias.__origin__" title="永久链接至目标"></a></p>
<p>本属性指向未应用参数之前的泛型类：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>list[int].<strong>origin</strong><br>&lt;class ‘list’&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>genericalias.``__args__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#genericalias.__args__" title="永久链接至目标"></a></p>
<p>该属性是传给泛型类的原始 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code>__class_getitem__()</code></a> 的泛型所组成的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#tuple" title="tuple"><code>tuple</code></a> (长度可能为 1):</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>dict[str, list[int]].<strong>args</strong><br>(&lt;class ‘str’&gt;, list[int])</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>genericalias.``__parameters__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#genericalias.__parameters__" title="永久链接至目标"></a></p>
<p>该属性是延迟计算出来的一个元组（可能为空），包含了 <code>__args__</code> 中的类型变量。</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>from typing import TypeVar</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>T &#x3D; TypeVar(‘T’)<br>list[T].<strong>parameters</strong><br>(~T,)</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>带有参数 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#typing.ParamSpec" title="typing.ParamSpec"><code>typing.ParamSpec</code></a> 的 <code>GenericAlias</code> 对象，在类型替换后其 <code>__parameters__</code> 可能会不准确，因为 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#typing.ParamSpec" title="typing.ParamSpec"><code>typing.ParamSpec</code></a> 主要用于静态类型检查。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0484"><strong>PEP 484</strong></a> —— 类型注解</p>
<p>介绍 Python 中用于类型标注的框架。</p>
<p><a href="https://www.python.org/dev/peps/pep-0585"><strong>PEP 585</strong></a> - 标准多项集中的类型提示泛型</p>
<p>介绍了对标准库类进行原生形参化的能力，只要它们实现了特殊的类方法 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code>__class_getitem__()</code></a>。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/typing.html#generics">泛型（Generic）</a>, <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#user-defined-generics">用户自定义泛型</a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#typing.Generic" title="typing.Generic"><code>typing.Generic</code></a></p>
<p>有关如何实现可在运行时被形参化并能被静态类型检查器所识别的泛用类的文档。</p>
<p>3.9 新版功能.</p>
<h3 id="union-类型"><a href="#union-类型" class="headerlink" title="union 类型"></a>union 类型</h3><p>联合对象包含了在多个 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bltin-type-objects">类型对象</a> 上执行 <code>|</code> (按位或) 运算后的值。 这些类型主要用于 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-annotation">类型标注</a>。与 <a href="https://docs.python.org/zh-cn/3.10/library/typing.html#typing.Union" title="typing.Union"><code>typing.Union</code></a> 相比，联合类型表达式可以实现更简洁的类型提示语法。</p>
<p><code>X | Y | ...</code></p>
<p>定义包含了 <em>X_、_Y</em> 等类型的 union 对象。 <code>X | Y</code> 表示 X 或 Y。相当于 <code>typing.Union[X, Y]</code> 。比如以下函数的参数应为类型 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a> ：</p>
<p>def square(number: int | float) -&gt; int | float:<br>    return number ** 2</p>
<p><code>union_object == other</code></p>
<p>union 对象可与其他 union 对象进行比较。详细结果如下：</p>
<ul>
<li><p>多次组合的结果会平推：</p>
<p>  (int | str) | float &#x3D;&#x3D; int | str | float</p>
</li>
<li><p>冗余的类型会被删除：</p>
<p>  int | str | int &#x3D;&#x3D; int | str</p>
</li>
<li><p>在相互比较时，会忽略顺序：</p>
<p>  int | str &#x3D;&#x3D; str | int</p>
</li>
<li><p>与 <code>typing.union</code> 兼容：</p>
<p>  int | str &#x3D;&#x3D; typing.Union[int, str]</p>
</li>
<li><p>Optional 类型可表示为与 <code>None</code> 的组合。</p>
<p>  str | None &#x3D;&#x3D; typing.Optional[str]</p>
</li>
</ul>
<p><code>isinstance(obj, union_object)</code></p>
<p><code>issubclass(obj, union_object)</code></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#issubclass" title="issubclass"><code>issubclass()</code></a> 也支持 union 对象：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(“”, int | str)<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>但不能使用包含 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#types-genericalias">parameterized generics</a> 的 union 对象：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>isinstance(1, int | list[int])<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: isinstance() argument 2 cannot contain a parameterized generic</p>
</blockquote>
</blockquote>
</blockquote>
<p>union 对象构成的用户类型可以经由 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#types.UnionType" title="types.UnionType"><code>types.UnionType</code></a> 访问，并可用于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#isinstance" title="isinstance"><code>isinstance()</code></a> 检查。 而不能由类型直接实例化为对象：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import types<br>isinstance(int | str, types.UnionType)<br>True<br>types.UnionType()<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>TypeError: cannot create ‘types.UnionType’ instances</p>
</blockquote>
</blockquote>
</blockquote>
<p>注解</p>
<p> </p>
<p>为了支持 <code>X | Y</code> 语法，类型对象加入了 <code>__or__()</code> 方法。若是元类已实现了 <code>__or__()</code>，union 也可以覆盖掉：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class M(type):<br>…     def <strong>or</strong>(self, other):<br>…         return “Hello”<br>…<br>class C(metaclass&#x3D;M):<br>…     pass<br>…<br>C | int<br>‘Hello’<br>int | C<br>int | <strong>main</strong>.C</p>
</blockquote>
</blockquote>
</blockquote>
<p>参见</p>
<p> </p>
<p><a href="https://www.python.org/dev/peps/pep-0604"><strong>PEP 604</strong></a> —— 提出了 <code>X | Y</code> 语法和 union 类型。</p>
<p>3.10 新版功能.</p>
<h2 id="其他内置类型"><a href="#其他内置类型" class="headerlink" title="其他内置类型"></a>其他内置类型</h2><p>解释器支持一些其他种类的对象。 这些对象大都仅支持一两种操作。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块唯一的特殊操作是属性访问: <code>m.name</code>，这里 <em>m</em> 为一个模块而 <em>name</em> 访问定义在 <em>m</em> 的符号表中的一个名称。 模块属性可以被赋值。 （请注意 <a href="https://docs.python.org/zh-cn/3.10/reference/simple_stmts.html#import"><code>import</code></a> 语句严格来说也是对模块对象的一种操作；<code>import foo</code> 不要求存在一个名为 <em>foo</em> 的模块对象，而是要求存在一个对于名为 <em>foo</em> 的模块的 (永久性) _定义_。）</p>
<p>每个模块都有一个特殊属性 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a>。 这是包含模块的符号表的字典。 修改此字典将实际改变模块的符号表，但是无法直接对 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a> 赋值 (你可以写 <code>m.__dict__[&#39;a&#39;] = 1</code>，这会将 <code>m.a</code> 定义为 <code>1</code>，但是你不能写 <code>m.__dict__ = &#123;&#125;</code>)。 不建议直接修改 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="object.__dict__"><code>__dict__</code></a>。</p>
<p>内置于解释器中的模块会写成这样: <code>&lt;module &#39;sys&#39; (built-in)&gt;</code>。 如果是从一个文件加载，则会写成 <code>&lt;module &#39;os&#39; from &#39;/usr/local/lib/pythonX.Y/os.pyc&#39;&gt;</code>。</p>
<h3 id="类与类实例"><a href="#类与类实例" class="headerlink" title="类与类实例"></a>类与类实例</h3><p>关于这些类型请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#objects">对象、值与类型</a> 和 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#class">类定义</a>。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对象是通过函数定义创建的。 对函数对象的唯一操作是调用它: <code>func(argument-list)</code>。</p>
<p>实际上存在两种不同的函数对象：内置函数和用户自定义函数。 两者支持同样的操作（调用函数），但实现方式不同，因此对象类型也不同。</p>
<p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#function">函数定义</a>。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是使用属性表示法来调用的函数。 存在两种形式：内置方法（例如列表的 <code>append()</code> 方法）和类实例方法。 内置方法由支持它们的类型来描述。</p>
<p>如果你通过一个实例来访问方法（即定义在类命名空间内的函数），你会得到一个特殊对象: <em>绑定方法</em> (或称 <em>实例方法</em>) 对象。 当被调用时，它会将 <code>self</code> 参数添加到参数列表。 绑定方法具有两个特殊的只读属性: <code>m.__self__</code> 操作该方法的对象，而 <code>m.__func__</code> 是实现该方法的函数。 调用 <code>m(arg-1, arg-2, ..., arg-n)</code> 完全等价于调用 <code>m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)</code>。</p>
<p>与函数对象类似，绑定方法对象也支持获取任意属性。 但是，由于方法属性实际上保存于下层的函数对象中 (<code>meth.__func__</code>)，因此不允许设置绑定方法的方法属性。 尝试设置方法的属性将会导致引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#AttributeError" title="AttributeError"><code>AttributeError</code></a>。 想要设置方法属性，你必须在下层的函数对象中显式地对其进行设置:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>class C:<br>…     def method(self):<br>…         pass<br>…<br>c &#x3D; C()<br>c.method.whoami &#x3D; ‘my name is method’  # can’t set on the method<br>Traceback (most recent call last):<br>  File “<stdin>“, line 1, in <module><br>AttributeError: ‘method’ object has no attribute ‘whoami’<br>c.method.<strong>func</strong>.whoami &#x3D; ‘my name is method’<br>c.method.whoami<br>‘my name is method’</p>
</blockquote>
</blockquote>
</blockquote>
<p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#types">标准类型层级结构</a>。</p>
<h3 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h3><p>代码对象被具体实现用来表示“伪编译”的可执行 Python 代码，例如一个函数体。 它们不同于函数对象，因为它们不包含对其全局执行环境的引用。 代码对象由内置的 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#compile" title="compile"><code>compile()</code></a> 函数返回，并可通过从函数对象的 <code>__code__</code> 属性从中提取。 另请参阅 <a href="https://docs.python.org/zh-cn/3.10/library/code.html#module-code" title="code: Facilities to implement read-eval-print loops."><code>code</code></a> 模块。</p>
<p>访问 <code>__code__</code> 会触发 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#auditing">审计事件</a> <code>object.__getattr__</code>，参数为 <code>obj</code> 和 <code>&quot;__code__&quot;</code>。</p>
<p>可以通过将代码对象（而非源码字符串）传给 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#exec" title="exec"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#eval" title="eval"><code>eval()</code></a> 内置函数来执行或求值。</p>
<p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#types">标准类型层级结构</a>。</p>
<h3 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h3><p>类型对象表示各种对象类型。 对象的类型可通过内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#type" title="type"><code>type()</code></a> 来获取。 类型没有特殊的操作。 标准库模块 <a href="https://docs.python.org/zh-cn/3.10/library/types.html#module-types" title="types: Names for built-in types."><code>types</code></a> 定义了所有标准内置类型的名称。</p>
<p>类型以这样的写法来表示: <code>&lt;class &#39;int&#39;&gt;</code>。</p>
<h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><p>此对象会由不显式地返回值的函数所返回。 它不支持任何特殊的操作。 空对象只有一种值 <code>None</code> (这是个内置名称)。 <code>type(None)()</code> 会生成同一个单例。</p>
<p>该对象的写法为 <code>None</code>。</p>
<h3 id="省略符对象"><a href="#省略符对象" class="headerlink" title="省略符对象"></a>省略符对象</h3><p>此对象常被用于切片 (参见 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#slicings">切片</a>)。 它不支持任何特殊的操作。 省略符对象只有一种值 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#Ellipsis" title="Ellipsis"><code>Ellipsis</code></a> (这是个内置名称)。 <code>type(Ellipsis)()</code> 会生成 <a href="https://docs.python.org/zh-cn/3.10/library/constants.html#Ellipsis" title="Ellipsis"><code>Ellipsis</code></a> 单例。</p>
<p>该对象的写法为 <code>Ellipsis</code> 或 <code>...</code>。</p>
<h3 id="未实现对象"><a href="#未实现对象" class="headerlink" title="未实现对象"></a>未实现对象</h3><p>此对象会被作为比较和二元运算被应用于它们所不支持的类型时的返回值。 请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/expressions.html#comparisons">比较运算</a> 了解更多信息。 未实现对象只有一种值 <code>NotImplemented</code>。 <code>type(NotImplemented)()</code> 会生成这个单例。</p>
<p>该对象的写法为 <code>NotImplemented</code>。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值是两个常量对象 <code>False</code> 和 <code>True</code>。 它们被用来表示逻辑上的真假（不过其他值也可被当作真值或假值）。 在数字类的上下文中（例如被用作算术运算符的参数时），它们的行为分别类似于整数 0 和 1。 内置函数 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bool" title="bool"><code>bool()</code></a> 可被用来将任意值转换为布尔值，只要该值可被解析为一个逻辑值（参见之前的 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#truth">逻辑值检测</a> 部分）。</p>
<p>该对象的写法分别为 <code>False</code> 和 <code>True</code>。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p>有关此对象的信息请参阅 <a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#types">标准类型层级结构</a>。 其中描述了栈帧对象、回溯对象以及切片对象等等。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>语言实现为部分对象类型添加了一些特殊的只读属性，它们具有各自的作用。 其中一些并不会被 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#dir" title="dir"><code>dir()</code></a> 内置函数所列出。</p>
<p><code>object.``__dict__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#object.__dict__" title="永久链接至目标"></a></p>
<p>一个字典或其他类型的映射对象，用于存储对象的（可写）属性。</p>
<p><code>instance.``__class__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#instance.__class__" title="永久链接至目标"></a></p>
<p>类实例所属的类。</p>
<p><code>class.``__bases__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__bases__" title="永久链接至目标"></a></p>
<p>由类对象的基类所组成的元组。</p>
<p><code>definition.``__name__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#definition.__name__" title="永久链接至目标"></a></p>
<p>类、函数、方法、描述器或生成器实例的名称。</p>
<p><code>definition.``__qualname__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#definition.__qualname__" title="永久链接至目标"></a></p>
<p>类、函数、方法、描述器或生成器实例的 <a href="https://docs.python.org/zh-cn/3.10/glossary.html#term-qualified-name">qualified name</a>。</p>
<p>3.3 新版功能.</p>
<p><code>class.``__mro__</code><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__mro__" title="永久链接至目标"></a></p>
<p>此属性是由类组成的元组，在方法解析期间会基于它来查找基类。</p>
<p><code>class.``mro</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.mro" title="永久链接至目标"></a></p>
<p>此方法可被一个元类来重载，以为其实例定制方法解析顺序。 它会在类实例化时被调用，其结果存储于 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__mro__" title="class.__mro__"><code>__mro__</code></a> 之中。</p>
<p><code>class.``__subclasses__</code>()<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#class.__subclasses__" title="永久链接至目标"></a></p>
<p>每个类都存有对直接子类的弱引用列表。本方法返回所有存活引用的列表。列表的顺序按照子类定义的排列。例如：</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>int.<strong>subclasses</strong>()<br>[&lt;class ‘bool’&gt;]</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="整数字符串转换长度限制"><a href="#整数字符串转换长度限制" class="headerlink" title="整数字符串转换长度限制"></a>整数字符串转换长度限制</h2><p>CPython 对于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 之间的转换有一个全局限制以缓解拒绝服务攻击。 此限制 <em>仅会</em> 作用于十进制或其他以非二的乘方为基数的数字。 十六进制、八进制和二进制转换不受限制。 该限制可以被配置。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 类型在 CPython 中是存储为二进制形式的任意长度的数字（通常称为“大数字”）。 不存在可在线性时间内将一个字符串转换为二进制整数或将一个二进制整数转换为字符串的算法，<em>除非</em> 基数为 2 的乘方。 对于基数为 10 来说已知最好的算法也有亚二次方复杂度。 转换一个大数值如 <code>int(&#39;1&#39; * 500_000)</code> 在快速的 CPU 上也会花费一秒以上的时间。</p>
<p>限制转换大小提供了一个避免 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735">CVE-2020-10735</a> 的可行方法。</p>
<p>此限制会在可能涉及非线性转换算法时作用于输入或输出字符串中的数字型字符数量。 下划线和正负号不计入限制数量。</p>
<p>当一个操作会超出限制时，将引发 <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#ValueError" title="ValueError"><code>ValueError</code></a>:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import sys<br>sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.<br>_ &#x3D; int(‘2’ * 5432)<br>Traceback (most recent call last):<br>…<br>ValueError: Exceeds the limit (4300) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit.<br>i &#x3D; int(‘2’ * 4300)<br>len(str(i))<br>4300<br>i_squared &#x3D; i<em>i<br>len(str(i_squared))<br>Traceback (most recent call last):<br>…<br>ValueError: Exceeds the limit (4300) for integer string conversion: value has 8599 digits; use sys.set_int_max_str_digits() to increase the limit.<br>len(hex(i_squared))<br>7144<br>assert int(hex(i_squared), base&#x3D;16) &#x3D;&#x3D; i</em>i  # Hexadecimal is unlimited.</p>
</blockquote>
</blockquote>
</blockquote>
<p>默认限制为 4300 位即 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.int_info" title="sys.int_info"><code>sys.int_info.default_max_str_digits</code></a> 的值。 最低限制可被配置为 640 位即 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.int_info" title="sys.int_info"><code>sys.int_info.str_digits_check_threshold</code></a>。</p>
<p>验证:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import sys<br>assert sys.int_info.default_max_str_digits &#x3D;&#x3D; 4300, sys.int_info<br>assert sys.int_info.str_digits_check_threshold &#x3D;&#x3D; 640, sys.int_info<br>msg &#x3D; int(‘578966293710682886880994035146873798396722250538762761564’<br>…           ‘9252925514383915483333812743580549779436104706260696366600’<br>…           ‘571186405732’).to_bytes(53, ‘big’)<br>…</p>
</blockquote>
</blockquote>
</blockquote>
<p>3.10.7 新版功能.</p>
<h3 id="受影响的-API"><a href="#受影响的-API" class="headerlink" title="受影响的 API"></a>受影响的 API</h3><p>此限制仅会作用于 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#int" title="int"><code>int</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#bytes" title="bytes"><code>bytes</code></a> 之间存在速度变慢可能的转换:</p>
<ul>
<li><p><code>int(string)</code> 默认以 10 为基数。</p>
</li>
<li><p><code>int(string, base)</code> 用于所有不为 2 的乘方的基数。</p>
</li>
<li><p><code>str(integer)</code>。</p>
</li>
<li><p><code>repr(integer)</code>。</p>
</li>
<li><p>任何其他目标是以 10 为基数的字符串转换，例如 <code>f&quot;&#123;integer&#125;&quot;</code>, <code>&quot;&#123;&#125;&quot;.format(integer)</code> 或 <code>b&quot;%d&quot; % integer</code>。</p>
</li>
</ul>
<p>此限制不会作用于使用线性算法的函数:</p>
<ul>
<li><p><code>int(string, base)</code> 中 base 可以为 2, 4, 8, 16 或 32。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.from_bytes" title="int.from_bytes"><code>int.from_bytes()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#int.to_bytes" title="int.to_bytes"><code>int.to_bytes()</code></a>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/functions.html#hex" title="hex"><code>hex()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#oct" title="oct"><code>oct()</code></a>, <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#bin" title="bin"><code>bin()</code></a>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/string.html#formatspec">格式规格迷你语言</a> 用于十六进制、八进制和二进制数。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 至 <a href="https://docs.python.org/zh-cn/3.10/library/functions.html#float" title="float"><code>float</code></a>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#str" title="str"><code>str</code></a> 至 <a href="https://docs.python.org/zh-cn/3.10/library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code>decimal.Decimal</code></a>。</p>
</li>
</ul>
<h3 id="配置限制值"><a href="#配置限制值" class="headerlink" title="配置限制值"></a>配置限制值</h3><p>在 Python 启动之前你可以使用环境变量或解释器命令行旗标来配置限制值:</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#envvar-PYTHONINTMAXSTRDIGITS"><code>PYTHONINTMAXSTRDIGITS</code></a>，例如 <code>PYTHONINTMAXSTRDIGITS=640 python3</code> 是将限制设为 640 而 <code>PYTHONINTMAXSTRDIGITS=0 python3</code> 是禁用此限制。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-X"><code>-X int_max_str_digits</code></a>，例如 <code>python3 -X int_max_str_digits=640</code></p>
</li>
<li><p><code>sys.flags.int_max_str_digits</code> 包含 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#envvar-PYTHONINTMAXSTRDIGITS"><code>PYTHONINTMAXSTRDIGITS</code></a> 或 <a href="https://docs.python.org/zh-cn/3.10/using/cmdline.html#cmdoption-X"><code>-X int_max_str_digits</code></a> 的值。 如果环境变量和 <code>-X</code> 选项均有设置，则 <code>-X</code> 选项优先。 值为 <em>-1</em> 表示两者均未设置，因此会在初始化时使用 <code>sys.int_info.default_max_str_digits</code> 的值。</p>
</li>
</ul>
<p>从代码中，你可以检查当前的限制并使用这些 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code>sys</code></a> API 来设置新值:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.get_int_max_str_digits" title="sys.get_int_max_str_digits"><code>sys.get_int_max_str_digits()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.set_int_max_str_digits" title="sys.set_int_max_str_digits"><code>sys.set_int_max_str_digits()</code></a> 是解释器级限制的读取器和设置器。 子解释器具有它们自己的限制。</li>
</ul>
<p>Information about the default and minimum can be found in <a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.int_info" title="sys.int_info"><code>sys.int_info</code></a>:</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.int_info" title="sys.int_info"><code>sys.int_info.default_max_str_digits</code></a> 是已编译的默认限制。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/sys.html#sys.int_info" title="sys.int_info"><code>sys.int_info.str_digits_check_threshold</code></a> 是该限制可接受的最低值（禁用该限制的 0 除外）。</p>
</li>
</ul>
<p>3.10.7 新版功能.</p>
<p>警告</p>
<p> </p>
<p>设置较低的限制值 <em>可能</em> 导致问题。 虽然不常见，但还是会有在其源代码中包含超出最小阈值的十进制整数常量的代码存在。 设置此限制的一个后果将是包含比此限制长的十进制整数字面值的 Python 源代码将在解析期间遇到错误，通常是在启动时或导入时甚至是在安装时 —— 只要对于某个代码还不存在已更新的 <code>.pyc</code> 就会发生。 一种在包含此类大数值常量的源代码中绕过该问题的办法是将它们转换为不受限制的 <code>0x</code> 十六进制形式。</p>
<p>如果你使用了较低的限制则请要彻底地测试你的应用程序。 确保你的测试通过环境变量或旗标尽早设置该限制来运行以便在启动期间甚至是在可能发起调用 Python 来将 <code>.py</code> 源文件预编译为 <code>.pyc</code> 文件的任何安装步骤其间应用该限制。</p>
<h3 id="推荐配置"><a href="#推荐配置" class="headerlink" title="推荐配置"></a>推荐配置</h3><p>The default <code>sys.int_info.default_max_str_digits</code> is expected to be reasonable for most applications. If your application requires a different limit, set it from your main entry point using Python version agnostic code as these APIs were added in security patch releases in versions before 3.11.</p>
<p>示例:</p>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>import sys<br>if hasattr(sys, “set_int_max_str_digits”):<br>…     upper_bound &#x3D; 68000<br>…     lower_bound &#x3D; 4004<br>…     current_limit &#x3D; sys.get_int_max_str_digits()<br>…     if current_limit &#x3D;&#x3D; 0 or current_limit &gt; upper_bound:<br>…         sys.set_int_max_str_digits(upper_bound)<br>…     elif current_limit &lt; lower_bound:<br>…         sys.set_int_max_str_digits(lower_bound)</p>
</blockquote>
</blockquote>
</blockquote>
<p>如果你需要完全禁用它，请将其设为 <code>0</code>。</p>
<p>备注</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id1">1</a></p>
<p>有关这些特殊方法的额外信息可参看 Python 参考指南 (<a href="https://docs.python.org/zh-cn/3.10/reference/datamodel.html#customization">基本定制</a>)。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id2">2</a></p>
<p>作为结果，列表 <code>[1, 2]</code> 与 <code>[1.0, 2.0]</code> 是相等的，元组的情况也类似。</p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id4">3</a></p>
<p>必须如此，因为解析器无法判断操作数的类型。</p>
<p>4(<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id6">1</a>,<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id7">2</a>,<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id8">3</a>,<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id9">4</a>)</p>
<p>区分大小写的字符是指所属一般类别属性为 “Lu” (Letter, uppercase), “Ll” (Letter, lowercase) 或 “Lt” (Letter, titlecase) 之一的字符。</p>
<p>5(<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id10">1</a>,<a href="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#id11">2</a>)</p>
<p>若只是要格式化一个元组，则应提供一个单例元组，其中只包含一个元素，就是需要格式化的那个元组。</p>
]]></content>
      <tags>
        <tag>Python Python标准库 内置类型 逻辑值检测 布尔运算 比较运算 数字类型 迭代器 序列类型 文本序列类型 二进制序列类型 集合类型 映射类型 上下文管理器类型 类型注解的类型 其他内置类型 特殊属性 整数字符串转换长度限制</tag>
      </tags>
  </entry>
</search>
